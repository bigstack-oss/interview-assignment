var s0 = Object.defineProperty;
var a0 = (e, t, n) => t in e ? s0(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var ho = (e, t, n) => (a0(e, typeof t != "symbol" ? t + "" : t, n), n);
import Us from "react";
var Tf = /* @__PURE__ */ ((e) => (e.RENDER_FINISHED = "render-finished", e.RESIZE = "chart-resize", e.MOUSEOVER = "chart-mouseover", e.MOUSEOUT = "chart-mouseout", e))(Tf || {}), Mf = /* @__PURE__ */ ((e) => (e.SHOW = "show-modal", e.HIDE = "hide-modal", e))(Mf || {}), Cf = /* @__PURE__ */ ((e) => (e.UPDATE = "model-update", e))(Cf || {}), $f = /* @__PURE__ */ ((e) => (e.SHOW_OVERFLOW_MENU = "show-toolbar-overflow-menu", e.HIDE_OVERFLOW_MENU = "hide-toolbar-overflow-menu", e.BUTTON_CLICK = "toolbar-button-click", e))($f || {}), Af = /* @__PURE__ */ ((e) => (e.UPDATE = "zoom-bar-update", e.SELECTION_START = "zoom-bar-selection-start", e.SELECTION_IN_PROGRESS = "zoom-bar-selection-in-progress", e.SELECTION_END = "zoom-bar-selection-end", e))(Af || {}), Lf = /* @__PURE__ */ ((e) => (e.CHANGE = "zoom-domain-change", e))(Lf || {}), Df = /* @__PURE__ */ ((e) => (e.CANVAS_ZOOM_IN = "canvas-zoom-in", e.CANVAS_ZOOM_OUT = "canvas-zoom-out", e))(Df || {}), kf = /* @__PURE__ */ ((e) => (e.LABEL_MOUSEOVER = "axis-label-mouseover", e.LABEL_MOUSEMOVE = "axis-label-mousemove", e.LABEL_CLICK = "axis-label-click", e.LABEL_MOUSEOUT = "axis-label-mouseout", e.LABEL_FOCUS = "axis-label-focus", e.LABEL_BLUR = "axis-label-blur", e.RENDER_COMPLETE = "axis-render-complete", e))(kf || {}), Rf = /* @__PURE__ */ ((e) => (e.POINT_MOUSEOVER = "scatter-mouseover", e.POINT_MOUSEMOVE = "scatter-mousemove", e.POINT_CLICK = "scatter-click", e.POINT_MOUSEOUT = "scatter-mouseout", e))(Rf || {}), If = /* @__PURE__ */ ((e) => (e.WORD_MOUSEOVER = "wordcloud-word-mouseover", e.WORD_MOUSEMOVE = "wordcloud-word-mousemove", e.WORD_CLICK = "wordcloud-word-click", e.WORD_MOUSEOUT = "wordcloud-word-mouseout", e))(If || {}), Nf = /* @__PURE__ */ ((e) => (e.SLICE_MOUSEOVER = "pie-slice-mouseover", e.SLICE_MOUSEMOVE = "pie-slice-mousemove", e.SLICE_CLICK = "pie-slice-click", e.SLICE_MOUSEOUT = "pie-slice-mouseout", e))(Nf || {}), Pf = /* @__PURE__ */ ((e) => (e.ARC_MOUSEOVER = "gauge-arc-mouseover", e.ARC_MOUSEMOVE = "gauge-arc-mousemove", e.ARC_CLICK = "gauge-arc-click", e.ARC_MOUSEOUT = "gauge-arc-mouseout", e))(Pf || {}), Uf = /* @__PURE__ */ ((e) => (e.BAR_MOUSEOVER = "bar-mouseover", e.BAR_MOUSEMOVE = "bar-mousemove", e.BAR_CLICK = "bar-click", e.BAR_MOUSEOUT = "bar-mouseout", e))(Uf || {}), Bf = /* @__PURE__ */ ((e) => (e.BOX_MOUSEOVER = "box-mouseover", e.BOX_MOUSEMOVE = "box-mousemove", e.BOX_CLICK = "box-click", e.BOX_MOUSEOUT = "box-mouseout", e.OUTLIER_MOUSEOVER = "outlier-mouseover", e.OUTLIER_MOUSEMOVE = "outlier-mousemove", e.OUTLIER_CLICK = "outlier-click", e.OUTLIER_MOUSEOUT = "outlier-mouseout", e))(Bf || {}), Vf = /* @__PURE__ */ ((e) => (e.SCATTER_MOUSEOVER = "scatter-mouseover", e.SCATTER_MOUSEMOVE = "scatter-mousemove", e.SCATTER_CLICK = "scatter-click", e.SCATTER_MOUSEOUT = "scatter-mouseout", e))(Vf || {}), Hf = /* @__PURE__ */ ((e) => (e.POINT_MOUSEOVER = "scatter-mouseover", e.POINT_MOUSEMOVE = "scatter-mousemove", e.POINT_CLICK = "scatter-click", e.POINT_MOUSEOUT = "scatter-mouseout", e))(Hf || {}), Ff = /* @__PURE__ */ ((e) => (e.X_AXIS_MOUSEOVER = "radar-x-axis-mouseover", e.X_AXIS_MOUSEMOVE = "radar-x-axis-mousemove", e.X_AXIS_CLICK = "radar-x-axis-click", e.X_AXIS_MOUSEOUT = "radar-x-axis-mouseout", e))(Ff || {}), Gf = /* @__PURE__ */ ((e) => (e.NODE_MOUSEOVER = "tree-node-mouseover", e.NODE_CLICK = "tree-node-click", e.NODE_MOUSEOUT = "tree-node-mouseout", e))(Gf || {}), zf = /* @__PURE__ */ ((e) => (e.LEAF_MOUSEOVER = "leaf-mouseover", e.LEAF_MOUSEMOVE = "leaf-mousemove", e.LEAF_CLICK = "leaf-click", e.LEAF_MOUSEOUT = "leaf-mouseout", e))(zf || {}), wi = /* @__PURE__ */ ((e) => (e.SHOW = "show-tooltip", e.MOVE = "move-tooltip", e.HIDE = "hide-tooltip", e))(wi || {}), jf = /* @__PURE__ */ ((e) => (e.SHOW = "show-threshold", e.HIDE = "hide-threshold", e))(jf || {}), Wf = /* @__PURE__ */ ((e) => (e.ITEM_HOVER = "legend-item-onhover", e.ITEM_CLICK = "legend-item-onclick", e.ITEM_MOUSEOUT = "legend-item-onmouseout", e.ITEMS_UPDATE = "legend-items-update", e))(Wf || {}), qf = /* @__PURE__ */ ((e) => (e.CIRCLE_MOUSEOVER = "circle-leaf-mouseover", e.CIRCLE_CLICK = "circle-leaf-click", e.CIRCLE_MOUSEOUT = "circle-leaf-mouseout", e.CIRCLE_MOUSEMOVE = "circle-leaf-mousemove", e))(qf || {}), Yf = /* @__PURE__ */ ((e) => (e.NODE_MOUSEOVER = "alluvial-node-mouseover", e.NODE_CLICK = "alluvial-node-click", e.NODE_MOUSEOUT = "alluvial-node-mouseout", e.NODE_MOUSEMOVE = "alluvial-node-mousemove", e.LINE_MOUSEOVER = "alluvial-line-mouseover", e.LINE_CLICK = "alluvial-line-click", e.LINE_MOUSEOUT = "alluvial-line-mouseout", e.LINE_MOUSEMOVE = "alluvial-line-mousemove", e))(Yf || {}), Xf = /* @__PURE__ */ ((e) => (e.METER_MOUSEOVER = "meter-mouseover", e.METER_CLICK = "meter-click", e.METER_MOUSEOUT = "meter-mouseout", e.METER_MOUSEMOVE = "meter-mousemove", e))(Xf || {}), Zf = /* @__PURE__ */ ((e) => (e.HEATMAP_MOUSEOVER = "heatmap-mouseover", e.HEATMAP_CLICK = "heatmap-click", e.HEATMAP_MOUSEOUT = "heatmap-mouseout", e.HEATMAP_MOUSEMOVE = "hetmap-mousemove", e))(Zf || {}), wr = /* @__PURE__ */ ((e) => (e.CHOROPLETH_MOUSEOVER = "choropleth-mouseover", e.CHOROPLETH_CLICK = "choropleth-click", e.CHOROPLETH_MOUSEOUT = "choropleth-mouseout", e.CHOROPLETH_MOUSEMOVE = "choropleth-mousemove", e))(wr || {});
const o0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alluvial: Yf,
  Area: Rf,
  Axis: kf,
  Bar: Uf,
  Boxplot: Bf,
  CanvasZoom: Df,
  Chart: Tf,
  Choropleth: wr,
  CirclePack: qf,
  Gauge: Pf,
  Heatmap: Zf,
  Legend: Wf,
  Line: Hf,
  Meter: Xf,
  Modal: Mf,
  Model: Cf,
  Pie: Nf,
  Radar: Ff,
  Scatter: Vf,
  Threshold: jf,
  Toolbar: $f,
  Tooltip: wi,
  Tree: Gf,
  Treemap: zf,
  WordCloud: If,
  ZoomBar: Af,
  ZoomDomain: Lf
}, Symbol.toStringTag, { value: "Module" })), O = o0;
var K = /* @__PURE__ */ ((e) => (e.HTML = "html", e.SVG = "svg", e))(K || {}), Kf = /* @__PURE__ */ ((e) => (e.WHITE = "white", e.G100 = "g100", e.G90 = "g90", e.G10 = "g10", e))(Kf || {}), et = /* @__PURE__ */ ((e) => (e.BACKGROUND = "background", e.FILL = "fill", e.STROKE = "stroke", e.TOOLTIP = "tooltip", e))(et || {}), H = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e.TOP = "top", e.BOTTOM = "bottom", e))(H || {}), We = /* @__PURE__ */ ((e) => (e.GRAPH_VIEW = "graph_view", e.SLIDER_VIEW = "slider_view", e))(We || {}), Ie = /* @__PURE__ */ ((e) => (e.END_LINE = "end_line", e.MID_LINE = "mid_line", e.FRONT_LINE = "front_line", e.NONE = "none", e))(Ie || {}), Kt = /* @__PURE__ */ ((e) => (e.VERTICAL = "vertical", e.HORIZONTAL = "horizontal", e))(Kt || {}), X = /* @__PURE__ */ ((e) => (e.TIME = "time", e.LINEAR = "linear", e.LOG = "log", e.LABELS = "labels", e.LABELS_RATIO = "labels-ratio", e))(X || {}), _i = /* @__PURE__ */ ((e) => (e.RIGHT = "right", e.LEFT = "left", e.TOP = "top", e.BOTTOM = "bottom", e))(_i || {}), Yt = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.CENTER = "center", e.RIGHT = "right", e))(Yt || {}), Li = /* @__PURE__ */ ((e) => (e.HORIZONTAL = "horizontal", e.VERTICAL = "vertical", e))(Li || {}), lc = /* @__PURE__ */ ((e) => (e.TREE = "tree", e.DENDROGRAM = "dendrogram", e))(lc || {}), Lt = /* @__PURE__ */ ((e) => (e.ROW = "row", e.COLUMN = "column", e.ROW_REVERSE = "row-reverse", e.COLUMN_REVERSE = "column-reverse", e))(Lt || {}), st = /* @__PURE__ */ ((e) => (e.FIXED = "fixed", e.PREFERRED = "preferred", e.STRETCH = "stretch", e))(st || {}), Wr = /* @__PURE__ */ ((e) => (e.CENTER = "center", e))(Wr || {}), bs = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(bs || {}), qt = /* @__PURE__ */ ((e) => (e.GRID = "grid", e.VERT_OR_HORIZ = "vertOrHoriz", e.PIE = "pie", e.DONUT = "donut", e))(qt || {}), rn = /* @__PURE__ */ ((e) => (e.START = "start", e.MIDDLE = "middle", e.END = "end", e))(rn || {}), sn = /* @__PURE__ */ ((e) => (e.BASELINE = "baseline", e.MIDDLE = "middle", e.HANGING = "hanging", e))(sn || {}), _r = /* @__PURE__ */ ((e) => (e.SEMI = "semi", e.FULL = "full", e))(_r || {}), Xo = /* @__PURE__ */ ((e) => (e.UP = "up", e.DOWN = "down", e))(Xo || {}), ws = /* @__PURE__ */ ((e) => (e.SUCCESS = "success", e.WARNING = "warning", e.DANGER = "danger", e))(ws || {}), _s = /* @__PURE__ */ ((e) => (e.ALWAYS = "always", e.AUTO = "auto", e.NEVER = "never", e))(_s || {}), Te = /* @__PURE__ */ ((e) => (e.SCATTER = "scatter", e.LINE = "line", e.SIMPLE_BAR = "simple-bar", e.STACKED_BAR = "stacked-bar", e.GROUPED_BAR = "grouped-bar", e.AREA = "area", e.STACKED_AREA = "stacked-area", e))(Te || {}), Ut = /* @__PURE__ */ ((e) => (e.EXPORT_CSV = "Export as CSV", e.EXPORT_PNG = "Export as PNG", e.EXPORT_JPG = "Export as JPG", e.ZOOM_IN = "Zoom in", e.ZOOM_OUT = "Zoom out", e.RESET_ZOOM = "Reset zoom", e.MAKE_FULLSCREEN = "Make fullscreen", e.SHOW_AS_DATATABLE = "Show as data-table", e.CUSTOM = "Custom", e))(Ut || {}), Zo = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(Zo || {}), Wt = /* @__PURE__ */ ((e) => (e.CHECKBOX = "checkbox", e.RADIUS = "radius", e.AREA = "area", e.SIZE = "size", e.LINE = "line", e.QUARTILE = "quartile", e.ZOOM = "zoom", e))(Wt || {}), Es = /* @__PURE__ */ ((e) => (e.LINEAR = "linear", e.QUANTIZE = "quantize", e))(Es || {}), Ei = /* @__PURE__ */ ((e) => (e.ON = "on", e.AUTO = "auto", e.OFF = "off", e))(Ei || {}), Aa = /* @__PURE__ */ ((e) => (e.DEFAULT = "default", e.HOVERABLE = "hoverable", e))(Aa || {}), on = /* @__PURE__ */ ((e) => (e.geoEqualEarth = "geoEqualEarth", e.geoAlbers = "geoAlbers", e.geoConicEqualArea = "geoConicEqualArea", e.geoConicEquidistant = "geoConicEquidistant", e.geoEquirectangular = "geoEquirectangular", e.geoMercator = "geoMercator", e.geoNaturalEarth1 = "geoNaturalEarth1", e))(on || {});
function zn(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function l0(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function cc(e) {
  let t, n, r;
  e.length !== 2 ? (t = zn, n = (o, l) => zn(e(o), l), r = (o, l) => e(o) - l) : (t = e === zn || e === l0 ? e : c0, n = e, r = e);
  function i(o, l, c = 0, u = o.length) {
    if (c < u) {
      if (t(l, l) !== 0)
        return u;
      do {
        const h = c + u >>> 1;
        n(o[h], l) < 0 ? c = h + 1 : u = h;
      } while (c < u);
    }
    return c;
  }
  function s(o, l, c = 0, u = o.length) {
    if (c < u) {
      if (t(l, l) !== 0)
        return u;
      do {
        const h = c + u >>> 1;
        n(o[h], l) <= 0 ? c = h + 1 : u = h;
      } while (c < u);
    }
    return c;
  }
  function a(o, l, c = 0, u = o.length) {
    const h = i(o, l, c, u - 1);
    return h > c && r(o[h - 1], l) > -r(o[h], l) ? h - 1 : h;
  }
  return { left: i, center: a, right: s };
}
function c0() {
  return 0;
}
function u0(e) {
  return e === null ? NaN : +e;
}
function* h0(e, t) {
  if (t === void 0)
    for (let n of e)
      n != null && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let r of e)
      (r = t(r, ++n, e)) != null && (r = +r) >= r && (yield r);
  }
}
const d0 = cc(zn), f0 = d0.right;
cc(u0).center;
const uc = f0;
function p0(e, t) {
  let n = 0;
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && ++n;
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (i = +i) >= i && ++n;
  }
  return n;
}
function Ne(e, t) {
  let n, r;
  if (t === void 0)
    for (const i of e)
      i != null && (n === void 0 ? i >= i && (n = r = i) : (n > i && (n = i), r < i && (r = i)));
  else {
    let i = -1;
    for (let s of e)
      (s = t(s, ++i, e)) != null && (n === void 0 ? s >= s && (n = r = s) : (n > s && (n = s), r < s && (r = s)));
  }
  return [n, r];
}
class Wn {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(t) {
    const n = this._partials;
    let r = 0;
    for (let i = 0; i < this._n && i < 32; i++) {
      const s = n[i], a = t + s, o = Math.abs(t) < Math.abs(s) ? t - (a - s) : s - (a - t);
      o && (n[r++] = o), t = a;
    }
    return n[r] = t, this._n = r + 1, this;
  }
  valueOf() {
    const t = this._partials;
    let n = this._n, r, i, s, a = 0;
    if (n > 0) {
      for (a = t[--n]; n > 0 && (r = a, i = t[--n], a = r + i, s = i - (a - r), !s); )
        ;
      n > 0 && (s < 0 && t[n - 1] < 0 || s > 0 && t[n - 1] > 0) && (i = s * 2, r = a + i, i == r - a && (a = r));
    }
    return a;
  }
}
class _u extends Map {
  constructor(t, n = v0) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null)
      for (const [r, i] of t)
        this.set(r, i);
  }
  get(t) {
    return super.get(Eu(this, t));
  }
  has(t) {
    return super.has(Eu(this, t));
  }
  set(t, n) {
    return super.set(g0(this, t), n);
  }
  delete(t) {
    return super.delete(m0(this, t));
  }
}
function Eu({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : n;
}
function g0({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) ? e.get(r) : (e.set(r, n), n);
}
function m0({ _intern: e, _key: t }, n) {
  const r = t(n);
  return e.has(r) && (n = e.get(r), e.delete(r)), n;
}
function v0(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function y0(e) {
  return e;
}
function x0(e = zn) {
  if (e === zn)
    return Qf;
  if (typeof e != "function")
    throw new TypeError("compare is not a function");
  return (t, n) => {
    const r = e(t, n);
    return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0);
  };
}
function Qf(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
var b0 = Array.prototype, w0 = b0.slice;
function fo(e) {
  return () => e;
}
const _0 = Math.sqrt(50), E0 = Math.sqrt(10), S0 = Math.sqrt(2);
function Bs(e, t, n) {
  const r = (t - e) / Math.max(0, n), i = Math.floor(Math.log10(r)), s = r / Math.pow(10, i), a = s >= _0 ? 10 : s >= E0 ? 5 : s >= S0 ? 2 : 1;
  let o, l, c;
  return i < 0 ? (c = Math.pow(10, -i) / a, o = Math.round(e * c), l = Math.round(t * c), o / c < e && ++o, l / c > t && --l, c = -c) : (c = Math.pow(10, i) * a, o = Math.round(e / c), l = Math.round(t / c), o * c < e && ++o, l * c > t && --l), l < o && 0.5 <= n && n < 2 ? Bs(e, t, n * 2) : [o, l, c];
}
function Vs(e, t, n) {
  if (t = +t, e = +e, n = +n, !(n > 0))
    return [];
  if (e === t)
    return [e];
  const r = t < e, [i, s, a] = r ? Bs(t, e, n) : Bs(e, t, n);
  if (!(s >= i))
    return [];
  const o = s - i + 1, l = new Array(o);
  if (r)
    if (a < 0)
      for (let c = 0; c < o; ++c)
        l[c] = (s - c) / -a;
    else
      for (let c = 0; c < o; ++c)
        l[c] = (s - c) * a;
  else if (a < 0)
    for (let c = 0; c < o; ++c)
      l[c] = (i + c) / -a;
  else
    for (let c = 0; c < o; ++c)
      l[c] = (i + c) * a;
  return l;
}
function Dr(e, t, n) {
  return t = +t, e = +e, n = +n, Bs(e, t, n)[2];
}
function Ko(e, t, n) {
  t = +t, e = +e, n = +n;
  const r = t < e, i = r ? Dr(t, e, n) : Dr(e, t, n);
  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function O0(e, t, n) {
  let r;
  for (; ; ) {
    const i = Dr(e, t, n);
    if (i === r || i === 0 || !isFinite(i))
      return [e, t];
    i > 0 ? (e = Math.floor(e / i) * i, t = Math.ceil(t / i) * i) : i < 0 && (e = Math.ceil(e * i) / i, t = Math.floor(t * i) / i), r = i;
  }
}
function T0(e) {
  return Math.max(1, Math.ceil(Math.log(p0(e)) / Math.LN2) + 1);
}
function M0() {
  var e = y0, t = Ne, n = T0;
  function r(i) {
    Array.isArray(i) || (i = Array.from(i));
    var s, a = i.length, o, l, c = new Array(a);
    for (s = 0; s < a; ++s)
      c[s] = e(i[s], s, i);
    var u = t(c), h = u[0], d = u[1], f = n(c, h, d);
    if (!Array.isArray(f)) {
      const x = d, S = +f;
      if (t === Ne && ([h, d] = O0(h, d, S)), f = Vs(h, d, S), f[0] <= h && (l = Dr(h, d, S)), f[f.length - 1] >= d)
        if (x >= d && t === Ne) {
          const _ = Dr(h, d, S);
          isFinite(_) && (_ > 0 ? d = (Math.floor(d / _) + 1) * _ : _ < 0 && (d = (Math.ceil(d * -_) + 1) / -_));
        } else
          f.pop();
    }
    for (var p = f.length, m = 0, g = p; f[m] <= h; )
      ++m;
    for (; f[g - 1] > d; )
      --g;
    (m || g < p) && (f = f.slice(m, g), p = g - m);
    var v = new Array(p + 1), y;
    for (s = 0; s <= p; ++s)
      y = v[s] = [], y.x0 = s > 0 ? f[s - 1] : h, y.x1 = s < p ? f[s] : d;
    if (isFinite(l)) {
      if (l > 0)
        for (s = 0; s < a; ++s)
          (o = c[s]) != null && h <= o && o <= d && v[Math.min(p, Math.floor((o - h) / l))].push(i[s]);
      else if (l < 0) {
        for (s = 0; s < a; ++s)
          if ((o = c[s]) != null && h <= o && o <= d) {
            const x = Math.floor((h - o) * l);
            v[Math.min(p, x + (f[x] <= o))].push(i[s]);
          }
      }
    } else
      for (s = 0; s < a; ++s)
        (o = c[s]) != null && h <= o && o <= d && v[uc(f, o, 0, p)].push(i[s]);
    return v;
  }
  return r.value = function(i) {
    return arguments.length ? (e = typeof i == "function" ? i : fo(i), r) : e;
  }, r.domain = function(i) {
    return arguments.length ? (t = typeof i == "function" ? i : fo([i[0], i[1]]), r) : t;
  }, r.thresholds = function(i) {
    return arguments.length ? (n = typeof i == "function" ? i : fo(Array.isArray(i) ? w0.call(i) : i), r) : n;
  }, r;
}
function qn(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function Ln(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function Jf(e, t, n = 0, r = 1 / 0, i) {
  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), r = Math.floor(Math.min(e.length - 1, r)), !(n <= t && t <= r))
    return e;
  for (i = i === void 0 ? Qf : x0(i); r > n; ) {
    if (r - n > 600) {
      const l = r - n + 1, c = t - n + 1, u = Math.log(l), h = 0.5 * Math.exp(2 * u / 3), d = 0.5 * Math.sqrt(u * h * (l - h) / l) * (c - l / 2 < 0 ? -1 : 1), f = Math.max(n, Math.floor(t - c * h / l + d)), p = Math.min(r, Math.floor(t + (l - c) * h / l + d));
      Jf(e, t, f, p, i);
    }
    const s = e[t];
    let a = n, o = r;
    for (Kr(e, n, t), i(e[r], s) > 0 && Kr(e, n, r); a < o; ) {
      for (Kr(e, a, o), ++a, --o; i(e[a], s) < 0; )
        ++a;
      for (; i(e[o], s) > 0; )
        --o;
    }
    i(e[n], s) === 0 ? Kr(e, n, o) : (++o, Kr(e, o, r)), o <= t && (n = o + 1), t <= o && (r = o - 1);
  }
  return e;
}
function Kr(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function po(e, t, n) {
  if (e = Float64Array.from(h0(e, n)), !(!(r = e.length) || isNaN(t = +t))) {
    if (t <= 0 || r < 2)
      return Ln(e);
    if (t >= 1)
      return qn(e);
    var r, i = (r - 1) * t, s = Math.floor(i), a = qn(Jf(e, s).subarray(0, s + 1)), o = Ln(e.subarray(s + 1));
    return a + (o - a) * (i - s);
  }
}
function* C0(e) {
  for (const t of e)
    yield* t;
}
function tp(e) {
  return Array.from(C0(e));
}
function $0(e, t, n) {
  e = +e, t = +t, n = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +n;
  for (var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, s = new Array(i); ++r < i; )
    s[r] = e + r * n;
  return s;
}
function A0(e) {
  return e;
}
var Ss = 1, Os = 2, Qo = 3, li = 4, Su = 1e-6;
function L0(e) {
  return "translate(" + e + ",0)";
}
function D0(e) {
  return "translate(0," + e + ")";
}
function k0(e) {
  return (t) => +e(t);
}
function R0(e, t) {
  return t = Math.max(0, e.bandwidth() - t * 2) / 2, e.round() && (t = Math.round(t)), (n) => +e(n) + t;
}
function I0() {
  return !this.__axis;
}
function La(e, t) {
  var n = [], r = null, i = null, s = 6, a = 6, o = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, c = e === Ss || e === li ? -1 : 1, u = e === li || e === Os ? "x" : "y", h = e === Ss || e === Qo ? L0 : D0;
  function d(f) {
    var p = r ?? (t.ticks ? t.ticks.apply(t, n) : t.domain()), m = i ?? (t.tickFormat ? t.tickFormat.apply(t, n) : A0), g = Math.max(s, 0) + o, v = t.range(), y = +v[0] + l, x = +v[v.length - 1] + l, S = (t.bandwidth ? R0 : k0)(t.copy(), l), _ = f.selection ? f.selection() : f, E = _.selectAll(".domain").data([null]), T = _.selectAll(".tick").data(p, t).order(), k = T.exit(), N = T.enter().append("g").attr("class", "tick"), L = T.select("line"), C = T.select("text");
    E = E.merge(E.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), T = T.merge(N), L = L.merge(N.append("line").attr("stroke", "currentColor").attr(u + "2", c * s)), C = C.merge(N.append("text").attr("fill", "currentColor").attr(u, c * g).attr("dy", e === Ss ? "0em" : e === Qo ? "0.71em" : "0.32em")), f !== _ && (E = E.transition(f), T = T.transition(f), L = L.transition(f), C = C.transition(f), k = k.transition(f).attr("opacity", Su).attr("transform", function(V) {
      return isFinite(V = S(V)) ? h(V + l) : this.getAttribute("transform");
    }), N.attr("opacity", Su).attr("transform", function(V) {
      var M = this.parentNode.__axis;
      return h((M && isFinite(M = M(V)) ? M : S(V)) + l);
    })), k.remove(), E.attr("d", e === li || e === Os ? a ? "M" + c * a + "," + y + "H" + l + "V" + x + "H" + c * a : "M" + l + "," + y + "V" + x : a ? "M" + y + "," + c * a + "V" + l + "H" + x + "V" + c * a : "M" + y + "," + l + "H" + x), T.attr("opacity", 1).attr("transform", function(V) {
      return h(S(V) + l);
    }), L.attr(u + "2", c * s), C.attr(u, c * g).text(m), _.filter(I0).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === Os ? "start" : e === li ? "end" : "middle"), _.each(function() {
      this.__axis = S;
    });
  }
  return d.scale = function(f) {
    return arguments.length ? (t = f, d) : t;
  }, d.ticks = function() {
    return n = Array.from(arguments), d;
  }, d.tickArguments = function(f) {
    return arguments.length ? (n = f == null ? [] : Array.from(f), d) : n.slice();
  }, d.tickValues = function(f) {
    return arguments.length ? (r = f == null ? null : Array.from(f), d) : r && r.slice();
  }, d.tickFormat = function(f) {
    return arguments.length ? (i = f, d) : i;
  }, d.tickSize = function(f) {
    return arguments.length ? (s = a = +f, d) : s;
  }, d.tickSizeInner = function(f) {
    return arguments.length ? (s = +f, d) : s;
  }, d.tickSizeOuter = function(f) {
    return arguments.length ? (a = +f, d) : a;
  }, d.tickPadding = function(f) {
    return arguments.length ? (o = +f, d) : o;
  }, d.offset = function(f) {
    return arguments.length ? (l = +f, d) : l;
  }, d;
}
function N0(e) {
  return La(Ss, e);
}
function P0(e) {
  return La(Os, e);
}
function hc(e) {
  return La(Qo, e);
}
function ep(e) {
  return La(li, e);
}
var U0 = { value: () => {
} };
function dc() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r))
      throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new Ts(n);
}
function Ts(e) {
  this._ = e;
}
function B0(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
Ts.prototype = dc.prototype = {
  constructor: Ts,
  on: function(e, t) {
    var n = this._, r = B0(e + "", n), i, s = -1, a = r.length;
    if (arguments.length < 2) {
      for (; ++s < a; )
        if ((i = (e = r[s]).type) && (i = V0(n[i], e.name)))
          return i;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++s < a; )
      if (i = (e = r[s]).type)
        n[i] = Ou(n[i], e.name, t);
      else if (t == null)
        for (i in n)
          n[i] = Ou(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new Ts(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), r = 0, i, s; r < i; ++r)
        n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (s = this._[e], r = 0, i = s.length; r < i; ++r)
      s[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var r = this._[e], i = 0, s = r.length; i < s; ++i)
      r[i].value.apply(t, n);
  }
};
function V0(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function Ou(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      e[r] = U0, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Jo = "http://www.w3.org/1999/xhtml";
const Tu = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Jo,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Da(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), Tu.hasOwnProperty(t) ? { space: Tu[t], local: e } : e;
}
function H0(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Jo && t.documentElement.namespaceURI === Jo ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function F0(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function np(e) {
  var t = Da(e);
  return (t.local ? F0 : H0)(t);
}
function G0() {
}
function fc(e) {
  return e == null ? G0 : function() {
    return this.querySelector(e);
  };
}
function z0(e) {
  typeof e != "function" && (e = fc(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], a = s.length, o = r[i] = new Array(a), l, c, u = 0; u < a; ++u)
      (l = s[u]) && (c = e.call(l, l.__data__, u, s)) && ("__data__" in l && (c.__data__ = l.__data__), o[u] = c);
  return new we(r, this._parents);
}
function j0(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function W0() {
  return [];
}
function rp(e) {
  return e == null ? W0 : function() {
    return this.querySelectorAll(e);
  };
}
function q0(e) {
  return function() {
    return j0(e.apply(this, arguments));
  };
}
function Y0(e) {
  typeof e == "function" ? e = q0(e) : e = rp(e);
  for (var t = this._groups, n = t.length, r = [], i = [], s = 0; s < n; ++s)
    for (var a = t[s], o = a.length, l, c = 0; c < o; ++c)
      (l = a[c]) && (r.push(e.call(l, l.__data__, c, a)), i.push(l));
  return new we(r, i);
}
function ip(e) {
  return function() {
    return this.matches(e);
  };
}
function sp(e) {
  return function(t) {
    return t.matches(e);
  };
}
var X0 = Array.prototype.find;
function Z0(e) {
  return function() {
    return X0.call(this.children, e);
  };
}
function K0() {
  return this.firstElementChild;
}
function Q0(e) {
  return this.select(e == null ? K0 : Z0(typeof e == "function" ? e : sp(e)));
}
var J0 = Array.prototype.filter;
function ty() {
  return Array.from(this.children);
}
function ey(e) {
  return function() {
    return J0.call(this.children, e);
  };
}
function ny(e) {
  return this.selectAll(e == null ? ty : ey(typeof e == "function" ? e : sp(e)));
}
function ry(e) {
  typeof e != "function" && (e = ip(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], a = s.length, o = r[i] = [], l, c = 0; c < a; ++c)
      (l = s[c]) && e.call(l, l.__data__, c, s) && o.push(l);
  return new we(r, this._parents);
}
function ap(e) {
  return new Array(e.length);
}
function iy() {
  return new we(this._enter || this._groups.map(ap), this._parents);
}
function Hs(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Hs.prototype = {
  constructor: Hs,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function sy(e) {
  return function() {
    return e;
  };
}
function ay(e, t, n, r, i, s) {
  for (var a = 0, o, l = t.length, c = s.length; a < c; ++a)
    (o = t[a]) ? (o.__data__ = s[a], r[a] = o) : n[a] = new Hs(e, s[a]);
  for (; a < l; ++a)
    (o = t[a]) && (i[a] = o);
}
function oy(e, t, n, r, i, s, a) {
  var o, l, c = /* @__PURE__ */ new Map(), u = t.length, h = s.length, d = new Array(u), f;
  for (o = 0; o < u; ++o)
    (l = t[o]) && (d[o] = f = a.call(l, l.__data__, o, t) + "", c.has(f) ? i[o] = l : c.set(f, l));
  for (o = 0; o < h; ++o)
    f = a.call(e, s[o], o, s) + "", (l = c.get(f)) ? (r[o] = l, l.__data__ = s[o], c.delete(f)) : n[o] = new Hs(e, s[o]);
  for (o = 0; o < u; ++o)
    (l = t[o]) && c.get(d[o]) === l && (i[o] = l);
}
function ly(e) {
  return e.__data__;
}
function cy(e, t) {
  if (!arguments.length)
    return Array.from(this, ly);
  var n = t ? oy : ay, r = this._parents, i = this._groups;
  typeof e != "function" && (e = sy(e));
  for (var s = i.length, a = new Array(s), o = new Array(s), l = new Array(s), c = 0; c < s; ++c) {
    var u = r[c], h = i[c], d = h.length, f = uy(e.call(u, u && u.__data__, c, r)), p = f.length, m = o[c] = new Array(p), g = a[c] = new Array(p), v = l[c] = new Array(d);
    n(u, h, m, g, v, f, t);
    for (var y = 0, x = 0, S, _; y < p; ++y)
      if (S = m[y]) {
        for (y >= x && (x = y + 1); !(_ = g[x]) && ++x < p; )
          ;
        S._next = _ || null;
      }
  }
  return a = new we(a, r), a._enter = o, a._exit = l, a;
}
function uy(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function hy() {
  return new we(this._exit || this._groups.map(ap), this._parents);
}
function dy(e, t, n) {
  var r = this.enter(), i = this, s = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? s.remove() : n(s), r && i ? r.merge(i).order() : i;
}
function fy(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, i = n.length, s = r.length, a = Math.min(i, s), o = new Array(i), l = 0; l < a; ++l)
    for (var c = n[l], u = r[l], h = c.length, d = o[l] = new Array(h), f, p = 0; p < h; ++p)
      (f = c[p] || u[p]) && (d[p] = f);
  for (; l < i; ++l)
    o[l] = n[l];
  return new we(o, this._parents);
}
function py() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], i = r.length - 1, s = r[i], a; --i >= 0; )
      (a = r[i]) && (s && a.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(a, s), s = a);
  return this;
}
function gy(e) {
  e || (e = my);
  function t(h, d) {
    return h && d ? e(h.__data__, d.__data__) : !h - !d;
  }
  for (var n = this._groups, r = n.length, i = new Array(r), s = 0; s < r; ++s) {
    for (var a = n[s], o = a.length, l = i[s] = new Array(o), c, u = 0; u < o; ++u)
      (c = a[u]) && (l[u] = c);
    l.sort(t);
  }
  return new we(i, this._parents).order();
}
function my(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function vy() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function yy() {
  return Array.from(this);
}
function xy() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, s = r.length; i < s; ++i) {
      var a = r[i];
      if (a)
        return a;
    }
  return null;
}
function by() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function wy() {
  return !this.node();
}
function _y(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var i = t[n], s = 0, a = i.length, o; s < a; ++s)
      (o = i[s]) && e.call(o, o.__data__, s, i);
  return this;
}
function Ey(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Sy(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Oy(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function Ty(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function My(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function Cy(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function $y(e, t) {
  var n = Da(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? Sy : Ey : typeof t == "function" ? n.local ? Cy : My : n.local ? Ty : Oy)(n, t));
}
function op(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function Ay(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Ly(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function Dy(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function ky(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? Ay : typeof t == "function" ? Dy : Ly)(e, t, n ?? "")) : kr(this.node(), e);
}
function kr(e, t) {
  return e.style.getPropertyValue(t) || op(e).getComputedStyle(e, null).getPropertyValue(t);
}
function Ry(e) {
  return function() {
    delete this[e];
  };
}
function Iy(e, t) {
  return function() {
    this[e] = t;
  };
}
function Ny(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function Py(e, t) {
  return arguments.length > 1 ? this.each((t == null ? Ry : typeof t == "function" ? Ny : Iy)(e, t)) : this.node()[e];
}
function lp(e) {
  return e.trim().split(/^|\s+/);
}
function pc(e) {
  return e.classList || new cp(e);
}
function cp(e) {
  this._node = e, this._names = lp(e.getAttribute("class") || "");
}
cp.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function up(e, t) {
  for (var n = pc(e), r = -1, i = t.length; ++r < i; )
    n.add(t[r]);
}
function hp(e, t) {
  for (var n = pc(e), r = -1, i = t.length; ++r < i; )
    n.remove(t[r]);
}
function Uy(e) {
  return function() {
    up(this, e);
  };
}
function By(e) {
  return function() {
    hp(this, e);
  };
}
function Vy(e, t) {
  return function() {
    (t.apply(this, arguments) ? up : hp)(this, e);
  };
}
function Hy(e, t) {
  var n = lp(e + "");
  if (arguments.length < 2) {
    for (var r = pc(this.node()), i = -1, s = n.length; ++i < s; )
      if (!r.contains(n[i]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? Vy : t ? Uy : By)(n, t));
}
function Fy() {
  this.textContent = "";
}
function Gy(e) {
  return function() {
    this.textContent = e;
  };
}
function zy(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function jy(e) {
  return arguments.length ? this.each(e == null ? Fy : (typeof e == "function" ? zy : Gy)(e)) : this.node().textContent;
}
function Wy() {
  this.innerHTML = "";
}
function qy(e) {
  return function() {
    this.innerHTML = e;
  };
}
function Yy(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function Xy(e) {
  return arguments.length ? this.each(e == null ? Wy : (typeof e == "function" ? Yy : qy)(e)) : this.node().innerHTML;
}
function Zy() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Ky() {
  return this.each(Zy);
}
function Qy() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function Jy() {
  return this.each(Qy);
}
function t1(e) {
  var t = typeof e == "function" ? e : np(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function e1() {
  return null;
}
function n1(e, t) {
  var n = typeof e == "function" ? e : np(e), r = t == null ? e1 : typeof t == "function" ? t : fc(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function r1() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function i1() {
  return this.each(r1);
}
function s1() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function a1() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function o1(e) {
  return this.select(e ? a1 : s1);
}
function l1(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function c1(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function u1(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function h1(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, i = t.length, s; n < i; ++n)
        s = t[n], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++r] = s;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function d1(e, t, n) {
  return function() {
    var r = this.__on, i, s = c1(t);
    if (r) {
      for (var a = 0, o = r.length; a < o; ++a)
        if ((i = r[a]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, s, n), i = { type: e.type, name: e.name, value: t, listener: s, options: n }, r ? r.push(i) : this.__on = [i];
  };
}
function f1(e, t, n) {
  var r = u1(e + ""), i, s = r.length, a;
  if (arguments.length < 2) {
    var o = this.node().__on;
    if (o) {
      for (var l = 0, c = o.length, u; l < c; ++l)
        for (i = 0, u = o[l]; i < s; ++i)
          if ((a = r[i]).type === u.type && a.name === u.name)
            return u.value;
    }
    return;
  }
  for (o = t ? d1 : h1, i = 0; i < s; ++i)
    this.each(o(r[i], t, n));
  return this;
}
function dp(e, t, n) {
  var r = op(e), i = r.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function p1(e, t) {
  return function() {
    return dp(this, e, t);
  };
}
function g1(e, t) {
  return function() {
    return dp(this, e, t.apply(this, arguments));
  };
}
function m1(e, t) {
  return this.each((typeof t == "function" ? g1 : p1)(e, t));
}
function* v1() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, s = r.length, a; i < s; ++i)
      (a = r[i]) && (yield a);
}
var fp = [null];
function we(e, t) {
  this._groups = e, this._parents = t;
}
function ji() {
  return new we([[document.documentElement]], fp);
}
function y1() {
  return this;
}
we.prototype = ji.prototype = {
  constructor: we,
  select: z0,
  selectAll: Y0,
  selectChild: Q0,
  selectChildren: ny,
  filter: ry,
  data: cy,
  enter: iy,
  exit: hy,
  join: dy,
  merge: fy,
  selection: y1,
  order: py,
  sort: gy,
  call: vy,
  nodes: yy,
  node: xy,
  size: by,
  empty: wy,
  each: _y,
  attr: $y,
  style: ky,
  property: Py,
  classed: Hy,
  text: jy,
  html: Xy,
  raise: Ky,
  lower: Jy,
  append: t1,
  insert: n1,
  remove: i1,
  clone: o1,
  datum: l1,
  on: f1,
  dispatch: m1,
  [Symbol.iterator]: v1
};
function R(e) {
  return typeof e == "string" ? new we([[document.querySelector(e)]], [document.documentElement]) : new we([[e]], fp);
}
function x1(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function Yn(e, t) {
  if (e = x1(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const tl = { capture: !0, passive: !1 };
function el(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function b1(e) {
  var t = e.document.documentElement, n = R(e).on("dragstart.drag", el, tl);
  "onselectstart" in t ? n.on("selectstart.drag", el, tl) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function w1(e, t) {
  var n = e.document.documentElement, r = R(e).on("dragstart.drag", null);
  t && (r.on("click.drag", el, tl), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
function gc(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function pp(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t)
    n[r] = t[r];
  return n;
}
function Wi() {
}
var Di = 0.7, Fs = 1 / Di, $r = "\\s*([+-]?\\d+)\\s*", ki = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Xe = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", _1 = /^#([0-9a-f]{3,8})$/, E1 = new RegExp(`^rgb\\(${$r},${$r},${$r}\\)$`), S1 = new RegExp(`^rgb\\(${Xe},${Xe},${Xe}\\)$`), O1 = new RegExp(`^rgba\\(${$r},${$r},${$r},${ki}\\)$`), T1 = new RegExp(`^rgba\\(${Xe},${Xe},${Xe},${ki}\\)$`), M1 = new RegExp(`^hsl\\(${ki},${Xe},${Xe}\\)$`), C1 = new RegExp(`^hsla\\(${ki},${Xe},${Xe},${ki}\\)$`), Mu = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
gc(Wi, pn, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Cu,
  // Deprecated! Use color.formatHex.
  formatHex: Cu,
  formatHex8: $1,
  formatHsl: A1,
  formatRgb: $u,
  toString: $u
});
function Cu() {
  return this.rgb().formatHex();
}
function $1() {
  return this.rgb().formatHex8();
}
function A1() {
  return gp(this).formatHsl();
}
function $u() {
  return this.rgb().formatRgb();
}
function pn(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = _1.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? Au(t) : n === 3 ? new de(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? ss(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? ss(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = E1.exec(e)) ? new de(t[1], t[2], t[3], 1) : (t = S1.exec(e)) ? new de(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = O1.exec(e)) ? ss(t[1], t[2], t[3], t[4]) : (t = T1.exec(e)) ? ss(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = M1.exec(e)) ? ku(t[1], t[2] / 100, t[3] / 100, 1) : (t = C1.exec(e)) ? ku(t[1], t[2] / 100, t[3] / 100, t[4]) : Mu.hasOwnProperty(e) ? Au(Mu[e]) : e === "transparent" ? new de(NaN, NaN, NaN, 0) : null;
}
function Au(e) {
  return new de(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function ss(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new de(e, t, n, r);
}
function L1(e) {
  return e instanceof Wi || (e = pn(e)), e ? (e = e.rgb(), new de(e.r, e.g, e.b, e.opacity)) : new de();
}
function nl(e, t, n, r) {
  return arguments.length === 1 ? L1(e) : new de(e, t, n, r ?? 1);
}
function de(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
gc(de, nl, pp(Wi, {
  brighter(e) {
    return e = e == null ? Fs : Math.pow(Fs, e), new de(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Di : Math.pow(Di, e), new de(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new de(jn(this.r), jn(this.g), jn(this.b), Gs(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Lu,
  // Deprecated! Use color.formatHex.
  formatHex: Lu,
  formatHex8: D1,
  formatRgb: Du,
  toString: Du
}));
function Lu() {
  return `#${Gn(this.r)}${Gn(this.g)}${Gn(this.b)}`;
}
function D1() {
  return `#${Gn(this.r)}${Gn(this.g)}${Gn(this.b)}${Gn((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Du() {
  const e = Gs(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${jn(this.r)}, ${jn(this.g)}, ${jn(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Gs(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function jn(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Gn(e) {
  return e = jn(e), (e < 16 ? "0" : "") + e.toString(16);
}
function ku(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new De(e, t, n, r);
}
function gp(e) {
  if (e instanceof De)
    return new De(e.h, e.s, e.l, e.opacity);
  if (e instanceof Wi || (e = pn(e)), !e)
    return new De();
  if (e instanceof De)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), s = Math.max(t, n, r), a = NaN, o = s - i, l = (s + i) / 2;
  return o ? (t === s ? a = (n - r) / o + (n < r) * 6 : n === s ? a = (r - t) / o + 2 : a = (t - n) / o + 4, o /= l < 0.5 ? s + i : 2 - s - i, a *= 60) : o = l > 0 && l < 1 ? 0 : a, new De(a, o, l, e.opacity);
}
function mc(e, t, n, r) {
  return arguments.length === 1 ? gp(e) : new De(e, t, n, r ?? 1);
}
function De(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
gc(De, mc, pp(Wi, {
  brighter(e) {
    return e = e == null ? Fs : Math.pow(Fs, e), new De(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Di : Math.pow(Di, e), new De(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new de(
      go(e >= 240 ? e - 240 : e + 120, i, r),
      go(e, i, r),
      go(e < 120 ? e + 240 : e - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new De(Ru(this.h), as(this.s), as(this.l), Gs(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Gs(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${Ru(this.h)}, ${as(this.s) * 100}%, ${as(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function Ru(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function as(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function go(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const vc = (e) => () => e;
function k1(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function R1(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function I1(e) {
  return (e = +e) == 1 ? mp : function(t, n) {
    return n - t ? R1(t, n, e) : vc(isNaN(t) ? n : t);
  };
}
function mp(e, t) {
  var n = t - e;
  return n ? k1(e, n) : vc(isNaN(e) ? t : e);
}
const zs = function e(t) {
  var n = I1(t);
  function r(i, s) {
    var a = n((i = nl(i)).r, (s = nl(s)).r), o = n(i.g, s.g), l = n(i.b, s.b), c = mp(i.opacity, s.opacity);
    return function(u) {
      return i.r = a(u), i.g = o(u), i.b = l(u), i.opacity = c(u), i + "";
    };
  }
  return r.gamma = e, r;
}(1);
function N1(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), i;
  return function(s) {
    for (i = 0; i < n; ++i)
      r[i] = e[i] * (1 - s) + t[i] * s;
    return r;
  };
}
function P1(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function U1(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, i = new Array(r), s = new Array(n), a;
  for (a = 0; a < r; ++a)
    i[a] = qi(e[a], t[a]);
  for (; a < n; ++a)
    s[a] = t[a];
  return function(o) {
    for (a = 0; a < r; ++a)
      s[a] = i[a](o);
    return s;
  };
}
function B1(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function xe(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function V1(e, t) {
  var n = {}, r = {}, i;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (i in t)
    i in e ? n[i] = qi(e[i], t[i]) : r[i] = t[i];
  return function(s) {
    for (i in n)
      r[i] = n[i](s);
    return r;
  };
}
var rl = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, mo = new RegExp(rl.source, "g");
function H1(e) {
  return function() {
    return e;
  };
}
function F1(e) {
  return function(t) {
    return e(t) + "";
  };
}
function vp(e, t) {
  var n = rl.lastIndex = mo.lastIndex = 0, r, i, s, a = -1, o = [], l = [];
  for (e = e + "", t = t + ""; (r = rl.exec(e)) && (i = mo.exec(t)); )
    (s = i.index) > n && (s = t.slice(n, s), o[a] ? o[a] += s : o[++a] = s), (r = r[0]) === (i = i[0]) ? o[a] ? o[a] += i : o[++a] = i : (o[++a] = null, l.push({ i: a, x: xe(r, i) })), n = mo.lastIndex;
  return n < t.length && (s = t.slice(n), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? l[0] ? F1(l[0].x) : H1(t) : (t = l.length, function(c) {
    for (var u = 0, h; u < t; ++u)
      o[(h = l[u]).i] = h.x(c);
    return o.join("");
  });
}
function qi(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? vc(t) : (n === "number" ? xe : n === "string" ? (r = pn(t)) ? (t = r, zs) : vp : t instanceof pn ? zs : t instanceof Date ? B1 : P1(t) ? N1 : Array.isArray(t) ? U1 : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? V1 : xe)(e, t);
}
function yp(e, t) {
  return e = +e, t = +t, function(n) {
    return Math.round(e * (1 - n) + t * n);
  };
}
var Iu = 180 / Math.PI, il = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function xp(e, t, n, r, i, s) {
  var a, o, l;
  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (l = e * n + t * r) && (n -= e * l, r -= t * l), (o = Math.sqrt(n * n + r * r)) && (n /= o, r /= o, l /= o), e * r < t * n && (e = -e, t = -t, l = -l, a = -a), {
    translateX: i,
    translateY: s,
    rotate: Math.atan2(t, e) * Iu,
    skewX: Math.atan(l) * Iu,
    scaleX: a,
    scaleY: o
  };
}
var os;
function G1(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? il : xp(t.a, t.b, t.c, t.d, t.e, t.f);
}
function z1(e) {
  return e == null || (os || (os = document.createElementNS("http://www.w3.org/2000/svg", "g")), os.setAttribute("transform", e), !(e = os.transform.baseVal.consolidate())) ? il : (e = e.matrix, xp(e.a, e.b, e.c, e.d, e.e, e.f));
}
function bp(e, t, n, r) {
  function i(c) {
    return c.length ? c.pop() + " " : "";
  }
  function s(c, u, h, d, f, p) {
    if (c !== h || u !== d) {
      var m = f.push("translate(", null, t, null, n);
      p.push({ i: m - 4, x: xe(c, h) }, { i: m - 2, x: xe(u, d) });
    } else
      (h || d) && f.push("translate(" + h + t + d + n);
  }
  function a(c, u, h, d) {
    c !== u ? (c - u > 180 ? u += 360 : u - c > 180 && (c += 360), d.push({ i: h.push(i(h) + "rotate(", null, r) - 2, x: xe(c, u) })) : u && h.push(i(h) + "rotate(" + u + r);
  }
  function o(c, u, h, d) {
    c !== u ? d.push({ i: h.push(i(h) + "skewX(", null, r) - 2, x: xe(c, u) }) : u && h.push(i(h) + "skewX(" + u + r);
  }
  function l(c, u, h, d, f, p) {
    if (c !== h || u !== d) {
      var m = f.push(i(f) + "scale(", null, ",", null, ")");
      p.push({ i: m - 4, x: xe(c, h) }, { i: m - 2, x: xe(u, d) });
    } else
      (h !== 1 || d !== 1) && f.push(i(f) + "scale(" + h + "," + d + ")");
  }
  return function(c, u) {
    var h = [], d = [];
    return c = e(c), u = e(u), s(c.translateX, c.translateY, u.translateX, u.translateY, h, d), a(c.rotate, u.rotate, h, d), o(c.skewX, u.skewX, h, d), l(c.scaleX, c.scaleY, u.scaleX, u.scaleY, h, d), c = u = null, function(f) {
      for (var p = -1, m = d.length, g; ++p < m; )
        h[(g = d[p]).i] = g.x(f);
      return h.join("");
    };
  };
}
var j1 = bp(G1, "px, ", "px)", "deg)"), W1 = bp(z1, ", ", ")", ")");
function q1(e, t) {
  for (var n = new Array(t), r = 0; r < t; ++r)
    n[r] = e(r / (t - 1));
  return n;
}
var Rr = 0, ci = 0, Qr = 0, wp = 1e3, js, ui, Ws = 0, Xn = 0, ka = 0, Ri = typeof performance == "object" && performance.now ? performance : Date, _p = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function yc() {
  return Xn || (_p(Y1), Xn = Ri.now() + ka);
}
function Y1() {
  Xn = 0;
}
function qs() {
  this._call = this._time = this._next = null;
}
qs.prototype = Ep.prototype = {
  constructor: qs,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? yc() : +n) + (t == null ? 0 : +t), !this._next && ui !== this && (ui ? ui._next = this : js = this, ui = this), this._call = e, this._time = n, sl();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, sl());
  }
};
function Ep(e, t, n) {
  var r = new qs();
  return r.restart(e, t, n), r;
}
function X1() {
  yc(), ++Rr;
  for (var e = js, t; e; )
    (t = Xn - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Rr;
}
function Nu() {
  Xn = (Ws = Ri.now()) + ka, Rr = ci = 0;
  try {
    X1();
  } finally {
    Rr = 0, K1(), Xn = 0;
  }
}
function Z1() {
  var e = Ri.now(), t = e - Ws;
  t > wp && (ka -= t, Ws = e);
}
function K1() {
  for (var e, t = js, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : js = n);
  ui = e, sl(r);
}
function sl(e) {
  if (!Rr) {
    ci && (ci = clearTimeout(ci));
    var t = e - Xn;
    t > 24 ? (e < 1 / 0 && (ci = setTimeout(Nu, e - Ri.now() - ka)), Qr && (Qr = clearInterval(Qr))) : (Qr || (Ws = Ri.now(), Qr = setInterval(Z1, wp)), Rr = 1, _p(Nu));
  }
}
function Pu(e, t, n) {
  var r = new qs();
  return t = t == null ? 0 : +t, r.restart((i) => {
    r.stop(), e(i + t);
  }, t, n), r;
}
var Q1 = dc("start", "end", "cancel", "interrupt"), J1 = [], Sp = 0, Uu = 1, al = 2, Ms = 3, Bu = 4, ol = 5, Cs = 6;
function Ra(e, t, n, r, i, s) {
  var a = e.__transition;
  if (!a)
    e.__transition = {};
  else if (n in a)
    return;
  tx(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: i,
    // For context during callback.
    on: Q1,
    tween: J1,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: Sp
  });
}
function xc(e, t) {
  var n = Ve(e, t);
  if (n.state > Sp)
    throw new Error("too late; already scheduled");
  return n;
}
function Qe(e, t) {
  var n = Ve(e, t);
  if (n.state > Ms)
    throw new Error("too late; already running");
  return n;
}
function Ve(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t]))
    throw new Error("transition not found");
  return n;
}
function tx(e, t, n) {
  var r = e.__transition, i;
  r[t] = n, n.timer = Ep(s, 0, n.time);
  function s(c) {
    n.state = Uu, n.timer.restart(a, n.delay, n.time), n.delay <= c && a(c - n.delay);
  }
  function a(c) {
    var u, h, d, f;
    if (n.state !== Uu)
      return l();
    for (u in r)
      if (f = r[u], f.name === n.name) {
        if (f.state === Ms)
          return Pu(a);
        f.state === Bu ? (f.state = Cs, f.timer.stop(), f.on.call("interrupt", e, e.__data__, f.index, f.group), delete r[u]) : +u < t && (f.state = Cs, f.timer.stop(), f.on.call("cancel", e, e.__data__, f.index, f.group), delete r[u]);
      }
    if (Pu(function() {
      n.state === Ms && (n.state = Bu, n.timer.restart(o, n.delay, n.time), o(c));
    }), n.state = al, n.on.call("start", e, e.__data__, n.index, n.group), n.state === al) {
      for (n.state = Ms, i = new Array(d = n.tween.length), u = 0, h = -1; u < d; ++u)
        (f = n.tween[u].value.call(e, e.__data__, n.index, n.group)) && (i[++h] = f);
      i.length = h + 1;
    }
  }
  function o(c) {
    for (var u = c < n.duration ? n.ease.call(null, c / n.duration) : (n.timer.restart(l), n.state = ol, 1), h = -1, d = i.length; ++h < d; )
      i[h].call(e, u);
    n.state === ol && (n.on.call("end", e, e.__data__, n.index, n.group), l());
  }
  function l() {
    n.state = Cs, n.timer.stop(), delete r[t];
    for (var c in r)
      return;
    delete e.__transition;
  }
}
function ll(e, t) {
  var n = e.__transition, r, i, s = !0, a;
  if (n) {
    t = t == null ? null : t + "";
    for (a in n) {
      if ((r = n[a]).name !== t) {
        s = !1;
        continue;
      }
      i = r.state > al && r.state < ol, r.state = Cs, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[a];
    }
    s && delete e.__transition;
  }
}
function ex(e) {
  return this.each(function() {
    ll(this, e);
  });
}
function nx(e, t) {
  var n, r;
  return function() {
    var i = Qe(this, e), s = i.tween;
    if (s !== n) {
      r = n = s;
      for (var a = 0, o = r.length; a < o; ++a)
        if (r[a].name === t) {
          r = r.slice(), r.splice(a, 1);
          break;
        }
    }
    i.tween = r;
  };
}
function rx(e, t, n) {
  var r, i;
  if (typeof n != "function")
    throw new Error();
  return function() {
    var s = Qe(this, e), a = s.tween;
    if (a !== r) {
      i = (r = a).slice();
      for (var o = { name: t, value: n }, l = 0, c = i.length; l < c; ++l)
        if (i[l].name === t) {
          i[l] = o;
          break;
        }
      l === c && i.push(o);
    }
    s.tween = i;
  };
}
function ix(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = Ve(this.node(), n).tween, i = 0, s = r.length, a; i < s; ++i)
      if ((a = r[i]).name === e)
        return a.value;
    return null;
  }
  return this.each((t == null ? nx : rx)(n, e, t));
}
function bc(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var i = Qe(this, r);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return Ve(i, r).value[t];
  };
}
function Op(e, t) {
  var n;
  return (typeof t == "number" ? xe : t instanceof pn ? zs : (n = pn(t)) ? (t = n, zs) : vp)(e, t);
}
function sx(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function ax(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function ox(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var a = this.getAttribute(e);
    return a === i ? null : a === r ? s : s = t(r = a, n);
  };
}
function lx(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var a = this.getAttributeNS(e.space, e.local);
    return a === i ? null : a === r ? s : s = t(r = a, n);
  };
}
function cx(e, t, n) {
  var r, i, s;
  return function() {
    var a, o = n(this), l;
    return o == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), l = o + "", a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o)));
  };
}
function ux(e, t, n) {
  var r, i, s;
  return function() {
    var a, o = n(this), l;
    return o == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), l = o + "", a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o)));
  };
}
function hx(e, t) {
  var n = Da(e), r = n === "transform" ? W1 : Op;
  return this.attrTween(e, typeof t == "function" ? (n.local ? ux : cx)(n, r, bc(this, "attr." + e, t)) : t == null ? (n.local ? ax : sx)(n) : (n.local ? lx : ox)(n, r, t));
}
function dx(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function fx(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function px(e, t) {
  var n, r;
  function i() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && fx(e, s)), n;
  }
  return i._value = t, i;
}
function gx(e, t) {
  var n, r;
  function i() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && dx(e, s)), n;
  }
  return i._value = t, i;
}
function mx(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  var r = Da(e);
  return this.tween(n, (r.local ? px : gx)(r, t));
}
function vx(e, t) {
  return function() {
    xc(this, e).delay = +t.apply(this, arguments);
  };
}
function yx(e, t) {
  return t = +t, function() {
    xc(this, e).delay = t;
  };
}
function xx(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? vx : yx)(t, e)) : Ve(this.node(), t).delay;
}
function bx(e, t) {
  return function() {
    Qe(this, e).duration = +t.apply(this, arguments);
  };
}
function wx(e, t) {
  return t = +t, function() {
    Qe(this, e).duration = t;
  };
}
function _x(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? bx : wx)(t, e)) : Ve(this.node(), t).duration;
}
function Ex(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    Qe(this, e).ease = t;
  };
}
function Sx(e) {
  var t = this._id;
  return arguments.length ? this.each(Ex(t, e)) : Ve(this.node(), t).ease;
}
function Ox(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function")
      throw new Error();
    Qe(this, e).ease = n;
  };
}
function Tx(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(Ox(this._id, e));
}
function Mx(e) {
  typeof e != "function" && (e = ip(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], a = s.length, o = r[i] = [], l, c = 0; c < a; ++c)
      (l = s[c]) && e.call(l, l.__data__, c, s) && o.push(l);
  return new gn(r, this._parents, this._name, this._id);
}
function Cx(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, i = n.length, s = Math.min(r, i), a = new Array(r), o = 0; o < s; ++o)
    for (var l = t[o], c = n[o], u = l.length, h = a[o] = new Array(u), d, f = 0; f < u; ++f)
      (d = l[f] || c[f]) && (h[f] = d);
  for (; o < r; ++o)
    a[o] = t[o];
  return new gn(a, this._parents, this._name, this._id);
}
function $x(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function Ax(e, t, n) {
  var r, i, s = $x(t) ? xc : Qe;
  return function() {
    var a = s(this, e), o = a.on;
    o !== r && (i = (r = o).copy()).on(t, n), a.on = i;
  };
}
function Lx(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Ve(this.node(), n).on.on(e) : this.each(Ax(n, e, t));
}
function Dx(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition)
      if (+n !== e)
        return;
    t && t.removeChild(this);
  };
}
function kx() {
  return this.on("end.remove", Dx(this._id));
}
function Rx(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = fc(e));
  for (var r = this._groups, i = r.length, s = new Array(i), a = 0; a < i; ++a)
    for (var o = r[a], l = o.length, c = s[a] = new Array(l), u, h, d = 0; d < l; ++d)
      (u = o[d]) && (h = e.call(u, u.__data__, d, o)) && ("__data__" in u && (h.__data__ = u.__data__), c[d] = h, Ra(c[d], t, n, d, c, Ve(u, n)));
  return new gn(s, this._parents, t, n);
}
function Ix(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = rp(e));
  for (var r = this._groups, i = r.length, s = [], a = [], o = 0; o < i; ++o)
    for (var l = r[o], c = l.length, u, h = 0; h < c; ++h)
      if (u = l[h]) {
        for (var d = e.call(u, u.__data__, h, l), f, p = Ve(u, n), m = 0, g = d.length; m < g; ++m)
          (f = d[m]) && Ra(f, t, n, m, d, p);
        s.push(d), a.push(u);
      }
  return new gn(s, a, t, n);
}
var Nx = ji.prototype.constructor;
function Px() {
  return new Nx(this._groups, this._parents);
}
function Ux(e, t) {
  var n, r, i;
  return function() {
    var s = kr(this, e), a = (this.style.removeProperty(e), kr(this, e));
    return s === a ? null : s === n && a === r ? i : i = t(n = s, r = a);
  };
}
function Tp(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Bx(e, t, n) {
  var r, i = n + "", s;
  return function() {
    var a = kr(this, e);
    return a === i ? null : a === r ? s : s = t(r = a, n);
  };
}
function Vx(e, t, n) {
  var r, i, s;
  return function() {
    var a = kr(this, e), o = n(this), l = o + "";
    return o == null && (l = o = (this.style.removeProperty(e), kr(this, e))), a === l ? null : a === r && l === i ? s : (i = l, s = t(r = a, o));
  };
}
function Hx(e, t) {
  var n, r, i, s = "style." + t, a = "end." + s, o;
  return function() {
    var l = Qe(this, e), c = l.on, u = l.value[s] == null ? o || (o = Tp(t)) : void 0;
    (c !== n || i !== u) && (r = (n = c).copy()).on(a, i = u), l.on = r;
  };
}
function Fx(e, t, n) {
  var r = (e += "") == "transform" ? j1 : Op;
  return t == null ? this.styleTween(e, Ux(e, r)).on("end.style." + e, Tp(e)) : typeof t == "function" ? this.styleTween(e, Vx(e, r, bc(this, "style." + e, t))).each(Hx(this._id, e)) : this.styleTween(e, Bx(e, r, t), n).on("end.style." + e, null);
}
function Gx(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function zx(e, t, n) {
  var r, i;
  function s() {
    var a = t.apply(this, arguments);
    return a !== i && (r = (i = a) && Gx(e, a, n)), r;
  }
  return s._value = t, s;
}
function jx(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2)
    return (r = this.tween(r)) && r._value;
  if (t == null)
    return this.tween(r, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(r, zx(e, t, n ?? ""));
}
function Wx(e) {
  return function() {
    this.textContent = e;
  };
}
function qx(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function Yx(e) {
  return this.tween("text", typeof e == "function" ? qx(bc(this, "text", e)) : Wx(e == null ? "" : e + ""));
}
function Xx(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function Zx(e) {
  var t, n;
  function r() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && Xx(i)), t;
  }
  return r._value = e, r;
}
function Kx(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, Zx(e));
}
function Qx() {
  for (var e = this._name, t = this._id, n = Mp(), r = this._groups, i = r.length, s = 0; s < i; ++s)
    for (var a = r[s], o = a.length, l, c = 0; c < o; ++c)
      if (l = a[c]) {
        var u = Ve(l, t);
        Ra(l, e, n, c, a, {
          time: u.time + u.delay + u.duration,
          delay: 0,
          duration: u.duration,
          ease: u.ease
        });
      }
  return new gn(r, this._parents, e, n);
}
function Jx() {
  var e, t, n = this, r = n._id, i = n.size();
  return new Promise(function(s, a) {
    var o = { value: a }, l = { value: function() {
      --i === 0 && s();
    } };
    n.each(function() {
      var c = Qe(this, r), u = c.on;
      u !== e && (t = (e = u).copy(), t._.cancel.push(o), t._.interrupt.push(o), t._.end.push(l)), c.on = t;
    }), i === 0 && s();
  });
}
var tb = 0;
function gn(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function Mp() {
  return ++tb;
}
var en = ji.prototype;
gn.prototype = {
  constructor: gn,
  select: Rx,
  selectAll: Ix,
  selectChild: en.selectChild,
  selectChildren: en.selectChildren,
  filter: Mx,
  merge: Cx,
  selection: Px,
  transition: Qx,
  call: en.call,
  nodes: en.nodes,
  node: en.node,
  size: en.size,
  empty: en.empty,
  each: en.each,
  on: Lx,
  attr: hx,
  attrTween: mx,
  style: Fx,
  styleTween: jx,
  text: Yx,
  textTween: Kx,
  remove: kx,
  tween: ix,
  delay: xx,
  duration: _x,
  ease: Sx,
  easeVarying: Tx,
  end: Jx,
  [Symbol.iterator]: en[Symbol.iterator]
};
const eb = (e) => +e;
function Cp(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var nb = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Cp
};
function rb(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function ib(e) {
  var t, n;
  e instanceof gn ? (t = e._id, e = e._name) : (t = Mp(), (n = nb).time = yc(), e = e == null ? null : e + "");
  for (var r = this._groups, i = r.length, s = 0; s < i; ++s)
    for (var a = r[s], o = a.length, l, c = 0; c < o; ++c)
      (l = a[c]) && Ra(l, e, t, c, a, n || rb(l, t));
  return new gn(r, this._parents, e, t);
}
ji.prototype.interrupt = ex;
ji.prototype.transition = ib;
const vo = (e) => () => e;
function sb(e, {
  sourceEvent: t,
  target: n,
  selection: r,
  mode: i,
  dispatch: s
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    selection: { value: r, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: s }
  });
}
function ab(e) {
  e.stopImmediatePropagation();
}
function yo(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
var Vu = { name: "drag" }, xo = { name: "space" }, ur = { name: "handle" }, hr = { name: "center" };
const { abs: Hu, max: ne, min: re } = Math;
function Fu(e) {
  return [+e[0], +e[1]];
}
function Gu(e) {
  return [Fu(e[0]), Fu(e[1])];
}
var $s = {
  name: "x",
  handles: ["w", "e"].map(Ys),
  input: function(e, t) {
    return e == null ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
  },
  output: function(e) {
    return e && [e[0][0], e[1][0]];
  }
}, bo = {
  name: "y",
  handles: ["n", "s"].map(Ys),
  input: function(e, t) {
    return e == null ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
  },
  output: function(e) {
    return e && [e[0][1], e[1][1]];
  }
}, nn = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, zu = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, ju = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, ob = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, lb = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function Ys(e) {
  return { type: e };
}
function cb(e) {
  return !e.ctrlKey && !e.button;
}
function ub() {
  var e = this.ownerSVGElement || this;
  return e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
}
function hb() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function wo(e) {
  for (; !e.__brush; )
    if (!(e = e.parentNode))
      return;
  return e.__brush;
}
function db(e) {
  return e[0][0] === e[1][0] || e[0][1] === e[1][1];
}
function $p() {
  return fb($s);
}
function fb(e) {
  var t = ub, n = cb, r = hb, i = !0, s = dc("start", "brush", "end"), a = 6, o;
  function l(g) {
    var v = g.property("__brush", m).selectAll(".overlay").data([Ys("overlay")]);
    v.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", nn.overlay).merge(v).each(function() {
      var x = wo(this).extent;
      R(this).attr("x", x[0][0]).attr("y", x[0][1]).attr("width", x[1][0] - x[0][0]).attr("height", x[1][1] - x[0][1]);
    }), g.selectAll(".selection").data([Ys("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", nn.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var y = g.selectAll(".handle").data(e.handles, function(x) {
      return x.type;
    });
    y.exit().remove(), y.enter().append("rect").attr("class", function(x) {
      return "handle handle--" + x.type;
    }).attr("cursor", function(x) {
      return nn[x.type];
    }), g.each(c).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", d).filter(r).on("touchstart.brush", d).on("touchmove.brush", f).on("touchend.brush touchcancel.brush", p).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  l.move = function(g, v, y) {
    g.tween ? g.on("start.brush", function(x) {
      u(this, arguments).beforestart().start(x);
    }).on("interrupt.brush end.brush", function(x) {
      u(this, arguments).end(x);
    }).tween("brush", function() {
      var x = this, S = x.__brush, _ = u(x, arguments), E = S.selection, T = e.input(typeof v == "function" ? v.apply(this, arguments) : v, S.extent), k = qi(E, T);
      function N(L) {
        S.selection = L === 1 && T === null ? null : k(L), c.call(x), _.brush();
      }
      return E !== null && T !== null ? N : N(1);
    }) : g.each(function() {
      var x = this, S = arguments, _ = x.__brush, E = e.input(typeof v == "function" ? v.apply(x, S) : v, _.extent), T = u(x, S).beforestart();
      ll(x), _.selection = E === null ? null : E, c.call(x), T.start(y).brush(y).end(y);
    });
  }, l.clear = function(g, v) {
    l.move(g, null, v);
  };
  function c() {
    var g = R(this), v = wo(this).selection;
    v ? (g.selectAll(".selection").style("display", null).attr("x", v[0][0]).attr("y", v[0][1]).attr("width", v[1][0] - v[0][0]).attr("height", v[1][1] - v[0][1]), g.selectAll(".handle").style("display", null).attr("x", function(y) {
      return y.type[y.type.length - 1] === "e" ? v[1][0] - a / 2 : v[0][0] - a / 2;
    }).attr("y", function(y) {
      return y.type[0] === "s" ? v[1][1] - a / 2 : v[0][1] - a / 2;
    }).attr("width", function(y) {
      return y.type === "n" || y.type === "s" ? v[1][0] - v[0][0] + a : a;
    }).attr("height", function(y) {
      return y.type === "e" || y.type === "w" ? v[1][1] - v[0][1] + a : a;
    })) : g.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function u(g, v, y) {
    var x = g.__brush.emitter;
    return x && (!y || !x.clean) ? x : new h(g, v, y);
  }
  function h(g, v, y) {
    this.that = g, this.args = v, this.state = g.__brush, this.active = 0, this.clean = y;
  }
  h.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(g, v) {
      return this.starting ? (this.starting = !1, this.emit("start", g, v)) : this.emit("brush", g), this;
    },
    brush: function(g, v) {
      return this.emit("brush", g, v), this;
    },
    end: function(g, v) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", g, v)), this;
    },
    emit: function(g, v, y) {
      var x = R(this.that).datum();
      s.call(
        g,
        this.that,
        new sb(g, {
          sourceEvent: v,
          target: l,
          selection: e.output(this.state.selection),
          mode: y,
          dispatch: s
        }),
        x
      );
    }
  };
  function d(g) {
    if (o && !g.touches || !n.apply(this, arguments))
      return;
    var v = this, y = g.target.__data__.type, x = (i && g.metaKey ? y = "overlay" : y) === "selection" ? Vu : i && g.altKey ? hr : ur, S = e === bo ? null : ob[y], _ = e === $s ? null : lb[y], E = wo(v), T = E.extent, k = E.selection, N = T[0][0], L, C, V = T[0][1], M, A, w = T[1][0], P, U, I = T[1][1], B, j, Y = 0, J = 0, ft, z = S && _ && i && g.shiftKey, Z, ut, nt = Array.from(g.touches || [g], (tt) => {
      const Dt = tt.identifier;
      return tt = Yn(tt, v), tt.point0 = tt.slice(), tt.identifier = Dt, tt;
    });
    ll(v);
    var Ot = u(v, arguments, !0).beforestart();
    if (y === "overlay") {
      k && (ft = !0);
      const tt = [nt[0], nt[1] || nt[0]];
      E.selection = k = [[
        L = e === bo ? N : re(tt[0][0], tt[1][0]),
        M = e === $s ? V : re(tt[0][1], tt[1][1])
      ], [
        P = e === bo ? w : ne(tt[0][0], tt[1][0]),
        B = e === $s ? I : ne(tt[0][1], tt[1][1])
      ]], nt.length > 1 && It(g);
    } else
      L = k[0][0], M = k[0][1], P = k[1][0], B = k[1][1];
    C = L, A = M, U = P, j = B;
    var W = R(v).attr("pointer-events", "none"), Q = W.selectAll(".overlay").attr("cursor", nn[y]);
    if (g.touches)
      Ot.moved = F, Ot.ended = vt;
    else {
      var lt = R(g.view).on("mousemove.brush", F, !0).on("mouseup.brush", vt, !0);
      i && lt.on("keydown.brush", Gt, !0).on("keyup.brush", zt, !0), b1(g.view);
    }
    c.call(v), Ot.start(g, x.name);
    function F(tt) {
      for (const Dt of tt.changedTouches || [tt])
        for (const Ge of nt)
          Ge.identifier === Dt.identifier && (Ge.cur = Yn(Dt, v));
      if (z && !Z && !ut && nt.length === 1) {
        const Dt = nt[0];
        Hu(Dt.cur[0] - Dt[0]) > Hu(Dt.cur[1] - Dt[1]) ? ut = !0 : Z = !0;
      }
      for (const Dt of nt)
        Dt.cur && (Dt[0] = Dt.cur[0], Dt[1] = Dt.cur[1]);
      ft = !0, yo(tt), It(tt);
    }
    function It(tt) {
      const Dt = nt[0], Ge = Dt.point0;
      var ze;
      switch (Y = Dt[0] - Ge[0], J = Dt[1] - Ge[1], x) {
        case xo:
        case Vu: {
          S && (Y = ne(N - L, re(w - P, Y)), C = L + Y, U = P + Y), _ && (J = ne(V - M, re(I - B, J)), A = M + J, j = B + J);
          break;
        }
        case ur: {
          nt[1] ? (S && (C = ne(N, re(w, nt[0][0])), U = ne(N, re(w, nt[1][0])), S = 1), _ && (A = ne(V, re(I, nt[0][1])), j = ne(V, re(I, nt[1][1])), _ = 1)) : (S < 0 ? (Y = ne(N - L, re(w - L, Y)), C = L + Y, U = P) : S > 0 && (Y = ne(N - P, re(w - P, Y)), C = L, U = P + Y), _ < 0 ? (J = ne(V - M, re(I - M, J)), A = M + J, j = B) : _ > 0 && (J = ne(V - B, re(I - B, J)), A = M, j = B + J));
          break;
        }
        case hr: {
          S && (C = ne(N, re(w, L - Y * S)), U = ne(N, re(w, P + Y * S))), _ && (A = ne(V, re(I, M - J * _)), j = ne(V, re(I, B + J * _)));
          break;
        }
      }
      U < C && (S *= -1, ze = L, L = P, P = ze, ze = C, C = U, U = ze, y in zu && Q.attr("cursor", nn[y = zu[y]])), j < A && (_ *= -1, ze = M, M = B, B = ze, ze = A, A = j, j = ze, y in ju && Q.attr("cursor", nn[y = ju[y]])), E.selection && (k = E.selection), Z && (C = k[0][0], U = k[1][0]), ut && (A = k[0][1], j = k[1][1]), (k[0][0] !== C || k[0][1] !== A || k[1][0] !== U || k[1][1] !== j) && (E.selection = [[C, A], [U, j]], c.call(v), Ot.brush(tt, x.name));
    }
    function vt(tt) {
      if (ab(tt), tt.touches) {
        if (tt.touches.length)
          return;
        o && clearTimeout(o), o = setTimeout(function() {
          o = null;
        }, 500);
      } else
        w1(tt.view, ft), lt.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      W.attr("pointer-events", "all"), Q.attr("cursor", nn.overlay), E.selection && (k = E.selection), db(k) && (E.selection = null, c.call(v)), Ot.end(tt, x.name);
    }
    function Gt(tt) {
      switch (tt.keyCode) {
        case 16: {
          z = S && _;
          break;
        }
        case 18: {
          x === ur && (S && (P = U - Y * S, L = C + Y * S), _ && (B = j - J * _, M = A + J * _), x = hr, It(tt));
          break;
        }
        case 32: {
          (x === ur || x === hr) && (S < 0 ? P = U - Y : S > 0 && (L = C - Y), _ < 0 ? B = j - J : _ > 0 && (M = A - J), x = xo, Q.attr("cursor", nn.selection), It(tt));
          break;
        }
        default:
          return;
      }
      yo(tt);
    }
    function zt(tt) {
      switch (tt.keyCode) {
        case 16: {
          z && (Z = ut = z = !1, It(tt));
          break;
        }
        case 18: {
          x === hr && (S < 0 ? P = U : S > 0 && (L = C), _ < 0 ? B = j : _ > 0 && (M = A), x = ur, It(tt));
          break;
        }
        case 32: {
          x === xo && (tt.altKey ? (S && (P = U - Y * S, L = C + Y * S), _ && (B = j - J * _, M = A + J * _), x = hr) : (S < 0 ? P = U : S > 0 && (L = C), _ < 0 ? B = j : _ > 0 && (M = A), x = ur), Q.attr("cursor", nn[y]), It(tt));
          break;
        }
        default:
          return;
      }
      yo(tt);
    }
  }
  function f(g) {
    u(this, arguments).moved(g);
  }
  function p(g) {
    u(this, arguments).ended(g);
  }
  function m() {
    var g = this.__brush || { selection: null };
    return g.extent = Gu(t.apply(this, arguments)), g.dim = e, g;
  }
  return l.extent = function(g) {
    return arguments.length ? (t = typeof g == "function" ? g : vo(Gu(g)), l) : t;
  }, l.filter = function(g) {
    return arguments.length ? (n = typeof g == "function" ? g : vo(!!g), l) : n;
  }, l.touchable = function(g) {
    return arguments.length ? (r = typeof g == "function" ? g : vo(!!g), l) : r;
  }, l.handleSize = function(g) {
    return arguments.length ? (a = +g, l) : a;
  }, l.keyModifiers = function(g) {
    return arguments.length ? (i = !!g, l) : i;
  }, l.on = function() {
    var g = s.on.apply(s, arguments);
    return g === s ? l : g;
  }, l;
}
const cl = Math.PI, ul = 2 * cl, Un = 1e-6, pb = ul - Un;
function Ap(e) {
  this._ += e[0];
  for (let t = 1, n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function gb(e) {
  let t = Math.floor(e);
  if (!(t >= 0))
    throw new Error(`invalid digits: ${e}`);
  if (t > 15)
    return Ap;
  const n = 10 ** t;
  return function(r) {
    this._ += r[0];
    for (let i = 1, s = r.length; i < s; ++i)
      this._ += Math.round(arguments[i] * n) / n + r[i];
  };
}
let wc = class {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? Ap : gb(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, r, i) {
    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;
  }
  bezierCurveTo(t, n, r, i, s, a) {
    this._append`C${+t},${+n},${+r},${+i},${this._x1 = +s},${this._y1 = +a}`;
  }
  arcTo(t, n, r, i, s) {
    if (t = +t, n = +n, r = +r, i = +i, s = +s, s < 0)
      throw new Error(`negative radius: ${s}`);
    let a = this._x1, o = this._y1, l = r - t, c = i - n, u = a - t, h = o - n, d = u * u + h * h;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (d > Un)
      if (!(Math.abs(h * l - c * u) > Un) || !s)
        this._append`L${this._x1 = t},${this._y1 = n}`;
      else {
        let f = r - a, p = i - o, m = l * l + c * c, g = f * f + p * p, v = Math.sqrt(m), y = Math.sqrt(d), x = s * Math.tan((cl - Math.acos((m + d - g) / (2 * v * y))) / 2), S = x / y, _ = x / v;
        Math.abs(S - 1) > Un && this._append`L${t + S * u},${n + S * h}`, this._append`A${s},${s},0,0,${+(h * f > u * p)},${this._x1 = t + _ * l},${this._y1 = n + _ * c}`;
      }
  }
  arc(t, n, r, i, s, a) {
    if (t = +t, n = +n, r = +r, a = !!a, r < 0)
      throw new Error(`negative radius: ${r}`);
    let o = r * Math.cos(i), l = r * Math.sin(i), c = t + o, u = n + l, h = 1 ^ a, d = a ? i - s : s - i;
    this._x1 === null ? this._append`M${c},${u}` : (Math.abs(this._x1 - c) > Un || Math.abs(this._y1 - u) > Un) && this._append`L${c},${u}`, r && (d < 0 && (d = d % ul + ul), d > pb ? this._append`A${r},${r},0,1,${h},${t - o},${n - l}A${r},${r},0,1,${h},${this._x1 = c},${this._y1 = u}` : d > Un && this._append`A${r},${r},0,${+(d >= cl)},${h},${this._x1 = t + r * Math.cos(s)},${this._y1 = n + r * Math.sin(s)}`);
  }
  rect(t, n, r, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;
  }
  toString() {
    return this._;
  }
};
function Lp() {
  return new wc();
}
Lp.prototype = wc.prototype;
function mb(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function Xs(e, t) {
  if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0)
    return null;
  var n, r = e.slice(0, n);
  return [
    r.length > 1 ? r[0] + r.slice(2) : r,
    +e.slice(n + 1)
  ];
}
function Ir(e) {
  return e = Xs(Math.abs(e)), e ? e[1] : NaN;
}
function vb(e, t) {
  return function(n, r) {
    for (var i = n.length, s = [], a = 0, o = e[0], l = 0; i > 0 && o > 0 && (l + o + 1 > r && (o = Math.max(1, r - l)), s.push(n.substring(i -= o, i + o)), !((l += o + 1) > r)); )
      o = e[a = (a + 1) % e.length];
    return s.reverse().join(t);
  };
}
function yb(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(n) {
      return e[+n];
    });
  };
}
var xb = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Ii(e) {
  if (!(t = xb.exec(e)))
    throw new Error("invalid format: " + e);
  var t;
  return new _c({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
Ii.prototype = _c.prototype;
function _c(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
_c.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function bb(e) {
  t:
    for (var t = e.length, n = 1, r = -1, i; n < t; ++n)
      switch (e[n]) {
        case ".":
          r = i = n;
          break;
        case "0":
          r === 0 && (r = n), i = n;
          break;
        default:
          if (!+e[n])
            break t;
          r > 0 && (r = 0);
          break;
      }
  return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e;
}
var Dp;
function wb(e, t) {
  var n = Xs(e, t);
  if (!n)
    return e + "";
  var r = n[0], i = n[1], s = i - (Dp = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, a = r.length;
  return s === a ? r : s > a ? r + new Array(s - a + 1).join("0") : s > 0 ? r.slice(0, s) + "." + r.slice(s) : "0." + new Array(1 - s).join("0") + Xs(e, Math.max(0, t + s - 1))[0];
}
function Wu(e, t) {
  var n = Xs(e, t);
  if (!n)
    return e + "";
  var r = n[0], i = n[1];
  return i < 0 ? "0." + new Array(-i).join("0") + r : r.length > i + 1 ? r.slice(0, i + 1) + "." + r.slice(i + 1) : r + new Array(i - r.length + 2).join("0");
}
const qu = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: mb,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => Wu(e * 100, t),
  r: Wu,
  s: wb,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function Yu(e) {
  return e;
}
var Xu = Array.prototype.map, Zu = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function _b(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? Yu : vb(Xu.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", r = e.currency === void 0 ? "" : e.currency[1] + "", i = e.decimal === void 0 ? "." : e.decimal + "", s = e.numerals === void 0 ? Yu : yb(Xu.call(e.numerals, String)), a = e.percent === void 0 ? "%" : e.percent + "", o = e.minus === void 0 ? "" : e.minus + "", l = e.nan === void 0 ? "NaN" : e.nan + "";
  function c(h) {
    h = Ii(h);
    var d = h.fill, f = h.align, p = h.sign, m = h.symbol, g = h.zero, v = h.width, y = h.comma, x = h.precision, S = h.trim, _ = h.type;
    _ === "n" ? (y = !0, _ = "g") : qu[_] || (x === void 0 && (x = 12), S = !0, _ = "g"), (g || d === "0" && f === "=") && (g = !0, d = "0", f = "=");
    var E = m === "$" ? n : m === "#" && /[boxX]/.test(_) ? "0" + _.toLowerCase() : "", T = m === "$" ? r : /[%p]/.test(_) ? a : "", k = qu[_], N = /[defgprs%]/.test(_);
    x = x === void 0 ? 6 : /[gprs]/.test(_) ? Math.max(1, Math.min(21, x)) : Math.max(0, Math.min(20, x));
    function L(C) {
      var V = E, M = T, A, w, P;
      if (_ === "c")
        M = k(C) + M, C = "";
      else {
        C = +C;
        var U = C < 0 || 1 / C < 0;
        if (C = isNaN(C) ? l : k(Math.abs(C), x), S && (C = bb(C)), U && +C == 0 && p !== "+" && (U = !1), V = (U ? p === "(" ? p : o : p === "-" || p === "(" ? "" : p) + V, M = (_ === "s" ? Zu[8 + Dp / 3] : "") + M + (U && p === "(" ? ")" : ""), N) {
          for (A = -1, w = C.length; ++A < w; )
            if (P = C.charCodeAt(A), 48 > P || P > 57) {
              M = (P === 46 ? i + C.slice(A + 1) : C.slice(A)) + M, C = C.slice(0, A);
              break;
            }
        }
      }
      y && !g && (C = t(C, 1 / 0));
      var I = V.length + C.length + M.length, B = I < v ? new Array(v - I + 1).join(d) : "";
      switch (y && g && (C = t(B + C, B.length ? v - M.length : 1 / 0), B = ""), f) {
        case "<":
          C = V + C + M + B;
          break;
        case "=":
          C = V + B + C + M;
          break;
        case "^":
          C = B.slice(0, I = B.length >> 1) + V + C + M + B.slice(I);
          break;
        default:
          C = B + V + C + M;
          break;
      }
      return s(C);
    }
    return L.toString = function() {
      return h + "";
    }, L;
  }
  function u(h, d) {
    var f = c((h = Ii(h), h.type = "f", h)), p = Math.max(-8, Math.min(8, Math.floor(Ir(d) / 3))) * 3, m = Math.pow(10, -p), g = Zu[8 + p / 3];
    return function(v) {
      return f(m * v) + g;
    };
  }
  return {
    format: c,
    formatPrefix: u
  };
}
var ls, Ec, kp;
Eb({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function Eb(e) {
  return ls = _b(e), Ec = ls.format, kp = ls.formatPrefix, ls;
}
function Sb(e) {
  return Math.max(0, -Ir(Math.abs(e)));
}
function Ob(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Ir(t) / 3))) * 3 - Ir(Math.abs(e)));
}
function Tb(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Ir(t) - Ir(e)) + 1;
}
var _t = 1e-6, Rp = 1e-12, ht = Math.PI, fe = ht / 2, Ku = ht / 4, _e = ht * 2, le = 180 / ht, Ht = ht / 180, Et = Math.abs, Ip = Math.atan, Zn = Math.atan2, St = Math.cos, Mb = Math.exp, Cb = Math.log, bt = Math.sin, $n = Math.sign || function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, Ue = Math.sqrt, $b = Math.tan;
function Ab(e) {
  return e > 1 ? 0 : e < -1 ? ht : Math.acos(e);
}
function mn(e) {
  return e > 1 ? fe : e < -1 ? -fe : Math.asin(e);
}
function Me() {
}
function Zs(e, t) {
  e && Ju.hasOwnProperty(e.type) && Ju[e.type](e, t);
}
var Qu = {
  Feature: function(e, t) {
    Zs(e.geometry, t);
  },
  FeatureCollection: function(e, t) {
    for (var n = e.features, r = -1, i = n.length; ++r < i; )
      Zs(n[r].geometry, t);
  }
}, Ju = {
  Sphere: function(e, t) {
    t.sphere();
  },
  Point: function(e, t) {
    e = e.coordinates, t.point(e[0], e[1], e[2]);
  },
  MultiPoint: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      e = n[r], t.point(e[0], e[1], e[2]);
  },
  LineString: function(e, t) {
    hl(e.coordinates, t, 0);
  },
  MultiLineString: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      hl(n[r], t, 0);
  },
  Polygon: function(e, t) {
    th(e.coordinates, t);
  },
  MultiPolygon: function(e, t) {
    for (var n = e.coordinates, r = -1, i = n.length; ++r < i; )
      th(n[r], t);
  },
  GeometryCollection: function(e, t) {
    for (var n = e.geometries, r = -1, i = n.length; ++r < i; )
      Zs(n[r], t);
  }
};
function hl(e, t, n) {
  var r = -1, i = e.length - n, s;
  for (t.lineStart(); ++r < i; )
    s = e[r], t.point(s[0], s[1], s[2]);
  t.lineEnd();
}
function th(e, t) {
  var n = -1, r = e.length;
  for (t.polygonStart(); ++n < r; )
    hl(e[n], t, 1);
  t.polygonEnd();
}
function vr(e, t) {
  e && Qu.hasOwnProperty(e.type) ? Qu[e.type](e, t) : Zs(e, t);
}
function dl(e) {
  return [Zn(e[1], e[0]), mn(e[2])];
}
function Nr(e) {
  var t = e[0], n = e[1], r = St(n);
  return [r * St(t), r * bt(t), bt(n)];
}
function cs(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function Ks(e, t) {
  return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
}
function _o(e, t) {
  e[0] += t[0], e[1] += t[1], e[2] += t[2];
}
function us(e, t) {
  return [e[0] * t, e[1] * t, e[2] * t];
}
function fl(e) {
  var t = Ue(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
  e[0] /= t, e[1] /= t, e[2] /= t;
}
function pl(e, t) {
  function n(r, i) {
    return r = e(r, i), t(r[0], r[1]);
  }
  return e.invert && t.invert && (n.invert = function(r, i) {
    return r = t.invert(r, i), r && e.invert(r[0], r[1]);
  }), n;
}
function gl(e, t) {
  return Et(e) > ht && (e -= Math.round(e / _e) * _e), [e, t];
}
gl.invert = gl;
function Np(e, t, n) {
  return (e %= _e) ? t || n ? pl(nh(e), rh(t, n)) : nh(e) : t || n ? rh(t, n) : gl;
}
function eh(e) {
  return function(t, n) {
    return t += e, Et(t) > ht && (t -= Math.round(t / _e) * _e), [t, n];
  };
}
function nh(e) {
  var t = eh(e);
  return t.invert = eh(-e), t;
}
function rh(e, t) {
  var n = St(e), r = bt(e), i = St(t), s = bt(t);
  function a(o, l) {
    var c = St(l), u = St(o) * c, h = bt(o) * c, d = bt(l), f = d * n + u * r;
    return [
      Zn(h * i - f * s, u * n - d * r),
      mn(f * i + h * s)
    ];
  }
  return a.invert = function(o, l) {
    var c = St(l), u = St(o) * c, h = bt(o) * c, d = bt(l), f = d * i - h * s;
    return [
      Zn(h * i + d * s, u * n + f * r),
      mn(f * n - u * r)
    ];
  }, a;
}
function Lb(e) {
  e = Np(e[0] * Ht, e[1] * Ht, e.length > 2 ? e[2] * Ht : 0);
  function t(n) {
    return n = e(n[0] * Ht, n[1] * Ht), n[0] *= le, n[1] *= le, n;
  }
  return t.invert = function(n) {
    return n = e.invert(n[0] * Ht, n[1] * Ht), n[0] *= le, n[1] *= le, n;
  }, t;
}
function Db(e, t, n, r, i, s) {
  if (n) {
    var a = St(t), o = bt(t), l = r * n;
    i == null ? (i = t + r * _e, s = t - l / 2) : (i = ih(a, i), s = ih(a, s), (r > 0 ? i < s : i > s) && (i += r * _e));
    for (var c, u = i; r > 0 ? u > s : u < s; u -= l)
      c = dl([a, -o * St(u), -o * bt(u)]), e.point(c[0], c[1]);
  }
}
function ih(e, t) {
  t = Nr(t), t[0] -= e, fl(t);
  var n = Ab(-t[1]);
  return ((-t[2] < 0 ? -n : n) + _e - _t) % _e;
}
function Pp() {
  var e = [], t;
  return {
    point: function(n, r, i) {
      t.push([n, r, i]);
    },
    lineStart: function() {
      e.push(t = []);
    },
    lineEnd: Me,
    rejoin: function() {
      e.length > 1 && e.push(e.pop().concat(e.shift()));
    },
    result: function() {
      var n = e;
      return e = [], t = null, n;
    }
  };
}
function As(e, t) {
  return Et(e[0] - t[0]) < _t && Et(e[1] - t[1]) < _t;
}
function hs(e, t, n, r) {
  this.x = e, this.z = t, this.o = n, this.e = r, this.v = !1, this.n = this.p = null;
}
function Up(e, t, n, r, i) {
  var s = [], a = [], o, l;
  if (e.forEach(function(p) {
    if (!((m = p.length - 1) <= 0)) {
      var m, g = p[0], v = p[m], y;
      if (As(g, v)) {
        if (!g[2] && !v[2]) {
          for (i.lineStart(), o = 0; o < m; ++o)
            i.point((g = p[o])[0], g[1]);
          i.lineEnd();
          return;
        }
        v[0] += 2 * _t;
      }
      s.push(y = new hs(g, p, null, !0)), a.push(y.o = new hs(g, null, y, !1)), s.push(y = new hs(v, p, null, !1)), a.push(y.o = new hs(v, null, y, !0));
    }
  }), !!s.length) {
    for (a.sort(t), sh(s), sh(a), o = 0, l = a.length; o < l; ++o)
      a[o].e = n = !n;
    for (var c = s[0], u, h; ; ) {
      for (var d = c, f = !0; d.v; )
        if ((d = d.n) === c)
          return;
      u = d.z, i.lineStart();
      do {
        if (d.v = d.o.v = !0, d.e) {
          if (f)
            for (o = 0, l = u.length; o < l; ++o)
              i.point((h = u[o])[0], h[1]);
          else
            r(d.x, d.n.x, 1, i);
          d = d.n;
        } else {
          if (f)
            for (u = d.p.z, o = u.length - 1; o >= 0; --o)
              i.point((h = u[o])[0], h[1]);
          else
            r(d.x, d.p.x, -1, i);
          d = d.p;
        }
        d = d.o, u = d.z, f = !f;
      } while (!d.v);
      i.lineEnd();
    }
  }
}
function sh(e) {
  if (t = e.length) {
    for (var t, n = 0, r = e[0], i; ++n < t; )
      r.n = i = e[n], i.p = r, r = i;
    r.n = i = e[0], i.p = r;
  }
}
function Eo(e) {
  return Et(e[0]) <= ht ? e[0] : $n(e[0]) * ((Et(e[0]) + ht) % _e - ht);
}
function kb(e, t) {
  var n = Eo(t), r = t[1], i = bt(r), s = [bt(n), -St(n), 0], a = 0, o = 0, l = new Wn();
  i === 1 ? r = fe + _t : i === -1 && (r = -fe - _t);
  for (var c = 0, u = e.length; c < u; ++c)
    if (d = (h = e[c]).length)
      for (var h, d, f = h[d - 1], p = Eo(f), m = f[1] / 2 + Ku, g = bt(m), v = St(m), y = 0; y < d; ++y, p = S, g = E, v = T, f = x) {
        var x = h[y], S = Eo(x), _ = x[1] / 2 + Ku, E = bt(_), T = St(_), k = S - p, N = k >= 0 ? 1 : -1, L = N * k, C = L > ht, V = g * E;
        if (l.add(Zn(V * N * bt(L), v * T + V * St(L))), a += C ? k + N * _e : k, C ^ p >= n ^ S >= n) {
          var M = Ks(Nr(f), Nr(x));
          fl(M);
          var A = Ks(s, M);
          fl(A);
          var w = (C ^ k >= 0 ? -1 : 1) * mn(A[2]);
          (r > w || r === w && (M[0] || M[1])) && (o += C ^ k >= 0 ? 1 : -1);
        }
      }
  return (a < -_t || a < _t && l < -Rp) ^ o & 1;
}
function Bp(e, t, n, r) {
  return function(i) {
    var s = t(i), a = Pp(), o = t(a), l = !1, c, u, h, d = {
      point: f,
      lineStart: m,
      lineEnd: g,
      polygonStart: function() {
        d.point = v, d.lineStart = y, d.lineEnd = x, u = [], c = [];
      },
      polygonEnd: function() {
        d.point = f, d.lineStart = m, d.lineEnd = g, u = tp(u);
        var S = kb(c, r);
        u.length ? (l || (i.polygonStart(), l = !0), Up(u, Ib, S, n, i)) : S && (l || (i.polygonStart(), l = !0), i.lineStart(), n(null, null, 1, i), i.lineEnd()), l && (i.polygonEnd(), l = !1), u = c = null;
      },
      sphere: function() {
        i.polygonStart(), i.lineStart(), n(null, null, 1, i), i.lineEnd(), i.polygonEnd();
      }
    };
    function f(S, _) {
      e(S, _) && i.point(S, _);
    }
    function p(S, _) {
      s.point(S, _);
    }
    function m() {
      d.point = p, s.lineStart();
    }
    function g() {
      d.point = f, s.lineEnd();
    }
    function v(S, _) {
      h.push([S, _]), o.point(S, _);
    }
    function y() {
      o.lineStart(), h = [];
    }
    function x() {
      v(h[0][0], h[0][1]), o.lineEnd();
      var S = o.clean(), _ = a.result(), E, T = _.length, k, N, L;
      if (h.pop(), c.push(h), h = null, !!T) {
        if (S & 1) {
          if (N = _[0], (k = N.length - 1) > 0) {
            for (l || (i.polygonStart(), l = !0), i.lineStart(), E = 0; E < k; ++E)
              i.point((L = N[E])[0], L[1]);
            i.lineEnd();
          }
          return;
        }
        T > 1 && S & 2 && _.push(_.pop().concat(_.shift())), u.push(_.filter(Rb));
      }
    }
    return d;
  };
}
function Rb(e) {
  return e.length > 1;
}
function Ib(e, t) {
  return ((e = e.x)[0] < 0 ? e[1] - fe - _t : fe - e[1]) - ((t = t.x)[0] < 0 ? t[1] - fe - _t : fe - t[1]);
}
const ah = Bp(
  function() {
    return !0;
  },
  Nb,
  Ub,
  [-ht, -fe]
);
function Nb(e) {
  var t = NaN, n = NaN, r = NaN, i;
  return {
    lineStart: function() {
      e.lineStart(), i = 1;
    },
    point: function(s, a) {
      var o = s > 0 ? ht : -ht, l = Et(s - t);
      Et(l - ht) < _t ? (e.point(t, n = (n + a) / 2 > 0 ? fe : -fe), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(o, n), e.point(s, n), i = 0) : r !== o && l >= ht && (Et(t - r) < _t && (t -= r * _t), Et(s - o) < _t && (s -= o * _t), n = Pb(t, n, s, a), e.point(r, n), e.lineEnd(), e.lineStart(), e.point(o, n), i = 0), e.point(t = s, n = a), r = o;
    },
    lineEnd: function() {
      e.lineEnd(), t = n = NaN;
    },
    clean: function() {
      return 2 - i;
    }
  };
}
function Pb(e, t, n, r) {
  var i, s, a = bt(e - n);
  return Et(a) > _t ? Ip((bt(t) * (s = St(r)) * bt(n) - bt(r) * (i = St(t)) * bt(e)) / (i * s * a)) : (t + r) / 2;
}
function Ub(e, t, n, r) {
  var i;
  if (e == null)
    i = n * fe, r.point(-ht, i), r.point(0, i), r.point(ht, i), r.point(ht, 0), r.point(ht, -i), r.point(0, -i), r.point(-ht, -i), r.point(-ht, 0), r.point(-ht, i);
  else if (Et(e[0] - t[0]) > _t) {
    var s = e[0] < t[0] ? ht : -ht;
    i = n * s / 2, r.point(-s, i), r.point(0, i), r.point(s, i);
  } else
    r.point(t[0], t[1]);
}
function Bb(e) {
  var t = St(e), n = 6 * Ht, r = t > 0, i = Et(t) > _t;
  function s(u, h, d, f) {
    Db(f, e, n, d, u, h);
  }
  function a(u, h) {
    return St(u) * St(h) > t;
  }
  function o(u) {
    var h, d, f, p, m;
    return {
      lineStart: function() {
        p = f = !1, m = 1;
      },
      point: function(g, v) {
        var y = [g, v], x, S = a(g, v), _ = r ? S ? 0 : c(g, v) : S ? c(g + (g < 0 ? ht : -ht), v) : 0;
        if (!h && (p = f = S) && u.lineStart(), S !== f && (x = l(h, y), (!x || As(h, x) || As(y, x)) && (y[2] = 1)), S !== f)
          m = 0, S ? (u.lineStart(), x = l(y, h), u.point(x[0], x[1])) : (x = l(h, y), u.point(x[0], x[1], 2), u.lineEnd()), h = x;
        else if (i && h && r ^ S) {
          var E;
          !(_ & d) && (E = l(y, h, !0)) && (m = 0, r ? (u.lineStart(), u.point(E[0][0], E[0][1]), u.point(E[1][0], E[1][1]), u.lineEnd()) : (u.point(E[1][0], E[1][1]), u.lineEnd(), u.lineStart(), u.point(E[0][0], E[0][1], 3)));
        }
        S && (!h || !As(h, y)) && u.point(y[0], y[1]), h = y, f = S, d = _;
      },
      lineEnd: function() {
        f && u.lineEnd(), h = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return m | (p && f) << 1;
      }
    };
  }
  function l(u, h, d) {
    var f = Nr(u), p = Nr(h), m = [1, 0, 0], g = Ks(f, p), v = cs(g, g), y = g[0], x = v - y * y;
    if (!x)
      return !d && u;
    var S = t * v / x, _ = -t * y / x, E = Ks(m, g), T = us(m, S), k = us(g, _);
    _o(T, k);
    var N = E, L = cs(T, N), C = cs(N, N), V = L * L - C * (cs(T, T) - 1);
    if (!(V < 0)) {
      var M = Ue(V), A = us(N, (-L - M) / C);
      if (_o(A, T), A = dl(A), !d)
        return A;
      var w = u[0], P = h[0], U = u[1], I = h[1], B;
      P < w && (B = w, w = P, P = B);
      var j = P - w, Y = Et(j - ht) < _t, J = Y || j < _t;
      if (!Y && I < U && (B = U, U = I, I = B), J ? Y ? U + I > 0 ^ A[1] < (Et(A[0] - w) < _t ? U : I) : U <= A[1] && A[1] <= I : j > ht ^ (w <= A[0] && A[0] <= P)) {
        var ft = us(N, (-L + M) / C);
        return _o(ft, T), [A, dl(ft)];
      }
    }
  }
  function c(u, h) {
    var d = r ? e : ht - e, f = 0;
    return u < -d ? f |= 1 : u > d && (f |= 2), h < -d ? f |= 4 : h > d && (f |= 8), f;
  }
  return Bp(a, o, s, r ? [0, -e] : [-ht, e - ht]);
}
function Vb(e, t, n, r, i, s) {
  var a = e[0], o = e[1], l = t[0], c = t[1], u = 0, h = 1, d = l - a, f = c - o, p;
  if (p = n - a, !(!d && p > 0)) {
    if (p /= d, d < 0) {
      if (p < u)
        return;
      p < h && (h = p);
    } else if (d > 0) {
      if (p > h)
        return;
      p > u && (u = p);
    }
    if (p = i - a, !(!d && p < 0)) {
      if (p /= d, d < 0) {
        if (p > h)
          return;
        p > u && (u = p);
      } else if (d > 0) {
        if (p < u)
          return;
        p < h && (h = p);
      }
      if (p = r - o, !(!f && p > 0)) {
        if (p /= f, f < 0) {
          if (p < u)
            return;
          p < h && (h = p);
        } else if (f > 0) {
          if (p > h)
            return;
          p > u && (u = p);
        }
        if (p = s - o, !(!f && p < 0)) {
          if (p /= f, f < 0) {
            if (p > h)
              return;
            p > u && (u = p);
          } else if (f > 0) {
            if (p < u)
              return;
            p < h && (h = p);
          }
          return u > 0 && (e[0] = a + u * d, e[1] = o + u * f), h < 1 && (t[0] = a + h * d, t[1] = o + h * f), !0;
        }
      }
    }
  }
}
var hi = 1e9, ds = -hi;
function Hb(e, t, n, r) {
  function i(c, u) {
    return e <= c && c <= n && t <= u && u <= r;
  }
  function s(c, u, h, d) {
    var f = 0, p = 0;
    if (c == null || (f = a(c, h)) !== (p = a(u, h)) || l(c, u) < 0 ^ h > 0)
      do
        d.point(f === 0 || f === 3 ? e : n, f > 1 ? r : t);
      while ((f = (f + h + 4) % 4) !== p);
    else
      d.point(u[0], u[1]);
  }
  function a(c, u) {
    return Et(c[0] - e) < _t ? u > 0 ? 0 : 3 : Et(c[0] - n) < _t ? u > 0 ? 2 : 1 : Et(c[1] - t) < _t ? u > 0 ? 1 : 0 : u > 0 ? 3 : 2;
  }
  function o(c, u) {
    return l(c.x, u.x);
  }
  function l(c, u) {
    var h = a(c, 1), d = a(u, 1);
    return h !== d ? h - d : h === 0 ? u[1] - c[1] : h === 1 ? c[0] - u[0] : h === 2 ? c[1] - u[1] : u[0] - c[0];
  }
  return function(c) {
    var u = c, h = Pp(), d, f, p, m, g, v, y, x, S, _, E, T = {
      point: k,
      lineStart: V,
      lineEnd: M,
      polygonStart: L,
      polygonEnd: C
    };
    function k(w, P) {
      i(w, P) && u.point(w, P);
    }
    function N() {
      for (var w = 0, P = 0, U = f.length; P < U; ++P)
        for (var I = f[P], B = 1, j = I.length, Y = I[0], J, ft, z = Y[0], Z = Y[1]; B < j; ++B)
          J = z, ft = Z, Y = I[B], z = Y[0], Z = Y[1], ft <= r ? Z > r && (z - J) * (r - ft) > (Z - ft) * (e - J) && ++w : Z <= r && (z - J) * (r - ft) < (Z - ft) * (e - J) && --w;
      return w;
    }
    function L() {
      u = h, d = [], f = [], E = !0;
    }
    function C() {
      var w = N(), P = E && w, U = (d = tp(d)).length;
      (P || U) && (c.polygonStart(), P && (c.lineStart(), s(null, null, 1, c), c.lineEnd()), U && Up(d, o, w, s, c), c.polygonEnd()), u = c, d = f = p = null;
    }
    function V() {
      T.point = A, f && f.push(p = []), _ = !0, S = !1, y = x = NaN;
    }
    function M() {
      d && (A(m, g), v && S && h.rejoin(), d.push(h.result())), T.point = k, S && u.lineEnd();
    }
    function A(w, P) {
      var U = i(w, P);
      if (f && p.push([w, P]), _)
        m = w, g = P, v = U, _ = !1, U && (u.lineStart(), u.point(w, P));
      else if (U && S)
        u.point(w, P);
      else {
        var I = [y = Math.max(ds, Math.min(hi, y)), x = Math.max(ds, Math.min(hi, x))], B = [w = Math.max(ds, Math.min(hi, w)), P = Math.max(ds, Math.min(hi, P))];
        Vb(I, B, e, t, n, r) ? (S || (u.lineStart(), u.point(I[0], I[1])), u.point(B[0], B[1]), U || u.lineEnd(), E = !1) : U && (u.lineStart(), u.point(w, P), E = !1);
      }
      y = w, x = P, S = U;
    }
    return T;
  };
}
const ml = (e) => e;
var So = new Wn(), vl = new Wn(), Vp, Hp, yl, xl, Cn = {
  point: Me,
  lineStart: Me,
  lineEnd: Me,
  polygonStart: function() {
    Cn.lineStart = Fb, Cn.lineEnd = zb;
  },
  polygonEnd: function() {
    Cn.lineStart = Cn.lineEnd = Cn.point = Me, So.add(Et(vl)), vl = new Wn();
  },
  result: function() {
    var e = So / 2;
    return So = new Wn(), e;
  }
};
function Fb() {
  Cn.point = Gb;
}
function Gb(e, t) {
  Cn.point = Fp, Vp = yl = e, Hp = xl = t;
}
function Fp(e, t) {
  vl.add(xl * e - yl * t), yl = e, xl = t;
}
function zb() {
  Fp(Vp, Hp);
}
const oh = Cn;
var Pr = 1 / 0, Qs = Pr, Ni = -Pr, Js = Ni, jb = {
  point: Wb,
  lineStart: Me,
  lineEnd: Me,
  polygonStart: Me,
  polygonEnd: Me,
  result: function() {
    var e = [[Pr, Qs], [Ni, Js]];
    return Ni = Js = -(Qs = Pr = 1 / 0), e;
  }
};
function Wb(e, t) {
  e < Pr && (Pr = e), e > Ni && (Ni = e), t < Qs && (Qs = t), t > Js && (Js = t);
}
const ta = jb;
var bl = 0, wl = 0, di = 0, ea = 0, na = 0, Er = 0, _l = 0, El = 0, fi = 0, Gp, zp, qe, Ye, ke = {
  point: Kn,
  lineStart: lh,
  lineEnd: ch,
  polygonStart: function() {
    ke.lineStart = Xb, ke.lineEnd = Zb;
  },
  polygonEnd: function() {
    ke.point = Kn, ke.lineStart = lh, ke.lineEnd = ch;
  },
  result: function() {
    var e = fi ? [_l / fi, El / fi] : Er ? [ea / Er, na / Er] : di ? [bl / di, wl / di] : [NaN, NaN];
    return bl = wl = di = ea = na = Er = _l = El = fi = 0, e;
  }
};
function Kn(e, t) {
  bl += e, wl += t, ++di;
}
function lh() {
  ke.point = qb;
}
function qb(e, t) {
  ke.point = Yb, Kn(qe = e, Ye = t);
}
function Yb(e, t) {
  var n = e - qe, r = t - Ye, i = Ue(n * n + r * r);
  ea += i * (qe + e) / 2, na += i * (Ye + t) / 2, Er += i, Kn(qe = e, Ye = t);
}
function ch() {
  ke.point = Kn;
}
function Xb() {
  ke.point = Kb;
}
function Zb() {
  jp(Gp, zp);
}
function Kb(e, t) {
  ke.point = jp, Kn(Gp = qe = e, zp = Ye = t);
}
function jp(e, t) {
  var n = e - qe, r = t - Ye, i = Ue(n * n + r * r);
  ea += i * (qe + e) / 2, na += i * (Ye + t) / 2, Er += i, i = Ye * e - qe * t, _l += i * (qe + e), El += i * (Ye + t), fi += i * 3, Kn(qe = e, Ye = t);
}
const uh = ke;
function Wp(e) {
  this._context = e;
}
Wp.prototype = {
  _radius: 4.5,
  pointRadius: function(e) {
    return this._radius = e, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(e, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(e, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(e, t);
        break;
      }
      default: {
        this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, _e);
        break;
      }
    }
  },
  result: Me
};
var Sl = new Wn(), Oo, qp, Yp, pi, gi, ra = {
  point: Me,
  lineStart: function() {
    ra.point = Qb;
  },
  lineEnd: function() {
    Oo && Xp(qp, Yp), ra.point = Me;
  },
  polygonStart: function() {
    Oo = !0;
  },
  polygonEnd: function() {
    Oo = null;
  },
  result: function() {
    var e = +Sl;
    return Sl = new Wn(), e;
  }
};
function Qb(e, t) {
  ra.point = Xp, qp = pi = e, Yp = gi = t;
}
function Xp(e, t) {
  pi -= e, gi -= t, Sl.add(Ue(pi * pi + gi * gi)), pi = e, gi = t;
}
const hh = ra;
let dh, ia, fh, ph;
class gh {
  constructor(t) {
    this._append = t == null ? Zp : Jb(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, n) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${n}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${n}`;
        break;
      }
      default: {
        if (this._append`M${t},${n}`, this._radius !== fh || this._append !== ia) {
          const r = this._radius, i = this._;
          this._ = "", this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`, fh = r, ia = this._append, ph = this._, this._ = i;
        }
        this._ += ph;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
}
function Zp(e) {
  let t = 1;
  this._ += e[0];
  for (const n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function Jb(e) {
  const t = Math.floor(e);
  if (!(t >= 0))
    throw new RangeError(`invalid digits: ${e}`);
  if (t > 15)
    return Zp;
  if (t !== dh) {
    const n = 10 ** t;
    dh = t, ia = function(i) {
      let s = 1;
      this._ += i[0];
      for (const a = i.length; s < a; ++s)
        this._ += Math.round(arguments[s] * n) / n + i[s];
    };
  }
  return ia;
}
function tw(e, t) {
  let n = 3, r = 4.5, i, s;
  function a(o) {
    return o && (typeof r == "function" && s.pointRadius(+r.apply(this, arguments)), vr(o, i(s))), s.result();
  }
  return a.area = function(o) {
    return vr(o, i(oh)), oh.result();
  }, a.measure = function(o) {
    return vr(o, i(hh)), hh.result();
  }, a.bounds = function(o) {
    return vr(o, i(ta)), ta.result();
  }, a.centroid = function(o) {
    return vr(o, i(uh)), uh.result();
  }, a.projection = function(o) {
    return arguments.length ? (i = o == null ? (e = null, ml) : (e = o).stream, a) : e;
  }, a.context = function(o) {
    return arguments.length ? (s = o == null ? (t = null, new gh(n)) : new Wp(t = o), typeof r != "function" && s.pointRadius(r), a) : t;
  }, a.pointRadius = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : (s.pointRadius(+o), +o), a) : r;
  }, a.digits = function(o) {
    if (!arguments.length)
      return n;
    if (o == null)
      n = null;
    else {
      const l = Math.floor(o);
      if (!(l >= 0))
        throw new RangeError(`invalid digits: ${o}`);
      n = l;
    }
    return t === null && (s = new gh(n)), a;
  }, a.projection(e).digits(n).context(t);
}
function Sc(e) {
  return function(t) {
    var n = new Ol();
    for (var r in e)
      n[r] = e[r];
    return n.stream = t, n;
  };
}
function Ol() {
}
Ol.prototype = {
  constructor: Ol,
  point: function(e, t) {
    this.stream.point(e, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function Oc(e, t, n) {
  var r = e.clipExtent && e.clipExtent();
  return e.scale(150).translate([0, 0]), r != null && e.clipExtent(null), vr(n, e.stream(ta)), t(ta.result()), r != null && e.clipExtent(r), e;
}
function Kp(e, t, n) {
  return Oc(e, function(r) {
    var i = t[1][0] - t[0][0], s = t[1][1] - t[0][1], a = Math.min(i / (r[1][0] - r[0][0]), s / (r[1][1] - r[0][1])), o = +t[0][0] + (i - a * (r[1][0] + r[0][0])) / 2, l = +t[0][1] + (s - a * (r[1][1] + r[0][1])) / 2;
    e.scale(150 * a).translate([o, l]);
  }, n);
}
function ew(e, t, n) {
  return Kp(e, [[0, 0], t], n);
}
function nw(e, t, n) {
  return Oc(e, function(r) {
    var i = +t, s = i / (r[1][0] - r[0][0]), a = (i - s * (r[1][0] + r[0][0])) / 2, o = -s * r[0][1];
    e.scale(150 * s).translate([a, o]);
  }, n);
}
function rw(e, t, n) {
  return Oc(e, function(r) {
    var i = +t, s = i / (r[1][1] - r[0][1]), a = -s * r[0][0], o = (i - s * (r[1][1] + r[0][1])) / 2;
    e.scale(150 * s).translate([a, o]);
  }, n);
}
var mh = 16, iw = St(30 * Ht);
function vh(e, t) {
  return +t ? aw(e, t) : sw(e);
}
function sw(e) {
  return Sc({
    point: function(t, n) {
      t = e(t, n), this.stream.point(t[0], t[1]);
    }
  });
}
function aw(e, t) {
  function n(r, i, s, a, o, l, c, u, h, d, f, p, m, g) {
    var v = c - r, y = u - i, x = v * v + y * y;
    if (x > 4 * t && m--) {
      var S = a + d, _ = o + f, E = l + p, T = Ue(S * S + _ * _ + E * E), k = mn(E /= T), N = Et(Et(E) - 1) < _t || Et(s - h) < _t ? (s + h) / 2 : Zn(_, S), L = e(N, k), C = L[0], V = L[1], M = C - r, A = V - i, w = y * M - v * A;
      (w * w / x > t || Et((v * M + y * A) / x - 0.5) > 0.3 || a * d + o * f + l * p < iw) && (n(r, i, s, a, o, l, C, V, N, S /= T, _ /= T, E, m, g), g.point(C, V), n(C, V, N, S, _, E, c, u, h, d, f, p, m, g));
    }
  }
  return function(r) {
    var i, s, a, o, l, c, u, h, d, f, p, m, g = {
      point: v,
      lineStart: y,
      lineEnd: S,
      polygonStart: function() {
        r.polygonStart(), g.lineStart = _;
      },
      polygonEnd: function() {
        r.polygonEnd(), g.lineStart = y;
      }
    };
    function v(k, N) {
      k = e(k, N), r.point(k[0], k[1]);
    }
    function y() {
      h = NaN, g.point = x, r.lineStart();
    }
    function x(k, N) {
      var L = Nr([k, N]), C = e(k, N);
      n(h, d, u, f, p, m, h = C[0], d = C[1], u = k, f = L[0], p = L[1], m = L[2], mh, r), r.point(h, d);
    }
    function S() {
      g.point = v, r.lineEnd();
    }
    function _() {
      y(), g.point = E, g.lineEnd = T;
    }
    function E(k, N) {
      x(i = k, N), s = h, a = d, o = f, l = p, c = m, g.point = x;
    }
    function T() {
      n(h, d, u, f, p, m, s, a, i, o, l, c, mh, r), g.lineEnd = S, S();
    }
    return g;
  };
}
var ow = Sc({
  point: function(e, t) {
    this.stream.point(e * Ht, t * Ht);
  }
});
function lw(e) {
  return Sc({
    point: function(t, n) {
      var r = e(t, n);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function cw(e, t, n, r, i) {
  function s(a, o) {
    return a *= r, o *= i, [t + e * a, n - e * o];
  }
  return s.invert = function(a, o) {
    return [(a - t) / e * r, (n - o) / e * i];
  }, s;
}
function yh(e, t, n, r, i, s) {
  if (!s)
    return cw(e, t, n, r, i);
  var a = St(s), o = bt(s), l = a * e, c = o * e, u = a / e, h = o / e, d = (o * n - a * t) / e, f = (o * t + a * n) / e;
  function p(m, g) {
    return m *= r, g *= i, [l * m - c * g + t, n - c * m - l * g];
  }
  return p.invert = function(m, g) {
    return [r * (u * m - h * g + d), i * (f - h * m - u * g)];
  }, p;
}
function Ia(e) {
  return Qp(function() {
    return e;
  })();
}
function Qp(e) {
  var t, n = 150, r = 480, i = 250, s = 0, a = 0, o = 0, l = 0, c = 0, u, h = 0, d = 1, f = 1, p = null, m = ah, g = null, v, y, x, S = ml, _ = 0.5, E, T, k, N, L;
  function C(w) {
    return k(w[0] * Ht, w[1] * Ht);
  }
  function V(w) {
    return w = k.invert(w[0], w[1]), w && [w[0] * le, w[1] * le];
  }
  C.stream = function(w) {
    return N && L === w ? N : N = ow(lw(u)(m(E(S(L = w)))));
  }, C.preclip = function(w) {
    return arguments.length ? (m = w, p = void 0, A()) : m;
  }, C.postclip = function(w) {
    return arguments.length ? (S = w, g = v = y = x = null, A()) : S;
  }, C.clipAngle = function(w) {
    return arguments.length ? (m = +w ? Bb(p = w * Ht) : (p = null, ah), A()) : p * le;
  }, C.clipExtent = function(w) {
    return arguments.length ? (S = w == null ? (g = v = y = x = null, ml) : Hb(g = +w[0][0], v = +w[0][1], y = +w[1][0], x = +w[1][1]), A()) : g == null ? null : [[g, v], [y, x]];
  }, C.scale = function(w) {
    return arguments.length ? (n = +w, M()) : n;
  }, C.translate = function(w) {
    return arguments.length ? (r = +w[0], i = +w[1], M()) : [r, i];
  }, C.center = function(w) {
    return arguments.length ? (s = w[0] % 360 * Ht, a = w[1] % 360 * Ht, M()) : [s * le, a * le];
  }, C.rotate = function(w) {
    return arguments.length ? (o = w[0] % 360 * Ht, l = w[1] % 360 * Ht, c = w.length > 2 ? w[2] % 360 * Ht : 0, M()) : [o * le, l * le, c * le];
  }, C.angle = function(w) {
    return arguments.length ? (h = w % 360 * Ht, M()) : h * le;
  }, C.reflectX = function(w) {
    return arguments.length ? (d = w ? -1 : 1, M()) : d < 0;
  }, C.reflectY = function(w) {
    return arguments.length ? (f = w ? -1 : 1, M()) : f < 0;
  }, C.precision = function(w) {
    return arguments.length ? (E = vh(T, _ = w * w), A()) : Ue(_);
  }, C.fitExtent = function(w, P) {
    return Kp(C, w, P);
  }, C.fitSize = function(w, P) {
    return ew(C, w, P);
  }, C.fitWidth = function(w, P) {
    return nw(C, w, P);
  }, C.fitHeight = function(w, P) {
    return rw(C, w, P);
  };
  function M() {
    var w = yh(n, 0, 0, d, f, h).apply(null, t(s, a)), P = yh(n, r - w[0], i - w[1], d, f, h);
    return u = Np(o, l, c), T = pl(t, P), k = pl(u, T), E = vh(T, _), A();
  }
  function A() {
    return N = L = null, C;
  }
  return function() {
    return t = e.apply(this, arguments), C.invert = t.invert && V, M();
  };
}
function Jp(e) {
  var t = 0, n = ht / 3, r = Qp(e), i = r(t, n);
  return i.parallels = function(s) {
    return arguments.length ? r(t = s[0] * Ht, n = s[1] * Ht) : [t * le, n * le];
  }, i;
}
function uw(e) {
  var t = St(e);
  function n(r, i) {
    return [r * t, bt(i) / t];
  }
  return n.invert = function(r, i) {
    return [r / t, mn(i * t)];
  }, n;
}
function hw(e, t) {
  var n = bt(e), r = (n + bt(t)) / 2;
  if (Et(r) < _t)
    return uw(e);
  var i = 1 + n * (2 * r - n), s = Ue(i) / r;
  function a(o, l) {
    var c = Ue(i - 2 * r * bt(l)) / r;
    return [c * bt(o *= r), s - c * St(o)];
  }
  return a.invert = function(o, l) {
    var c = s - l, u = Zn(o, Et(c)) * $n(c);
    return c * r < 0 && (u -= ht * $n(o) * $n(c)), [u / r, mn((i - (o * o + c * c) * r * r) / (2 * r))];
  }, a;
}
function tg() {
  return Jp(hw).scale(155.424).center([0, 33.6442]);
}
function dw() {
  return tg().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function Tc(e, t) {
  return [e, Cb($b((fe + t) / 2))];
}
Tc.invert = function(e, t) {
  return [e, 2 * Ip(Mb(t)) - fe];
};
function fw() {
  return pw(Tc).scale(961 / _e);
}
function pw(e) {
  var t = Ia(e), n = t.center, r = t.scale, i = t.translate, s = t.clipExtent, a = null, o, l, c;
  t.scale = function(h) {
    return arguments.length ? (r(h), u()) : r();
  }, t.translate = function(h) {
    return arguments.length ? (i(h), u()) : i();
  }, t.center = function(h) {
    return arguments.length ? (n(h), u()) : n();
  }, t.clipExtent = function(h) {
    return arguments.length ? (h == null ? a = o = l = c = null : (a = +h[0][0], o = +h[0][1], l = +h[1][0], c = +h[1][1]), u()) : a == null ? null : [[a, o], [l, c]];
  };
  function u() {
    var h = ht * r(), d = t(Lb(t.rotate()).invert([0, 0]));
    return s(a == null ? [[d[0] - h, d[1] - h], [d[0] + h, d[1] + h]] : e === Tc ? [[Math.max(d[0] - h, a), o], [Math.min(d[0] + h, l), c]] : [[a, Math.max(d[1] - h, o)], [l, Math.min(d[1] + h, c)]]);
  }
  return u();
}
function sa(e, t) {
  return [e, t];
}
sa.invert = sa;
function gw() {
  return Ia(sa).scale(152.63);
}
function mw(e, t) {
  var n = St(e), r = e === t ? bt(e) : (n - St(t)) / (t - e), i = n / r + e;
  if (Et(r) < _t)
    return sa;
  function s(a, o) {
    var l = i - o, c = r * a;
    return [l * bt(c), i - l * St(c)];
  }
  return s.invert = function(a, o) {
    var l = i - o, c = Zn(a, Et(l)) * $n(l);
    return l * r < 0 && (c -= ht * $n(a) * $n(l)), [c / r, i - $n(r) * Ue(a * a + l * l)];
  }, s;
}
function vw() {
  return Jp(mw).scale(131.154).center([0, 13.9389]);
}
var Si = 1.340264, Oi = -0.081106, Ti = 893e-6, Mi = 3796e-6, aa = Ue(3) / 2, yw = 12;
function eg(e, t) {
  var n = mn(aa * bt(t)), r = n * n, i = r * r * r;
  return [
    e * St(n) / (aa * (Si + 3 * Oi * r + i * (7 * Ti + 9 * Mi * r))),
    n * (Si + Oi * r + i * (Ti + Mi * r))
  ];
}
eg.invert = function(e, t) {
  for (var n = t, r = n * n, i = r * r * r, s = 0, a, o, l; s < yw && (o = n * (Si + Oi * r + i * (Ti + Mi * r)) - t, l = Si + 3 * Oi * r + i * (7 * Ti + 9 * Mi * r), n -= a = o / l, r = n * n, i = r * r * r, !(Et(a) < Rp)); ++s)
    ;
  return [
    aa * e * (Si + 3 * Oi * r + i * (7 * Ti + 9 * Mi * r)) / St(n),
    mn(bt(n) / aa)
  ];
};
function xw() {
  return Ia(eg).scale(177.158);
}
function ng(e, t) {
  var n = t * t, r = n * n;
  return [
    e * (0.8707 - 0.131979 * n + r * (-0.013791 + r * (3971e-6 * n - 1529e-6 * r))),
    t * (1.007226 + n * (0.015085 + r * (-0.044475 + 0.028874 * n - 5916e-6 * r)))
  ];
}
ng.invert = function(e, t) {
  var n = t, r = 25, i;
  do {
    var s = n * n, a = s * s;
    n -= i = (n * (1.007226 + s * (0.015085 + a * (-0.044475 + 0.028874 * s - 5916e-6 * a))) - t) / (1.007226 + s * (0.015085 * 3 + a * (-0.044475 * 7 + 0.028874 * 9 * s - 5916e-6 * 11 * a)));
  } while (Et(i) > _t && --r > 0);
  return [
    e / (0.8707 + (s = n * n) * (-0.131979 + s * (-0.013791 + s * s * s * (3971e-6 - 1529e-6 * s)))),
    n
  ];
};
function bw() {
  return Ia(ng).scale(175.295);
}
function ww(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function _w(e) {
  return e.reduce(Ew, 0) / e.length;
}
function Ew(e, t) {
  return e + t.x;
}
function Sw(e) {
  return 1 + e.reduce(Ow, 0);
}
function Ow(e, t) {
  return Math.max(e, t.y);
}
function Tw(e) {
  for (var t; t = e.children; )
    e = t[0];
  return e;
}
function Mw(e) {
  for (var t; t = e.children; )
    e = t[t.length - 1];
  return e;
}
function Cw() {
  var e = ww, t = 1, n = 1, r = !1;
  function i(s) {
    var a, o = 0;
    s.eachAfter(function(d) {
      var f = d.children;
      f ? (d.x = _w(f), d.y = Sw(f)) : (d.x = a ? o += e(d, a) : 0, d.y = 0, a = d);
    });
    var l = Tw(s), c = Mw(s), u = l.x - e(l, c) / 2, h = c.x + e(c, l) / 2;
    return s.eachAfter(r ? function(d) {
      d.x = (d.x - s.x) * t, d.y = (s.y - d.y) * n;
    } : function(d) {
      d.x = (d.x - u) / (h - u) * t, d.y = (1 - (s.y ? d.y / s.y : 1)) * n;
    });
  }
  return i.separation = function(s) {
    return arguments.length ? (e = s, i) : e;
  }, i.size = function(s) {
    return arguments.length ? (r = !1, t = +s[0], n = +s[1], i) : r ? null : [t, n];
  }, i.nodeSize = function(s) {
    return arguments.length ? (r = !0, t = +s[0], n = +s[1], i) : r ? [t, n] : null;
  }, i;
}
function $w(e) {
  var t = 0, n = e.children, r = n && n.length;
  if (!r)
    t = 1;
  else
    for (; --r >= 0; )
      t += n[r].value;
  e.value = t;
}
function Aw() {
  return this.eachAfter($w);
}
function Lw(e, t) {
  let n = -1;
  for (const r of this)
    e.call(t, r, ++n, this);
  return this;
}
function Dw(e, t) {
  for (var n = this, r = [n], i, s, a = -1; n = r.pop(); )
    if (e.call(t, n, ++a, this), i = n.children)
      for (s = i.length - 1; s >= 0; --s)
        r.push(i[s]);
  return this;
}
function kw(e, t) {
  for (var n = this, r = [n], i = [], s, a, o, l = -1; n = r.pop(); )
    if (i.push(n), s = n.children)
      for (a = 0, o = s.length; a < o; ++a)
        r.push(s[a]);
  for (; n = i.pop(); )
    e.call(t, n, ++l, this);
  return this;
}
function Rw(e, t) {
  let n = -1;
  for (const r of this)
    if (e.call(t, r, ++n, this))
      return r;
}
function Iw(e) {
  return this.eachAfter(function(t) {
    for (var n = +e(t.data) || 0, r = t.children, i = r && r.length; --i >= 0; )
      n += r[i].value;
    t.value = n;
  });
}
function Nw(e) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(e);
  });
}
function Pw(e) {
  for (var t = this, n = Uw(t, e), r = [t]; t !== n; )
    t = t.parent, r.push(t);
  for (var i = r.length; e !== n; )
    r.splice(i, 0, e), e = e.parent;
  return r;
}
function Uw(e, t) {
  if (e === t)
    return e;
  var n = e.ancestors(), r = t.ancestors(), i = null;
  for (e = n.pop(), t = r.pop(); e === t; )
    i = e, e = n.pop(), t = r.pop();
  return i;
}
function Bw() {
  for (var e = this, t = [e]; e = e.parent; )
    t.push(e);
  return t;
}
function Vw() {
  return Array.from(this);
}
function Hw() {
  var e = [];
  return this.eachBefore(function(t) {
    t.children || e.push(t);
  }), e;
}
function Fw() {
  var e = this, t = [];
  return e.each(function(n) {
    n !== e && t.push({ source: n.parent, target: n });
  }), t;
}
function* Gw() {
  var e = this, t, n = [e], r, i, s;
  do
    for (t = n.reverse(), n = []; e = t.pop(); )
      if (yield e, r = e.children)
        for (i = 0, s = r.length; i < s; ++i)
          n.push(r[i]);
  while (n.length);
}
function Yi(e, t) {
  e instanceof Map ? (e = [void 0, e], t === void 0 && (t = Ww)) : t === void 0 && (t = jw);
  for (var n = new Pi(e), r, i = [n], s, a, o, l; r = i.pop(); )
    if ((a = t(r.data)) && (l = (a = Array.from(a)).length))
      for (r.children = a, o = l - 1; o >= 0; --o)
        i.push(s = a[o] = new Pi(a[o])), s.parent = r, s.depth = r.depth + 1;
  return n.eachBefore(Yw);
}
function zw() {
  return Yi(this).eachBefore(qw);
}
function jw(e) {
  return e.children;
}
function Ww(e) {
  return Array.isArray(e) ? e[1] : null;
}
function qw(e) {
  e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;
}
function Yw(e) {
  var t = 0;
  do
    e.height = t;
  while ((e = e.parent) && e.height < ++t);
}
function Pi(e) {
  this.data = e, this.depth = this.height = 0, this.parent = null;
}
Pi.prototype = Yi.prototype = {
  constructor: Pi,
  count: Aw,
  each: Lw,
  eachAfter: kw,
  eachBefore: Dw,
  find: Rw,
  sum: Iw,
  sort: Nw,
  path: Pw,
  ancestors: Bw,
  descendants: Vw,
  leaves: Hw,
  links: Fw,
  copy: zw,
  [Symbol.iterator]: Gw
};
function Xw(e) {
  return e == null ? null : rg(e);
}
function rg(e) {
  if (typeof e != "function")
    throw new Error();
  return e;
}
function Fn() {
  return 0;
}
function yr(e) {
  return function() {
    return e;
  };
}
const Zw = 1664525, Kw = 1013904223, xh = 4294967296;
function Qw() {
  let e = 1;
  return () => (e = (Zw * e + Kw) % xh) / xh;
}
function Jw(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function t_(e, t) {
  let n = e.length, r, i;
  for (; n; )
    i = t() * n-- | 0, r = e[n], e[n] = e[i], e[i] = r;
  return e;
}
function e_(e, t) {
  for (var n = 0, r = (e = t_(Array.from(e), t)).length, i = [], s, a; n < r; )
    s = e[n], a && ig(a, s) ? ++n : (a = r_(i = n_(i, s)), n = 0);
  return a;
}
function n_(e, t) {
  var n, r;
  if (To(t, e))
    return [t];
  for (n = 0; n < e.length; ++n)
    if (fs(t, e[n]) && To(mi(e[n], t), e))
      return [e[n], t];
  for (n = 0; n < e.length - 1; ++n)
    for (r = n + 1; r < e.length; ++r)
      if (fs(mi(e[n], e[r]), t) && fs(mi(e[n], t), e[r]) && fs(mi(e[r], t), e[n]) && To(sg(e[n], e[r], t), e))
        return [e[n], e[r], t];
  throw new Error();
}
function fs(e, t) {
  var n = e.r - t.r, r = t.x - e.x, i = t.y - e.y;
  return n < 0 || n * n < r * r + i * i;
}
function ig(e, t) {
  var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9, r = t.x - e.x, i = t.y - e.y;
  return n > 0 && n * n > r * r + i * i;
}
function To(e, t) {
  for (var n = 0; n < t.length; ++n)
    if (!ig(e, t[n]))
      return !1;
  return !0;
}
function r_(e) {
  switch (e.length) {
    case 1:
      return i_(e[0]);
    case 2:
      return mi(e[0], e[1]);
    case 3:
      return sg(e[0], e[1], e[2]);
  }
}
function i_(e) {
  return {
    x: e.x,
    y: e.y,
    r: e.r
  };
}
function mi(e, t) {
  var n = e.x, r = e.y, i = e.r, s = t.x, a = t.y, o = t.r, l = s - n, c = a - r, u = o - i, h = Math.sqrt(l * l + c * c);
  return {
    x: (n + s + l / h * u) / 2,
    y: (r + a + c / h * u) / 2,
    r: (h + i + o) / 2
  };
}
function sg(e, t, n) {
  var r = e.x, i = e.y, s = e.r, a = t.x, o = t.y, l = t.r, c = n.x, u = n.y, h = n.r, d = r - a, f = r - c, p = i - o, m = i - u, g = l - s, v = h - s, y = r * r + i * i - s * s, x = y - a * a - o * o + l * l, S = y - c * c - u * u + h * h, _ = f * p - d * m, E = (p * S - m * x) / (_ * 2) - r, T = (m * g - p * v) / _, k = (f * x - d * S) / (_ * 2) - i, N = (d * v - f * g) / _, L = T * T + N * N - 1, C = 2 * (s + E * T + k * N), V = E * E + k * k - s * s, M = -(Math.abs(L) > 1e-6 ? (C + Math.sqrt(C * C - 4 * L * V)) / (2 * L) : V / C);
  return {
    x: r + E + T * M,
    y: i + k + N * M,
    r: M
  };
}
function bh(e, t, n) {
  var r = e.x - t.x, i, s, a = e.y - t.y, o, l, c = r * r + a * a;
  c ? (s = t.r + n.r, s *= s, l = e.r + n.r, l *= l, s > l ? (i = (c + l - s) / (2 * c), o = Math.sqrt(Math.max(0, l / c - i * i)), n.x = e.x - i * r - o * a, n.y = e.y - i * a + o * r) : (i = (c + s - l) / (2 * c), o = Math.sqrt(Math.max(0, s / c - i * i)), n.x = t.x + i * r - o * a, n.y = t.y + i * a + o * r)) : (n.x = t.x + n.r, n.y = t.y);
}
function wh(e, t) {
  var n = e.r + t.r - 1e-6, r = t.x - e.x, i = t.y - e.y;
  return n > 0 && n * n > r * r + i * i;
}
function _h(e) {
  var t = e._, n = e.next._, r = t.r + n.r, i = (t.x * n.r + n.x * t.r) / r, s = (t.y * n.r + n.y * t.r) / r;
  return i * i + s * s;
}
function ps(e) {
  this._ = e, this.next = null, this.previous = null;
}
function s_(e, t) {
  if (!(s = (e = Jw(e)).length))
    return 0;
  var n, r, i, s, a, o, l, c, u, h, d;
  if (n = e[0], n.x = 0, n.y = 0, !(s > 1))
    return n.r;
  if (r = e[1], n.x = -r.r, r.x = n.r, r.y = 0, !(s > 2))
    return n.r + r.r;
  bh(r, n, i = e[2]), n = new ps(n), r = new ps(r), i = new ps(i), n.next = i.previous = r, r.next = n.previous = i, i.next = r.previous = n;
  t:
    for (l = 3; l < s; ++l) {
      bh(n._, r._, i = e[l]), i = new ps(i), c = r.next, u = n.previous, h = r._.r, d = n._.r;
      do
        if (h <= d) {
          if (wh(c._, i._)) {
            r = c, n.next = r, r.previous = n, --l;
            continue t;
          }
          h += c._.r, c = c.next;
        } else {
          if (wh(u._, i._)) {
            n = u, n.next = r, r.previous = n, --l;
            continue t;
          }
          d += u._.r, u = u.previous;
        }
      while (c !== u.next);
      for (i.previous = n, i.next = r, n.next = r.previous = r = i, a = _h(n); (i = i.next) !== r; )
        (o = _h(i)) < a && (n = i, a = o);
      r = n.next;
    }
  for (n = [r._], i = r; (i = i.next) !== r; )
    n.push(i._);
  for (i = e_(n, t), l = 0; l < s; ++l)
    n = e[l], n.x -= i.x, n.y -= i.y;
  return i.r;
}
function a_(e) {
  return Math.sqrt(e.value);
}
function o_() {
  var e = null, t = 1, n = 1, r = Fn;
  function i(s) {
    const a = Qw();
    return s.x = t / 2, s.y = n / 2, e ? s.eachBefore(Eh(e)).eachAfter(Mo(r, 0.5, a)).eachBefore(Sh(1)) : s.eachBefore(Eh(a_)).eachAfter(Mo(Fn, 1, a)).eachAfter(Mo(r, s.r / Math.min(t, n), a)).eachBefore(Sh(Math.min(t, n) / (2 * s.r))), s;
  }
  return i.radius = function(s) {
    return arguments.length ? (e = Xw(s), i) : e;
  }, i.size = function(s) {
    return arguments.length ? (t = +s[0], n = +s[1], i) : [t, n];
  }, i.padding = function(s) {
    return arguments.length ? (r = typeof s == "function" ? s : yr(+s), i) : r;
  }, i;
}
function Eh(e) {
  return function(t) {
    t.children || (t.r = Math.max(0, +e(t) || 0));
  };
}
function Mo(e, t, n) {
  return function(r) {
    if (i = r.children) {
      var i, s, a = i.length, o = e(r) * t || 0, l;
      if (o)
        for (s = 0; s < a; ++s)
          i[s].r += o;
      if (l = s_(i, n), o)
        for (s = 0; s < a; ++s)
          i[s].r -= o;
      r.r = l + o;
    }
  };
}
function Sh(e) {
  return function(t) {
    var n = t.parent;
    t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y);
  };
}
function l_(e) {
  e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1);
}
function c_(e, t, n, r, i) {
  for (var s = e.children, a, o = -1, l = s.length, c = e.value && (r - t) / e.value; ++o < l; )
    a = s[o], a.y0 = n, a.y1 = i, a.x0 = t, a.x1 = t += a.value * c;
}
function u_(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function Co(e) {
  var t = e.children;
  return t ? t[0] : e.t;
}
function $o(e) {
  var t = e.children;
  return t ? t[t.length - 1] : e.t;
}
function h_(e, t, n) {
  var r = n / (t.i - e.i);
  t.c -= r, t.s += n, e.c += r, t.z += n, t.m += n;
}
function d_(e) {
  for (var t = 0, n = 0, r = e.children, i = r.length, s; --i >= 0; )
    s = r[i], s.z += t, s.m += t, t += s.s + (n += s.c);
}
function f_(e, t, n) {
  return e.a.parent === t.parent ? e.a : n;
}
function Ls(e, t) {
  this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
}
Ls.prototype = Object.create(Pi.prototype);
function p_(e) {
  for (var t = new Ls(e, 0), n, r = [t], i, s, a, o; n = r.pop(); )
    if (s = n._.children)
      for (n.children = new Array(o = s.length), a = o - 1; a >= 0; --a)
        r.push(i = n.children[a] = new Ls(s[a], a)), i.parent = n;
  return (t.parent = new Ls(null, 0)).children = [t], t;
}
function g_() {
  var e = u_, t = 1, n = 1, r = null;
  function i(c) {
    var u = p_(c);
    if (u.eachAfter(s), u.parent.m = -u.z, u.eachBefore(a), r)
      c.eachBefore(l);
    else {
      var h = c, d = c, f = c;
      c.eachBefore(function(y) {
        y.x < h.x && (h = y), y.x > d.x && (d = y), y.depth > f.depth && (f = y);
      });
      var p = h === d ? 1 : e(h, d) / 2, m = p - h.x, g = t / (d.x + p + m), v = n / (f.depth || 1);
      c.eachBefore(function(y) {
        y.x = (y.x + m) * g, y.y = y.depth * v;
      });
    }
    return c;
  }
  function s(c) {
    var u = c.children, h = c.parent.children, d = c.i ? h[c.i - 1] : null;
    if (u) {
      d_(c);
      var f = (u[0].z + u[u.length - 1].z) / 2;
      d ? (c.z = d.z + e(c._, d._), c.m = c.z - f) : c.z = f;
    } else
      d && (c.z = d.z + e(c._, d._));
    c.parent.A = o(c, d, c.parent.A || h[0]);
  }
  function a(c) {
    c._.x = c.z + c.parent.m, c.m += c.parent.m;
  }
  function o(c, u, h) {
    if (u) {
      for (var d = c, f = c, p = u, m = d.parent.children[0], g = d.m, v = f.m, y = p.m, x = m.m, S; p = $o(p), d = Co(d), p && d; )
        m = Co(m), f = $o(f), f.a = c, S = p.z + y - d.z - g + e(p._, d._), S > 0 && (h_(f_(p, c, h), c, S), g += S, v += S), y += p.m, g += d.m, x += m.m, v += f.m;
      p && !$o(f) && (f.t = p, f.m += y - v), d && !Co(m) && (m.t = d, m.m += g - x, h = c);
    }
    return h;
  }
  function l(c) {
    c.x *= t, c.y = c.depth * n;
  }
  return i.separation = function(c) {
    return arguments.length ? (e = c, i) : e;
  }, i.size = function(c) {
    return arguments.length ? (r = !1, t = +c[0], n = +c[1], i) : r ? null : [t, n];
  }, i.nodeSize = function(c) {
    return arguments.length ? (r = !0, t = +c[0], n = +c[1], i) : r ? [t, n] : null;
  }, i;
}
function m_(e, t, n, r, i) {
  for (var s = e.children, a, o = -1, l = s.length, c = e.value && (i - n) / e.value; ++o < l; )
    a = s[o], a.x0 = t, a.x1 = r, a.y0 = n, a.y1 = n += a.value * c;
}
var v_ = (1 + Math.sqrt(5)) / 2;
function y_(e, t, n, r, i, s) {
  for (var a = [], o = t.children, l, c, u = 0, h = 0, d = o.length, f, p, m = t.value, g, v, y, x, S, _, E; u < d; ) {
    f = i - n, p = s - r;
    do
      g = o[h++].value;
    while (!g && h < d);
    for (v = y = g, _ = Math.max(p / f, f / p) / (m * e), E = g * g * _, S = Math.max(y / E, E / v); h < d; ++h) {
      if (g += c = o[h].value, c < v && (v = c), c > y && (y = c), E = g * g * _, x = Math.max(y / E, E / v), x > S) {
        g -= c;
        break;
      }
      S = x;
    }
    a.push(l = { value: g, dice: f < p, children: o.slice(u, h) }), l.dice ? c_(l, n, r, i, m ? r += p * g / m : s) : m_(l, n, r, m ? n += f * g / m : i, s), m -= g, u = h;
  }
  return a;
}
const x_ = function e(t) {
  function n(r, i, s, a, o) {
    y_(t, r, i, s, a, o);
  }
  return n.ratio = function(r) {
    return e((r = +r) > 1 ? r : 1);
  }, n;
}(v_);
function b_() {
  var e = x_, t = !1, n = 1, r = 1, i = [0], s = Fn, a = Fn, o = Fn, l = Fn, c = Fn;
  function u(d) {
    return d.x0 = d.y0 = 0, d.x1 = n, d.y1 = r, d.eachBefore(h), i = [0], t && d.eachBefore(l_), d;
  }
  function h(d) {
    var f = i[d.depth], p = d.x0 + f, m = d.y0 + f, g = d.x1 - f, v = d.y1 - f;
    g < p && (p = g = (p + g) / 2), v < m && (m = v = (m + v) / 2), d.x0 = p, d.y0 = m, d.x1 = g, d.y1 = v, d.children && (f = i[d.depth + 1] = s(d) / 2, p += c(d) - f, m += a(d) - f, g -= o(d) - f, v -= l(d) - f, g < p && (p = g = (p + g) / 2), v < m && (m = v = (m + v) / 2), e(d, p, m, g, v));
  }
  return u.round = function(d) {
    return arguments.length ? (t = !!d, u) : t;
  }, u.size = function(d) {
    return arguments.length ? (n = +d[0], r = +d[1], u) : [n, r];
  }, u.tile = function(d) {
    return arguments.length ? (e = rg(d), u) : e;
  }, u.padding = function(d) {
    return arguments.length ? u.paddingInner(d).paddingOuter(d) : u.paddingInner();
  }, u.paddingInner = function(d) {
    return arguments.length ? (s = typeof d == "function" ? d : yr(+d), u) : s;
  }, u.paddingOuter = function(d) {
    return arguments.length ? u.paddingTop(d).paddingRight(d).paddingBottom(d).paddingLeft(d) : u.paddingTop();
  }, u.paddingTop = function(d) {
    return arguments.length ? (a = typeof d == "function" ? d : yr(+d), u) : a;
  }, u.paddingRight = function(d) {
    return arguments.length ? (o = typeof d == "function" ? d : yr(+d), u) : o;
  }, u.paddingBottom = function(d) {
    return arguments.length ? (l = typeof d == "function" ? d : yr(+d), u) : l;
  }, u.paddingLeft = function(d) {
    return arguments.length ? (c = typeof d == "function" ? d : yr(+d), u) : c;
  }, u;
}
function qr(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
const Oh = Symbol("implicit");
function Na() {
  var e = new _u(), t = [], n = [], r = Oh;
  function i(s) {
    let a = e.get(s);
    if (a === void 0) {
      if (r !== Oh)
        return r;
      e.set(s, a = t.push(s) - 1);
    }
    return n[a % n.length];
  }
  return i.domain = function(s) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new _u();
    for (const a of s)
      e.has(a) || e.set(a, t.push(a) - 1);
    return i;
  }, i.range = function(s) {
    return arguments.length ? (n = Array.from(s), i) : n.slice();
  }, i.unknown = function(s) {
    return arguments.length ? (r = s, i) : r;
  }, i.copy = function() {
    return Na(t, n).unknown(r);
  }, qr.apply(i, arguments), i;
}
function Xi() {
  var e = Na().unknown(void 0), t = e.domain, n = e.range, r = 0, i = 1, s, a, o = !1, l = 0, c = 0, u = 0.5;
  delete e.unknown;
  function h() {
    var d = t().length, f = i < r, p = f ? i : r, m = f ? r : i;
    s = (m - p) / Math.max(1, d - l + c * 2), o && (s = Math.floor(s)), p += (m - p - s * (d - l)) * u, a = s * (1 - l), o && (p = Math.round(p), a = Math.round(a));
    var g = $0(d).map(function(v) {
      return p + s * v;
    });
    return n(f ? g.reverse() : g);
  }
  return e.domain = function(d) {
    return arguments.length ? (t(d), h()) : t();
  }, e.range = function(d) {
    return arguments.length ? ([r, i] = d, r = +r, i = +i, h()) : [r, i];
  }, e.rangeRound = function(d) {
    return [r, i] = d, r = +r, i = +i, o = !0, h();
  }, e.bandwidth = function() {
    return a;
  }, e.step = function() {
    return s;
  }, e.round = function(d) {
    return arguments.length ? (o = !!d, h()) : o;
  }, e.padding = function(d) {
    return arguments.length ? (l = Math.min(1, c = +d), h()) : l;
  }, e.paddingInner = function(d) {
    return arguments.length ? (l = Math.min(1, d), h()) : l;
  }, e.paddingOuter = function(d) {
    return arguments.length ? (c = +d, h()) : c;
  }, e.align = function(d) {
    return arguments.length ? (u = Math.max(0, Math.min(1, d)), h()) : u;
  }, e.copy = function() {
    return Xi(t(), [r, i]).round(o).paddingInner(l).paddingOuter(c).align(u);
  }, qr.apply(h(), arguments);
}
function w_(e) {
  return function() {
    return e;
  };
}
function __(e) {
  return +e;
}
var Th = [0, 1];
function Sr(e) {
  return e;
}
function Tl(e, t) {
  return (t -= e = +e) ? function(n) {
    return (n - e) / t;
  } : w_(isNaN(t) ? NaN : 0.5);
}
function E_(e, t) {
  var n;
  return e > t && (n = e, e = t, t = n), function(r) {
    return Math.max(e, Math.min(t, r));
  };
}
function S_(e, t, n) {
  var r = e[0], i = e[1], s = t[0], a = t[1];
  return i < r ? (r = Tl(i, r), s = n(a, s)) : (r = Tl(r, i), s = n(s, a)), function(o) {
    return s(r(o));
  };
}
function O_(e, t, n) {
  var r = Math.min(e.length, t.length) - 1, i = new Array(r), s = new Array(r), a = -1;
  for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < r; )
    i[a] = Tl(e[a], e[a + 1]), s[a] = n(t[a], t[a + 1]);
  return function(o) {
    var l = uc(e, o, 1, r) - 1;
    return s[l](i[l](o));
  };
}
function Mc(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function ag() {
  var e = Th, t = Th, n = qi, r, i, s, a = Sr, o, l, c;
  function u() {
    var d = Math.min(e.length, t.length);
    return a !== Sr && (a = E_(e[0], e[d - 1])), o = d > 2 ? O_ : S_, l = c = null, h;
  }
  function h(d) {
    return d == null || isNaN(d = +d) ? s : (l || (l = o(e.map(r), t, n)))(r(a(d)));
  }
  return h.invert = function(d) {
    return a(i((c || (c = o(t, e.map(r), xe)))(d)));
  }, h.domain = function(d) {
    return arguments.length ? (e = Array.from(d, __), u()) : e.slice();
  }, h.range = function(d) {
    return arguments.length ? (t = Array.from(d), u()) : t.slice();
  }, h.rangeRound = function(d) {
    return t = Array.from(d), n = yp, u();
  }, h.clamp = function(d) {
    return arguments.length ? (a = d ? !0 : Sr, u()) : a !== Sr;
  }, h.interpolate = function(d) {
    return arguments.length ? (n = d, u()) : n;
  }, h.unknown = function(d) {
    return arguments.length ? (s = d, h) : s;
  }, function(d, f) {
    return r = d, i = f, u();
  };
}
function og() {
  return ag()(Sr, Sr);
}
function T_(e, t, n, r) {
  var i = Ko(e, t, n), s;
  switch (r = Ii(r ?? ",f"), r.type) {
    case "s": {
      var a = Math.max(Math.abs(e), Math.abs(t));
      return r.precision == null && !isNaN(s = Ob(i, a)) && (r.precision = s), kp(r, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      r.precision == null && !isNaN(s = Tb(i, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = s - (r.type === "e"));
      break;
    }
    case "f":
    case "%": {
      r.precision == null && !isNaN(s = Sb(i)) && (r.precision = s - (r.type === "%") * 2);
      break;
    }
  }
  return Ec(r);
}
function lg(e) {
  var t = e.domain;
  return e.ticks = function(n) {
    var r = t();
    return Vs(r[0], r[r.length - 1], n ?? 10);
  }, e.tickFormat = function(n, r) {
    var i = t();
    return T_(i[0], i[i.length - 1], n ?? 10, r);
  }, e.nice = function(n) {
    n == null && (n = 10);
    var r = t(), i = 0, s = r.length - 1, a = r[i], o = r[s], l, c, u = 10;
    for (o < a && (c = a, a = o, o = c, c = i, i = s, s = c); u-- > 0; ) {
      if (c = Dr(a, o, n), c === l)
        return r[i] = a, r[s] = o, t(r);
      if (c > 0)
        a = Math.floor(a / c) * c, o = Math.ceil(o / c) * c;
      else if (c < 0)
        a = Math.ceil(a * c) / c, o = Math.floor(o * c) / c;
      else
        break;
      l = c;
    }
    return e;
  }, e;
}
function Be() {
  var e = og();
  return e.copy = function() {
    return Mc(e, Be());
  }, qr.apply(e, arguments), lg(e);
}
function cg(e, t) {
  e = e.slice();
  var n = 0, r = e.length - 1, i = e[n], s = e[r], a;
  return s < i && (a = n, n = r, r = a, a = i, i = s, s = a), e[n] = t.floor(i), e[r] = t.ceil(s), e;
}
function Mh(e) {
  return Math.log(e);
}
function Ch(e) {
  return Math.exp(e);
}
function M_(e) {
  return -Math.log(-e);
}
function C_(e) {
  return -Math.exp(-e);
}
function $_(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function A_(e) {
  return e === 10 ? $_ : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function L_(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function $h(e) {
  return (t, n) => -e(-t, n);
}
function D_(e) {
  const t = e(Mh, Ch), n = t.domain;
  let r = 10, i, s;
  function a() {
    return i = L_(r), s = A_(r), n()[0] < 0 ? (i = $h(i), s = $h(s), e(M_, C_)) : e(Mh, Ch), t;
  }
  return t.base = function(o) {
    return arguments.length ? (r = +o, a()) : r;
  }, t.domain = function(o) {
    return arguments.length ? (n(o), a()) : n();
  }, t.ticks = (o) => {
    const l = n();
    let c = l[0], u = l[l.length - 1];
    const h = u < c;
    h && ([c, u] = [u, c]);
    let d = i(c), f = i(u), p, m;
    const g = o == null ? 10 : +o;
    let v = [];
    if (!(r % 1) && f - d < g) {
      if (d = Math.floor(d), f = Math.ceil(f), c > 0) {
        for (; d <= f; ++d)
          for (p = 1; p < r; ++p)
            if (m = d < 0 ? p / s(-d) : p * s(d), !(m < c)) {
              if (m > u)
                break;
              v.push(m);
            }
      } else
        for (; d <= f; ++d)
          for (p = r - 1; p >= 1; --p)
            if (m = d > 0 ? p / s(-d) : p * s(d), !(m < c)) {
              if (m > u)
                break;
              v.push(m);
            }
      v.length * 2 < g && (v = Vs(c, u, g));
    } else
      v = Vs(d, f, Math.min(f - d, g)).map(s);
    return h ? v.reverse() : v;
  }, t.tickFormat = (o, l) => {
    if (o == null && (o = 10), l == null && (l = r === 10 ? "s" : ","), typeof l != "function" && (!(r % 1) && (l = Ii(l)).precision == null && (l.trim = !0), l = Ec(l)), o === 1 / 0)
      return l;
    const c = Math.max(1, r * o / t.ticks().length);
    return (u) => {
      let h = u / s(Math.round(i(u)));
      return h * r < r - 0.5 && (h *= r), h <= c ? l(u) : "";
    };
  }, t.nice = () => n(cg(n(), {
    floor: (o) => s(Math.floor(i(o))),
    ceil: (o) => s(Math.ceil(i(o)))
  })), t;
}
function ug() {
  const e = D_(ag()).domain([1, 10]);
  return e.copy = () => Mc(e, ug()).base(e.base()), qr.apply(e, arguments), e;
}
function Cc() {
  var e = 0, t = 1, n = 1, r = [0.5], i = [0, 1], s;
  function a(l) {
    return l != null && l <= l ? i[uc(r, l, 0, n)] : s;
  }
  function o() {
    var l = -1;
    for (r = new Array(n); ++l < n; )
      r[l] = ((l + 1) * t - (l - n) * e) / (n + 1);
    return a;
  }
  return a.domain = function(l) {
    return arguments.length ? ([e, t] = l, e = +e, t = +t, o()) : [e, t];
  }, a.range = function(l) {
    return arguments.length ? (n = (i = Array.from(l)).length - 1, o()) : i.slice();
  }, a.invertExtent = function(l) {
    var c = i.indexOf(l);
    return c < 0 ? [NaN, NaN] : c < 1 ? [e, r[0]] : c >= n ? [r[n - 1], t] : [r[c - 1], r[c]];
  }, a.unknown = function(l) {
    return arguments.length && (s = l), a;
  }, a.thresholds = function() {
    return r.slice();
  }, a.copy = function() {
    return Cc().domain([e, t]).range(i).unknown(s);
  }, qr.apply(lg(a), arguments);
}
const Ao = /* @__PURE__ */ new Date(), Lo = /* @__PURE__ */ new Date();
function Zt(e, t, n, r) {
  function i(s) {
    return e(s = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+s)), s;
  }
  return i.floor = (s) => (e(s = /* @__PURE__ */ new Date(+s)), s), i.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), i.round = (s) => {
    const a = i(s), o = i.ceil(s);
    return s - a < o - s ? a : o;
  }, i.offset = (s, a) => (t(s = /* @__PURE__ */ new Date(+s), a == null ? 1 : Math.floor(a)), s), i.range = (s, a, o) => {
    const l = [];
    if (s = i.ceil(s), o = o == null ? 1 : Math.floor(o), !(s < a) || !(o > 0))
      return l;
    let c;
    do
      l.push(c = /* @__PURE__ */ new Date(+s)), t(s, o), e(s);
    while (c < s && s < a);
    return l;
  }, i.filter = (s) => Zt((a) => {
    if (a >= a)
      for (; e(a), !s(a); )
        a.setTime(a - 1);
  }, (a, o) => {
    if (a >= a)
      if (o < 0)
        for (; ++o <= 0; )
          for (; t(a, -1), !s(a); )
            ;
      else
        for (; --o >= 0; )
          for (; t(a, 1), !s(a); )
            ;
  }), n && (i.count = (s, a) => (Ao.setTime(+s), Lo.setTime(+a), e(Ao), e(Lo), Math.floor(n(Ao, Lo))), i.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? i.filter(r ? (a) => r(a) % s === 0 : (a) => i.count(0, a) % s === 0) : i)), i;
}
const oa = Zt(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
oa.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? Zt((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, n) => {
  t.setTime(+t + n * e);
}, (t, n) => (n - t) / e) : oa);
oa.range;
const un = 1e3, Ce = un * 60, hn = Ce * 60, vn = hn * 24, $c = vn * 7, Ah = vn * 30, Do = vn * 365, Or = Zt((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * un);
}, (e, t) => (t - e) / un, (e) => e.getUTCSeconds());
Or.range;
const Ac = Zt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * un);
}, (e, t) => {
  e.setTime(+e + t * Ce);
}, (e, t) => (t - e) / Ce, (e) => e.getMinutes());
Ac.range;
const k_ = Zt((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * Ce);
}, (e, t) => (t - e) / Ce, (e) => e.getUTCMinutes());
k_.range;
const Lc = Zt((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * un - e.getMinutes() * Ce);
}, (e, t) => {
  e.setTime(+e + t * hn);
}, (e, t) => (t - e) / hn, (e) => e.getHours());
Lc.range;
const R_ = Zt((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * hn);
}, (e, t) => (t - e) / hn, (e) => e.getUTCHours());
R_.range;
const Zi = Zt(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * Ce) / vn,
  (e) => e.getDate() - 1
);
Zi.range;
const Dc = Zt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / vn, (e) => e.getUTCDate() - 1);
Dc.range;
const I_ = Zt((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / vn, (e) => Math.floor(e / vn));
I_.range;
function er(e) {
  return Zt((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setDate(t.getDate() + n * 7);
  }, (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Ce) / $c);
}
const Pa = er(0), la = er(1), N_ = er(2), P_ = er(3), Ur = er(4), U_ = er(5), B_ = er(6);
Pa.range;
la.range;
N_.range;
P_.range;
Ur.range;
U_.range;
B_.range;
function nr(e) {
  return Zt((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, n) => {
    t.setUTCDate(t.getUTCDate() + n * 7);
  }, (t, n) => (n - t) / $c);
}
const hg = nr(0), ca = nr(1), V_ = nr(2), H_ = nr(3), Br = nr(4), F_ = nr(5), G_ = nr(6);
hg.range;
ca.range;
V_.range;
H_.range;
Br.range;
F_.range;
G_.range;
const kc = Zt((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
kc.range;
const z_ = Zt((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
z_.range;
const yn = Zt((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
yn.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Zt((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, n) => {
  t.setFullYear(t.getFullYear() + n * e);
});
yn.range;
const Qn = Zt((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
Qn.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Zt((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, n) => {
  t.setUTCFullYear(t.getUTCFullYear() + n * e);
});
Qn.range;
function j_(e, t, n, r, i, s) {
  const a = [
    [Or, 1, un],
    [Or, 5, 5 * un],
    [Or, 15, 15 * un],
    [Or, 30, 30 * un],
    [s, 1, Ce],
    [s, 5, 5 * Ce],
    [s, 15, 15 * Ce],
    [s, 30, 30 * Ce],
    [i, 1, hn],
    [i, 3, 3 * hn],
    [i, 6, 6 * hn],
    [i, 12, 12 * hn],
    [r, 1, vn],
    [r, 2, 2 * vn],
    [n, 1, $c],
    [t, 1, Ah],
    [t, 3, 3 * Ah],
    [e, 1, Do]
  ];
  function o(c, u, h) {
    const d = u < c;
    d && ([c, u] = [u, c]);
    const f = h && typeof h.range == "function" ? h : l(c, u, h), p = f ? f.range(c, +u + 1) : [];
    return d ? p.reverse() : p;
  }
  function l(c, u, h) {
    const d = Math.abs(u - c) / h, f = cc(([, , g]) => g).right(a, d);
    if (f === a.length)
      return e.every(Ko(c / Do, u / Do, h));
    if (f === 0)
      return oa.every(Math.max(Ko(c, u, h), 1));
    const [p, m] = a[d / a[f - 1][2] < a[f][2] / d ? f - 1 : f];
    return p.every(m);
  }
  return [o, l];
}
const [W_, q_] = j_(yn, kc, Pa, Zi, Lc, Ac);
function ko(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Ro(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function Jr(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function Y_(e) {
  var t = e.dateTime, n = e.date, r = e.time, i = e.periods, s = e.days, a = e.shortDays, o = e.months, l = e.shortMonths, c = ti(i), u = ei(i), h = ti(s), d = ei(s), f = ti(a), p = ei(a), m = ti(o), g = ei(o), v = ti(l), y = ei(l), x = {
    a: U,
    A: I,
    b: B,
    B: j,
    c: null,
    d: Nh,
    e: Nh,
    f: vE,
    g: ME,
    G: $E,
    H: pE,
    I: gE,
    j: mE,
    L: dg,
    m: yE,
    M: xE,
    p: Y,
    q: J,
    Q: Bh,
    s: Vh,
    S: bE,
    u: wE,
    U: _E,
    V: EE,
    w: SE,
    W: OE,
    x: null,
    X: null,
    y: TE,
    Y: CE,
    Z: AE,
    "%": Uh
  }, S = {
    a: ft,
    A: z,
    b: Z,
    B: ut,
    c: null,
    d: Ph,
    e: Ph,
    f: RE,
    g: zE,
    G: WE,
    H: LE,
    I: DE,
    j: kE,
    L: pg,
    m: IE,
    M: NE,
    p: nt,
    q: Ot,
    Q: Bh,
    s: Vh,
    S: PE,
    u: UE,
    U: BE,
    V: VE,
    w: HE,
    W: FE,
    x: null,
    X: null,
    y: GE,
    Y: jE,
    Z: qE,
    "%": Uh
  }, _ = {
    a: L,
    A: C,
    b: V,
    B: M,
    c: A,
    d: Rh,
    e: Rh,
    f: uE,
    g: kh,
    G: Dh,
    H: Ih,
    I: Ih,
    j: aE,
    L: cE,
    m: sE,
    M: oE,
    p: N,
    q: iE,
    Q: dE,
    s: fE,
    S: lE,
    u: J_,
    U: tE,
    V: eE,
    w: Q_,
    W: nE,
    x: w,
    X: P,
    y: kh,
    Y: Dh,
    Z: rE,
    "%": hE
  };
  x.x = E(n, x), x.X = E(r, x), x.c = E(t, x), S.x = E(n, S), S.X = E(r, S), S.c = E(t, S);
  function E(W, Q) {
    return function(lt) {
      var F = [], It = -1, vt = 0, Gt = W.length, zt, tt, Dt;
      for (lt instanceof Date || (lt = /* @__PURE__ */ new Date(+lt)); ++It < Gt; )
        W.charCodeAt(It) === 37 && (F.push(W.slice(vt, It)), (tt = Lh[zt = W.charAt(++It)]) != null ? zt = W.charAt(++It) : tt = zt === "e" ? " " : "0", (Dt = Q[zt]) && (zt = Dt(lt, tt)), F.push(zt), vt = It + 1);
      return F.push(W.slice(vt, It)), F.join("");
    };
  }
  function T(W, Q) {
    return function(lt) {
      var F = Jr(1900, void 0, 1), It = k(F, W, lt += "", 0), vt, Gt;
      if (It != lt.length)
        return null;
      if ("Q" in F)
        return new Date(F.Q);
      if ("s" in F)
        return new Date(F.s * 1e3 + ("L" in F ? F.L : 0));
      if (Q && !("Z" in F) && (F.Z = 0), "p" in F && (F.H = F.H % 12 + F.p * 12), F.m === void 0 && (F.m = "q" in F ? F.q : 0), "V" in F) {
        if (F.V < 1 || F.V > 53)
          return null;
        "w" in F || (F.w = 1), "Z" in F ? (vt = Ro(Jr(F.y, 0, 1)), Gt = vt.getUTCDay(), vt = Gt > 4 || Gt === 0 ? ca.ceil(vt) : ca(vt), vt = Dc.offset(vt, (F.V - 1) * 7), F.y = vt.getUTCFullYear(), F.m = vt.getUTCMonth(), F.d = vt.getUTCDate() + (F.w + 6) % 7) : (vt = ko(Jr(F.y, 0, 1)), Gt = vt.getDay(), vt = Gt > 4 || Gt === 0 ? la.ceil(vt) : la(vt), vt = Zi.offset(vt, (F.V - 1) * 7), F.y = vt.getFullYear(), F.m = vt.getMonth(), F.d = vt.getDate() + (F.w + 6) % 7);
      } else
        ("W" in F || "U" in F) && ("w" in F || (F.w = "u" in F ? F.u % 7 : "W" in F ? 1 : 0), Gt = "Z" in F ? Ro(Jr(F.y, 0, 1)).getUTCDay() : ko(Jr(F.y, 0, 1)).getDay(), F.m = 0, F.d = "W" in F ? (F.w + 6) % 7 + F.W * 7 - (Gt + 5) % 7 : F.w + F.U * 7 - (Gt + 6) % 7);
      return "Z" in F ? (F.H += F.Z / 100 | 0, F.M += F.Z % 100, Ro(F)) : ko(F);
    };
  }
  function k(W, Q, lt, F) {
    for (var It = 0, vt = Q.length, Gt = lt.length, zt, tt; It < vt; ) {
      if (F >= Gt)
        return -1;
      if (zt = Q.charCodeAt(It++), zt === 37) {
        if (zt = Q.charAt(It++), tt = _[zt in Lh ? Q.charAt(It++) : zt], !tt || (F = tt(W, lt, F)) < 0)
          return -1;
      } else if (zt != lt.charCodeAt(F++))
        return -1;
    }
    return F;
  }
  function N(W, Q, lt) {
    var F = c.exec(Q.slice(lt));
    return F ? (W.p = u.get(F[0].toLowerCase()), lt + F[0].length) : -1;
  }
  function L(W, Q, lt) {
    var F = f.exec(Q.slice(lt));
    return F ? (W.w = p.get(F[0].toLowerCase()), lt + F[0].length) : -1;
  }
  function C(W, Q, lt) {
    var F = h.exec(Q.slice(lt));
    return F ? (W.w = d.get(F[0].toLowerCase()), lt + F[0].length) : -1;
  }
  function V(W, Q, lt) {
    var F = v.exec(Q.slice(lt));
    return F ? (W.m = y.get(F[0].toLowerCase()), lt + F[0].length) : -1;
  }
  function M(W, Q, lt) {
    var F = m.exec(Q.slice(lt));
    return F ? (W.m = g.get(F[0].toLowerCase()), lt + F[0].length) : -1;
  }
  function A(W, Q, lt) {
    return k(W, t, Q, lt);
  }
  function w(W, Q, lt) {
    return k(W, n, Q, lt);
  }
  function P(W, Q, lt) {
    return k(W, r, Q, lt);
  }
  function U(W) {
    return a[W.getDay()];
  }
  function I(W) {
    return s[W.getDay()];
  }
  function B(W) {
    return l[W.getMonth()];
  }
  function j(W) {
    return o[W.getMonth()];
  }
  function Y(W) {
    return i[+(W.getHours() >= 12)];
  }
  function J(W) {
    return 1 + ~~(W.getMonth() / 3);
  }
  function ft(W) {
    return a[W.getUTCDay()];
  }
  function z(W) {
    return s[W.getUTCDay()];
  }
  function Z(W) {
    return l[W.getUTCMonth()];
  }
  function ut(W) {
    return o[W.getUTCMonth()];
  }
  function nt(W) {
    return i[+(W.getUTCHours() >= 12)];
  }
  function Ot(W) {
    return 1 + ~~(W.getUTCMonth() / 3);
  }
  return {
    format: function(W) {
      var Q = E(W += "", x);
      return Q.toString = function() {
        return W;
      }, Q;
    },
    parse: function(W) {
      var Q = T(W += "", !1);
      return Q.toString = function() {
        return W;
      }, Q;
    },
    utcFormat: function(W) {
      var Q = E(W += "", S);
      return Q.toString = function() {
        return W;
      }, Q;
    },
    utcParse: function(W) {
      var Q = T(W += "", !0);
      return Q.toString = function() {
        return W;
      }, Q;
    }
  };
}
var Lh = { "-": "", _: " ", 0: "0" }, Qt = /^\s*\d+/, X_ = /^%/, Z_ = /[\\^$*+?|[\]().{}]/g;
function mt(e, t, n) {
  var r = e < 0 ? "-" : "", i = (r ? -e : e) + "", s = i.length;
  return r + (s < n ? new Array(n - s + 1).join(t) + i : i);
}
function K_(e) {
  return e.replace(Z_, "\\$&");
}
function ti(e) {
  return new RegExp("^(?:" + e.map(K_).join("|") + ")", "i");
}
function ei(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]));
}
function Q_(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 1));
  return r ? (e.w = +r[0], n + r[0].length) : -1;
}
function J_(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 1));
  return r ? (e.u = +r[0], n + r[0].length) : -1;
}
function tE(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 2));
  return r ? (e.U = +r[0], n + r[0].length) : -1;
}
function eE(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 2));
  return r ? (e.V = +r[0], n + r[0].length) : -1;
}
function nE(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 2));
  return r ? (e.W = +r[0], n + r[0].length) : -1;
}
function Dh(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 4));
  return r ? (e.y = +r[0], n + r[0].length) : -1;
}
function kh(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 2));
  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), n + r[0].length) : -1;
}
function rE(e, t, n) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6));
  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), n + r[0].length) : -1;
}
function iE(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 1));
  return r ? (e.q = r[0] * 3 - 3, n + r[0].length) : -1;
}
function sE(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 2));
  return r ? (e.m = r[0] - 1, n + r[0].length) : -1;
}
function Rh(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 2));
  return r ? (e.d = +r[0], n + r[0].length) : -1;
}
function aE(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 3));
  return r ? (e.m = 0, e.d = +r[0], n + r[0].length) : -1;
}
function Ih(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 2));
  return r ? (e.H = +r[0], n + r[0].length) : -1;
}
function oE(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 2));
  return r ? (e.M = +r[0], n + r[0].length) : -1;
}
function lE(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 2));
  return r ? (e.S = +r[0], n + r[0].length) : -1;
}
function cE(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 3));
  return r ? (e.L = +r[0], n + r[0].length) : -1;
}
function uE(e, t, n) {
  var r = Qt.exec(t.slice(n, n + 6));
  return r ? (e.L = Math.floor(r[0] / 1e3), n + r[0].length) : -1;
}
function hE(e, t, n) {
  var r = X_.exec(t.slice(n, n + 1));
  return r ? n + r[0].length : -1;
}
function dE(e, t, n) {
  var r = Qt.exec(t.slice(n));
  return r ? (e.Q = +r[0], n + r[0].length) : -1;
}
function fE(e, t, n) {
  var r = Qt.exec(t.slice(n));
  return r ? (e.s = +r[0], n + r[0].length) : -1;
}
function Nh(e, t) {
  return mt(e.getDate(), t, 2);
}
function pE(e, t) {
  return mt(e.getHours(), t, 2);
}
function gE(e, t) {
  return mt(e.getHours() % 12 || 12, t, 2);
}
function mE(e, t) {
  return mt(1 + Zi.count(yn(e), e), t, 3);
}
function dg(e, t) {
  return mt(e.getMilliseconds(), t, 3);
}
function vE(e, t) {
  return dg(e, t) + "000";
}
function yE(e, t) {
  return mt(e.getMonth() + 1, t, 2);
}
function xE(e, t) {
  return mt(e.getMinutes(), t, 2);
}
function bE(e, t) {
  return mt(e.getSeconds(), t, 2);
}
function wE(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function _E(e, t) {
  return mt(Pa.count(yn(e) - 1, e), t, 2);
}
function fg(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? Ur(e) : Ur.ceil(e);
}
function EE(e, t) {
  return e = fg(e), mt(Ur.count(yn(e), e) + (yn(e).getDay() === 4), t, 2);
}
function SE(e) {
  return e.getDay();
}
function OE(e, t) {
  return mt(la.count(yn(e) - 1, e), t, 2);
}
function TE(e, t) {
  return mt(e.getFullYear() % 100, t, 2);
}
function ME(e, t) {
  return e = fg(e), mt(e.getFullYear() % 100, t, 2);
}
function CE(e, t) {
  return mt(e.getFullYear() % 1e4, t, 4);
}
function $E(e, t) {
  var n = e.getDay();
  return e = n >= 4 || n === 0 ? Ur(e) : Ur.ceil(e), mt(e.getFullYear() % 1e4, t, 4);
}
function AE(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + mt(t / 60 | 0, "0", 2) + mt(t % 60, "0", 2);
}
function Ph(e, t) {
  return mt(e.getUTCDate(), t, 2);
}
function LE(e, t) {
  return mt(e.getUTCHours(), t, 2);
}
function DE(e, t) {
  return mt(e.getUTCHours() % 12 || 12, t, 2);
}
function kE(e, t) {
  return mt(1 + Dc.count(Qn(e), e), t, 3);
}
function pg(e, t) {
  return mt(e.getUTCMilliseconds(), t, 3);
}
function RE(e, t) {
  return pg(e, t) + "000";
}
function IE(e, t) {
  return mt(e.getUTCMonth() + 1, t, 2);
}
function NE(e, t) {
  return mt(e.getUTCMinutes(), t, 2);
}
function PE(e, t) {
  return mt(e.getUTCSeconds(), t, 2);
}
function UE(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function BE(e, t) {
  return mt(hg.count(Qn(e) - 1, e), t, 2);
}
function gg(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? Br(e) : Br.ceil(e);
}
function VE(e, t) {
  return e = gg(e), mt(Br.count(Qn(e), e) + (Qn(e).getUTCDay() === 4), t, 2);
}
function HE(e) {
  return e.getUTCDay();
}
function FE(e, t) {
  return mt(ca.count(Qn(e) - 1, e), t, 2);
}
function GE(e, t) {
  return mt(e.getUTCFullYear() % 100, t, 2);
}
function zE(e, t) {
  return e = gg(e), mt(e.getUTCFullYear() % 100, t, 2);
}
function jE(e, t) {
  return mt(e.getUTCFullYear() % 1e4, t, 4);
}
function WE(e, t) {
  var n = e.getUTCDay();
  return e = n >= 4 || n === 0 ? Br(e) : Br.ceil(e), mt(e.getUTCFullYear() % 1e4, t, 4);
}
function qE() {
  return "+0000";
}
function Uh() {
  return "%";
}
function Bh(e) {
  return +e;
}
function Vh(e) {
  return Math.floor(+e / 1e3);
}
var dr, mg;
YE({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function YE(e) {
  return dr = Y_(e), mg = dr.format, dr.parse, dr.utcFormat, dr.utcParse, dr;
}
function XE(e) {
  return new Date(e);
}
function ZE(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function vg(e, t, n, r, i, s, a, o, l, c) {
  var u = og(), h = u.invert, d = u.domain, f = c(".%L"), p = c(":%S"), m = c("%I:%M"), g = c("%I %p"), v = c("%a %d"), y = c("%b %d"), x = c("%B"), S = c("%Y");
  function _(E) {
    return (l(E) < E ? f : o(E) < E ? p : a(E) < E ? m : s(E) < E ? g : r(E) < E ? i(E) < E ? v : y : n(E) < E ? x : S)(E);
  }
  return u.invert = function(E) {
    return new Date(h(E));
  }, u.domain = function(E) {
    return arguments.length ? d(Array.from(E, ZE)) : d().map(XE);
  }, u.ticks = function(E) {
    var T = d();
    return e(T[0], T[T.length - 1], E ?? 10);
  }, u.tickFormat = function(E, T) {
    return T == null ? _ : c(T);
  }, u.nice = function(E) {
    var T = d();
    return (!E || typeof E.range != "function") && (E = t(T[0], T[T.length - 1], E ?? 10)), E ? d(cg(T, E)) : u;
  }, u.copy = function() {
    return Mc(u, vg(e, t, n, r, i, s, a, o, l, c));
  }, u;
}
function yg() {
  return qr.apply(vg(W_, q_, yn, kc, Pa, Zi, Lc, Ac, Or, mg).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function ct(e) {
  return function() {
    return e;
  };
}
const Hh = Math.abs, ie = Math.atan2, Nn = Math.cos, KE = Math.max, Io = Math.min, je = Math.sin, Tr = Math.sqrt, se = 1e-12, Ui = Math.PI, ua = Ui / 2, Ds = 2 * Ui;
function QE(e) {
  return e > 1 ? 0 : e < -1 ? Ui : Math.acos(e);
}
function Fh(e) {
  return e >= 1 ? ua : e <= -1 ? -ua : Math.asin(e);
}
function Ua(e) {
  let t = 3;
  return e.digits = function(n) {
    if (!arguments.length)
      return t;
    if (n == null)
      t = null;
    else {
      const r = Math.floor(n);
      if (!(r >= 0))
        throw new RangeError(`invalid digits: ${n}`);
      t = r;
    }
    return e;
  }, () => new wc(t);
}
function JE(e) {
  return e.innerRadius;
}
function tS(e) {
  return e.outerRadius;
}
function eS(e) {
  return e.startAngle;
}
function nS(e) {
  return e.endAngle;
}
function rS(e) {
  return e && e.padAngle;
}
function iS(e, t, n, r, i, s, a, o) {
  var l = n - e, c = r - t, u = a - i, h = o - s, d = h * l - u * c;
  if (!(d * d < se))
    return d = (u * (t - s) - h * (e - i)) / d, [e + d * l, t + d * c];
}
function gs(e, t, n, r, i, s, a) {
  var o = e - n, l = t - r, c = (a ? s : -s) / Tr(o * o + l * l), u = c * l, h = -c * o, d = e + u, f = t + h, p = n + u, m = r + h, g = (d + p) / 2, v = (f + m) / 2, y = p - d, x = m - f, S = y * y + x * x, _ = i - s, E = d * m - p * f, T = (x < 0 ? -1 : 1) * Tr(KE(0, _ * _ * S - E * E)), k = (E * x - y * T) / S, N = (-E * y - x * T) / S, L = (E * x + y * T) / S, C = (-E * y + x * T) / S, V = k - g, M = N - v, A = L - g, w = C - v;
  return V * V + M * M > A * A + w * w && (k = L, N = C), {
    cx: k,
    cy: N,
    x01: -u,
    y01: -h,
    x11: k * (i / _ - 1),
    y11: N * (i / _ - 1)
  };
}
function Bi() {
  var e = JE, t = tS, n = ct(0), r = null, i = eS, s = nS, a = rS, o = null, l = Ua(c);
  function c() {
    var u, h, d = +e.apply(this, arguments), f = +t.apply(this, arguments), p = i.apply(this, arguments) - ua, m = s.apply(this, arguments) - ua, g = Hh(m - p), v = m > p;
    if (o || (o = u = l()), f < d && (h = f, f = d, d = h), !(f > se))
      o.moveTo(0, 0);
    else if (g > Ds - se)
      o.moveTo(f * Nn(p), f * je(p)), o.arc(0, 0, f, p, m, !v), d > se && (o.moveTo(d * Nn(m), d * je(m)), o.arc(0, 0, d, m, p, v));
    else {
      var y = p, x = m, S = p, _ = m, E = g, T = g, k = a.apply(this, arguments) / 2, N = k > se && (r ? +r.apply(this, arguments) : Tr(d * d + f * f)), L = Io(Hh(f - d) / 2, +n.apply(this, arguments)), C = L, V = L, M, A;
      if (N > se) {
        var w = Fh(N / d * je(k)), P = Fh(N / f * je(k));
        (E -= w * 2) > se ? (w *= v ? 1 : -1, S += w, _ -= w) : (E = 0, S = _ = (p + m) / 2), (T -= P * 2) > se ? (P *= v ? 1 : -1, y += P, x -= P) : (T = 0, y = x = (p + m) / 2);
      }
      var U = f * Nn(y), I = f * je(y), B = d * Nn(_), j = d * je(_);
      if (L > se) {
        var Y = f * Nn(x), J = f * je(x), ft = d * Nn(S), z = d * je(S), Z;
        if (g < Ui)
          if (Z = iS(U, I, ft, z, Y, J, B, j)) {
            var ut = U - Z[0], nt = I - Z[1], Ot = Y - Z[0], W = J - Z[1], Q = 1 / je(QE((ut * Ot + nt * W) / (Tr(ut * ut + nt * nt) * Tr(Ot * Ot + W * W))) / 2), lt = Tr(Z[0] * Z[0] + Z[1] * Z[1]);
            C = Io(L, (d - lt) / (Q - 1)), V = Io(L, (f - lt) / (Q + 1));
          } else
            C = V = 0;
      }
      T > se ? V > se ? (M = gs(ft, z, U, I, f, V, v), A = gs(Y, J, B, j, f, V, v), o.moveTo(M.cx + M.x01, M.cy + M.y01), V < L ? o.arc(M.cx, M.cy, V, ie(M.y01, M.x01), ie(A.y01, A.x01), !v) : (o.arc(M.cx, M.cy, V, ie(M.y01, M.x01), ie(M.y11, M.x11), !v), o.arc(0, 0, f, ie(M.cy + M.y11, M.cx + M.x11), ie(A.cy + A.y11, A.cx + A.x11), !v), o.arc(A.cx, A.cy, V, ie(A.y11, A.x11), ie(A.y01, A.x01), !v))) : (o.moveTo(U, I), o.arc(0, 0, f, y, x, !v)) : o.moveTo(U, I), !(d > se) || !(E > se) ? o.lineTo(B, j) : C > se ? (M = gs(B, j, Y, J, d, -C, v), A = gs(U, I, ft, z, d, -C, v), o.lineTo(M.cx + M.x01, M.cy + M.y01), C < L ? o.arc(M.cx, M.cy, C, ie(M.y01, M.x01), ie(A.y01, A.x01), !v) : (o.arc(M.cx, M.cy, C, ie(M.y01, M.x01), ie(M.y11, M.x11), !v), o.arc(0, 0, d, ie(M.cy + M.y11, M.cx + M.x11), ie(A.cy + A.y11, A.cx + A.x11), v), o.arc(A.cx, A.cy, C, ie(A.y11, A.x11), ie(A.y01, A.x01), !v))) : o.arc(0, 0, d, _, S, v);
    }
    if (o.closePath(), u)
      return o = null, u + "" || null;
  }
  return c.centroid = function() {
    var u = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, h = (+i.apply(this, arguments) + +s.apply(this, arguments)) / 2 - Ui / 2;
    return [Nn(h) * u, je(h) * u];
  }, c.innerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : ct(+u), c) : e;
  }, c.outerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : ct(+u), c) : t;
  }, c.cornerRadius = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : ct(+u), c) : n;
  }, c.padRadius = function(u) {
    return arguments.length ? (r = u == null ? null : typeof u == "function" ? u : ct(+u), c) : r;
  }, c.startAngle = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : ct(+u), c) : i;
  }, c.endAngle = function(u) {
    return arguments.length ? (s = typeof u == "function" ? u : ct(+u), c) : s;
  }, c.padAngle = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : ct(+u), c) : a;
  }, c.context = function(u) {
    return arguments.length ? (o = u ?? null, c) : o;
  }, c;
}
var sS = Array.prototype.slice;
function Ba(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function xg(e) {
  this._context = e;
}
xg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function Va(e) {
  return new xg(e);
}
function Rc(e) {
  return e[0];
}
function Ic(e) {
  return e[1];
}
function Ki(e, t) {
  var n = ct(!0), r = null, i = Va, s = null, a = Ua(o);
  e = typeof e == "function" ? e : e === void 0 ? Rc : ct(e), t = typeof t == "function" ? t : t === void 0 ? Ic : ct(t);
  function o(l) {
    var c, u = (l = Ba(l)).length, h, d = !1, f;
    for (r == null && (s = i(f = a())), c = 0; c <= u; ++c)
      !(c < u && n(h = l[c], c, l)) === d && ((d = !d) ? s.lineStart() : s.lineEnd()), d && s.point(+e(h, c, l), +t(h, c, l));
    if (f)
      return s = null, f + "" || null;
  }
  return o.x = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : ct(+l), o) : e;
  }, o.y = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : ct(+l), o) : t;
  }, o.defined = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : ct(!!l), o) : n;
  }, o.curve = function(l) {
    return arguments.length ? (i = l, r != null && (s = i(r)), o) : i;
  }, o.context = function(l) {
    return arguments.length ? (l == null ? r = s = null : s = i(r = l), o) : r;
  }, o;
}
function Nc(e, t, n) {
  var r = null, i = ct(!0), s = null, a = Va, o = null, l = Ua(c);
  e = typeof e == "function" ? e : e === void 0 ? Rc : ct(+e), t = typeof t == "function" ? t : ct(t === void 0 ? 0 : +t), n = typeof n == "function" ? n : n === void 0 ? Ic : ct(+n);
  function c(h) {
    var d, f, p, m = (h = Ba(h)).length, g, v = !1, y, x = new Array(m), S = new Array(m);
    for (s == null && (o = a(y = l())), d = 0; d <= m; ++d) {
      if (!(d < m && i(g = h[d], d, h)) === v)
        if (v = !v)
          f = d, o.areaStart(), o.lineStart();
        else {
          for (o.lineEnd(), o.lineStart(), p = d - 1; p >= f; --p)
            o.point(x[p], S[p]);
          o.lineEnd(), o.areaEnd();
        }
      v && (x[d] = +e(g, d, h), S[d] = +t(g, d, h), o.point(r ? +r(g, d, h) : x[d], n ? +n(g, d, h) : S[d]));
    }
    if (y)
      return o = null, y + "" || null;
  }
  function u() {
    return Ki().defined(i).curve(a).context(s);
  }
  return c.x = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : ct(+h), r = null, c) : e;
  }, c.x0 = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : ct(+h), c) : e;
  }, c.x1 = function(h) {
    return arguments.length ? (r = h == null ? null : typeof h == "function" ? h : ct(+h), c) : r;
  }, c.y = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : ct(+h), n = null, c) : t;
  }, c.y0 = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : ct(+h), c) : t;
  }, c.y1 = function(h) {
    return arguments.length ? (n = h == null ? null : typeof h == "function" ? h : ct(+h), c) : n;
  }, c.lineX0 = c.lineY0 = function() {
    return u().x(e).y(t);
  }, c.lineY1 = function() {
    return u().x(e).y(n);
  }, c.lineX1 = function() {
    return u().x(r).y(t);
  }, c.defined = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : ct(!!h), c) : i;
  }, c.curve = function(h) {
    return arguments.length ? (a = h, s != null && (o = a(s)), c) : a;
  }, c.context = function(h) {
    return arguments.length ? (h == null ? s = o = null : o = a(s = h), c) : s;
  }, c;
}
function aS(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function oS(e) {
  return e;
}
function lS() {
  var e = oS, t = aS, n = null, r = ct(0), i = ct(Ds), s = ct(0);
  function a(o) {
    var l, c = (o = Ba(o)).length, u, h, d = 0, f = new Array(c), p = new Array(c), m = +r.apply(this, arguments), g = Math.min(Ds, Math.max(-Ds, i.apply(this, arguments) - m)), v, y = Math.min(Math.abs(g) / c, s.apply(this, arguments)), x = y * (g < 0 ? -1 : 1), S;
    for (l = 0; l < c; ++l)
      (S = p[f[l] = l] = +e(o[l], l, o)) > 0 && (d += S);
    for (t != null ? f.sort(function(_, E) {
      return t(p[_], p[E]);
    }) : n != null && f.sort(function(_, E) {
      return n(o[_], o[E]);
    }), l = 0, h = d ? (g - c * x) / d : 0; l < c; ++l, m = v)
      u = f[l], S = p[u], v = m + (S > 0 ? S * h : 0) + x, p[u] = {
        data: o[u],
        index: l,
        value: S,
        startAngle: m,
        endAngle: v,
        padAngle: y
      };
    return p;
  }
  return a.value = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : ct(+o), a) : e;
  }, a.sortValues = function(o) {
    return arguments.length ? (t = o, n = null, a) : t;
  }, a.sort = function(o) {
    return arguments.length ? (n = o, t = null, a) : n;
  }, a.startAngle = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : ct(+o), a) : r;
  }, a.endAngle = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : ct(+o), a) : i;
  }, a.padAngle = function(o) {
    return arguments.length ? (s = typeof o == "function" ? o : ct(+o), a) : s;
  }, a;
}
var cS = wg(Va);
function bg(e) {
  this._curve = e;
}
bg.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(e, t) {
    this._curve.point(t * Math.sin(e), t * -Math.cos(e));
  }
};
function wg(e) {
  function t(n) {
    return new bg(e(n));
  }
  return t._curve = e, t;
}
function uS(e) {
  var t = e.curve;
  return e.angle = e.x, delete e.x, e.radius = e.y, delete e.y, e.curve = function(n) {
    return arguments.length ? t(wg(n)) : t()._curve;
  }, e;
}
function hS() {
  return uS(Ki().curve(cS));
}
class dS {
  constructor(t, n) {
    this._context = t, this._x = n;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, n) {
    switch (t = +t, n = +n, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
        break;
      }
    }
    this._x0 = t, this._y0 = n;
  }
}
function fS(e) {
  return new dS(e, !0);
}
function pS(e) {
  return e.source;
}
function gS(e) {
  return e.target;
}
function mS(e) {
  let t = pS, n = gS, r = Rc, i = Ic, s = null, a = null, o = Ua(l);
  function l() {
    let c;
    const u = sS.call(arguments), h = t.apply(this, u), d = n.apply(this, u);
    if (s == null && (a = e(c = o())), a.lineStart(), u[0] = h, a.point(+r.apply(this, u), +i.apply(this, u)), u[0] = d, a.point(+r.apply(this, u), +i.apply(this, u)), a.lineEnd(), c)
      return a = null, c + "" || null;
  }
  return l.source = function(c) {
    return arguments.length ? (t = c, l) : t;
  }, l.target = function(c) {
    return arguments.length ? (n = c, l) : n;
  }, l.x = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : ct(+c), l) : r;
  }, l.y = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : ct(+c), l) : i;
  }, l.context = function(c) {
    return arguments.length ? (c == null ? s = a = null : a = e(s = c), l) : s;
  }, l;
}
function vS() {
  return mS(fS);
}
function Dn() {
}
function ha(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  );
}
function Ha(e) {
  this._context = e;
}
Ha.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        ha(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        ha(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function yS(e) {
  return new Ha(e);
}
function _g(e) {
  this._context = e;
}
_g.prototype = {
  areaStart: Dn,
  areaEnd: Dn,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = e, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = e, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        ha(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function xS(e) {
  return new _g(e);
}
function Eg(e) {
  this._context = e;
}
Eg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + e) / 6, r = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r);
        break;
      case 3:
        this._point = 4;
      default:
        ha(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
  }
};
function bS(e) {
  return new Eg(e);
}
function Sg(e, t) {
  this._basis = new Ha(e), this._beta = t;
}
Sg.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length - 1;
    if (n > 0)
      for (var r = e[0], i = t[0], s = e[n] - r, a = t[n] - i, o = -1, l; ++o <= n; )
        l = o / n, this._basis.point(
          this._beta * e[o] + (1 - this._beta) * (r + l * s),
          this._beta * t[o] + (1 - this._beta) * (i + l * a)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
const wS = function e(t) {
  function n(r) {
    return t === 1 ? new Ha(r) : new Sg(r, t);
  }
  return n.beta = function(r) {
    return e(+r);
  }, n;
}(0.85);
function da(e, t, n) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - n),
    e._x2,
    e._y2
  );
}
function Pc(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Pc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        da(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        da(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const _S = function e(t) {
  function n(r) {
    return new Pc(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function Uc(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Uc.prototype = {
  areaStart: Dn,
  areaEnd: Dn,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        da(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const ES = function e(t) {
  function n(r) {
    return new Uc(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function Bc(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
Bc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        da(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const SS = function e(t) {
  function n(r) {
    return new Bc(r, t);
  }
  return n.tension = function(r) {
    return e(+r);
  }, n;
}(0);
function Vc(e, t, n) {
  var r = e._x1, i = e._y1, s = e._x2, a = e._y2;
  if (e._l01_a > se) {
    var o = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, l = 3 * e._l01_a * (e._l01_a + e._l12_a);
    r = (r * o - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / l, i = (i * o - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / l;
  }
  if (e._l23_a > se) {
    var c = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, u = 3 * e._l23_a * (e._l23_a + e._l12_a);
    s = (s * c + e._x1 * e._l23_2a - t * e._l12_2a) / u, a = (a * c + e._y1 * e._l23_2a - n * e._l12_2a) / u;
  }
  e._context.bezierCurveTo(r, i, s, a, e._x2, e._y2);
}
function Og(e, t) {
  this._context = e, this._alpha = t;
}
Og.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        Vc(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const OS = function e(t) {
  function n(r) {
    return t ? new Og(r, t) : new Pc(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Tg(e, t) {
  this._context = e, this._alpha = t;
}
Tg.prototype = {
  areaStart: Dn,
  areaEnd: Dn,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = e, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = e, this._y5 = t;
        break;
      default:
        Vc(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const TS = function e(t) {
  function n(r) {
    return t ? new Tg(r, t) : new Uc(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Mg(e, t) {
  this._context = e, this._alpha = t;
}
Mg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var n = this._x2 - e, r = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(n * n + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        Vc(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const MS = function e(t) {
  function n(r) {
    return t ? new Mg(r, t) : new Bc(r, 0);
  }
  return n.alpha = function(r) {
    return e(+r);
  }, n;
}(0.5);
function Cg(e) {
  this._context = e;
}
Cg.prototype = {
  areaStart: Dn,
  areaEnd: Dn,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(e, t) {
    e = +e, t = +t, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
  }
};
function $g(e) {
  return new Cg(e);
}
function Gh(e) {
  return e < 0 ? -1 : 1;
}
function zh(e, t, n) {
  var r = e._x1 - e._x0, i = t - e._x1, s = (e._y1 - e._y0) / (r || i < 0 && -0), a = (n - e._y1) / (i || r < 0 && -0), o = (s * i + a * r) / (r + i);
  return (Gh(s) + Gh(a)) * Math.min(Math.abs(s), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function jh(e, t) {
  var n = e._x1 - e._x0;
  return n ? (3 * (e._y1 - e._y0) / n - t) / 2 : t;
}
function No(e, t, n) {
  var r = e._x0, i = e._y0, s = e._x1, a = e._y1, o = (s - r) / 3;
  e._context.bezierCurveTo(r + o, i + o * t, s - o, a - o * n, s, a);
}
function fa(e) {
  this._context = e;
}
fa.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        No(this, this._t0, jh(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var n = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, No(this, jh(this, n = zh(this, e, t)), n);
          break;
        default:
          No(this, this._t0, n = zh(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = n;
    }
  }
};
function Ag(e) {
  this._context = new Lg(e);
}
(Ag.prototype = Object.create(fa.prototype)).point = function(e, t) {
  fa.prototype.point.call(this, t, e);
};
function Lg(e) {
  this._context = e;
}
Lg.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, n, r, i, s) {
    this._context.bezierCurveTo(t, e, r, n, s, i);
  }
};
function CS(e) {
  return new fa(e);
}
function $S(e) {
  return new Ag(e);
}
function Dg(e) {
  this._context = e;
}
Dg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, n = e.length;
    if (n)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), n === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var r = Wh(e), i = Wh(t), s = 0, a = 1; a < n; ++s, ++a)
          this._context.bezierCurveTo(r[0][s], i[0][s], r[1][s], i[1][s], e[a], t[a]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function Wh(e) {
  var t, n = e.length - 1, r, i = new Array(n), s = new Array(n), a = new Array(n);
  for (i[0] = 0, s[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    i[t] = 1, s[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[n - 1] = 2, s[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1; t < n; ++t)
    r = i[t] / s[t - 1], s[t] -= r, a[t] -= r * a[t - 1];
  for (i[n - 1] = a[n - 1] / s[n - 1], t = n - 2; t >= 0; --t)
    i[t] = (a[t] - i[t + 1]) / s[t];
  for (s[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t)
    s[t] = 2 * e[t + 1] - i[t + 1];
  return [i, s];
}
function AS(e) {
  return new Dg(e);
}
function Fa(e, t) {
  this._context = e, this._t = t;
}
Fa.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var n = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function LS(e) {
  return new Fa(e, 0.5);
}
function DS(e) {
  return new Fa(e, 0);
}
function kS(e) {
  return new Fa(e, 1);
}
function qh(e, t) {
  if ((a = e.length) > 1)
    for (var n = 1, r, i, s = e[t[0]], a, o = s.length; n < a; ++n)
      for (i = s, s = e[t[n]], r = 0; r < o; ++r)
        s[r][1] += s[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1];
}
function Yh(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; )
    n[t] = t;
  return n;
}
function RS(e, t) {
  return e[t];
}
function IS(e) {
  const t = [];
  return t.key = e, t;
}
function Po() {
  var e = ct([]), t = Yh, n = qh, r = RS;
  function i(s) {
    var a = Array.from(e.apply(this, arguments), IS), o, l = a.length, c = -1, u;
    for (const h of s)
      for (o = 0, ++c; o < l; ++o)
        (a[o][c] = [0, +r(h, a[o].key, c, s)]).data = h;
    for (o = 0, u = Ba(t(a)); o < l; ++o)
      a[u[o]].index = o;
    return n(a, u), a;
  }
  return i.keys = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : ct(Array.from(s)), i) : e;
  }, i.value = function(s) {
    return arguments.length ? (r = typeof s == "function" ? s : ct(+s), i) : r;
  }, i.order = function(s) {
    return arguments.length ? (t = s == null ? Yh : typeof s == "function" ? s : ct(Array.from(s)), i) : t;
  }, i.offset = function(s) {
    return arguments.length ? (n = s ?? qh, i) : n;
  }, i;
}
function NS(e, t) {
  if ((l = e.length) > 0)
    for (var n, r = 0, i, s, a, o, l, c = e[t[0]].length; r < c; ++r)
      for (a = o = 0, n = 0; n < l; ++n)
        (s = (i = e[t[n]][r])[1] - i[0]) > 0 ? (i[0] = a, i[1] = a += s) : s < 0 ? (i[1] = o, i[0] = o += s) : (i[0] = 0, i[1] = s);
}
function vi(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
vi.prototype = {
  constructor: vi,
  scale: function(e) {
    return e === 1 ? this : new vi(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new vi(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
vi.prototype;
function Uo(e) {
  return function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.width ? String(t.width) : e.defaultWidth, r = e.formats[n] || e.formats[e.defaultWidth];
    return r;
  };
}
function ni(e) {
  return function(t, n) {
    var r = n != null && n.context ? String(n.context) : "standalone", i;
    if (r === "formatting" && e.formattingValues) {
      var s = e.defaultFormattingWidth || e.defaultWidth, a = n != null && n.width ? String(n.width) : s;
      i = e.formattingValues[a] || e.formattingValues[s];
    } else {
      var o = e.defaultWidth, l = n != null && n.width ? String(n.width) : e.defaultWidth;
      i = e.values[l] || e.values[o];
    }
    var c = e.argumentCallback ? e.argumentCallback(t) : t;
    return i[c];
  };
}
function ri(e) {
  return function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = n.width, i = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth], s = t.match(i);
    if (!s)
      return null;
    var a = s[0], o = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth], l = Array.isArray(o) ? US(o, function(h) {
      return h.test(a);
    }) : PS(o, function(h) {
      return h.test(a);
    }), c;
    c = e.valueCallback ? e.valueCallback(l) : l, c = n.valueCallback ? n.valueCallback(c) : c;
    var u = t.slice(a.length);
    return {
      value: c,
      rest: u
    };
  };
}
function PS(e, t) {
  for (var n in e)
    if (e.hasOwnProperty(n) && t(e[n]))
      return n;
}
function US(e, t) {
  for (var n = 0; n < e.length; n++)
    if (t(e[n]))
      return n;
}
function BS(e) {
  return function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = t.match(e.matchPattern);
    if (!r)
      return null;
    var i = r[0], s = t.match(e.parsePattern);
    if (!s)
      return null;
    var a = e.valueCallback ? e.valueCallback(s[0]) : s[0];
    a = n.valueCallback ? n.valueCallback(a) : a;
    var o = t.slice(i.length);
    return {
      value: a,
      rest: o
    };
  };
}
function pa(e) {
  "@babel/helpers - typeof";
  return pa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, pa(e);
}
function Xt(e) {
  if (e === null || e === !0 || e === !1)
    return NaN;
  var t = Number(e);
  return isNaN(t) ? t : t < 0 ? Math.ceil(t) : Math.floor(t);
}
function ot(e, t) {
  if (t.length < e)
    throw new TypeError(e + " argument" + (e > 1 ? "s" : "") + " required, but only " + t.length + " present");
}
function xt(e) {
  ot(1, arguments);
  var t = Object.prototype.toString.call(e);
  return e instanceof Date || pa(e) === "object" && t === "[object Date]" ? new Date(e.getTime()) : typeof e == "number" || t === "[object Number]" ? new Date(e) : ((typeof e == "string" || t === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), /* @__PURE__ */ new Date(NaN));
}
function Ga(e, t) {
  ot(2, arguments);
  var n = xt(e).getTime(), r = Xt(t);
  return new Date(n + r);
}
var VS = {};
function za() {
  return VS;
}
function Ml(e) {
  var t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
  return t.setUTCFullYear(e.getFullYear()), e.getTime() - t.getTime();
}
function HS(e) {
  return ot(1, arguments), e instanceof Date || pa(e) === "object" && Object.prototype.toString.call(e) === "[object Date]";
}
function FS(e) {
  if (ot(1, arguments), !HS(e) && typeof e != "number")
    return !1;
  var t = xt(e);
  return !isNaN(Number(t));
}
function GS(e, t) {
  ot(2, arguments);
  var n = Xt(t);
  return Ga(e, -n);
}
var zS = 864e5;
function jS(e) {
  ot(1, arguments);
  var t = xt(e), n = t.getTime();
  t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  var r = t.getTime(), i = n - r;
  return Math.floor(i / zS) + 1;
}
function ga(e) {
  ot(1, arguments);
  var t = 1, n = xt(e), r = n.getUTCDay(), i = (r < t ? 7 : 0) + r - t;
  return n.setUTCDate(n.getUTCDate() - i), n.setUTCHours(0, 0, 0, 0), n;
}
function kg(e) {
  ot(1, arguments);
  var t = xt(e), n = t.getUTCFullYear(), r = /* @__PURE__ */ new Date(0);
  r.setUTCFullYear(n + 1, 0, 4), r.setUTCHours(0, 0, 0, 0);
  var i = ga(r), s = /* @__PURE__ */ new Date(0);
  s.setUTCFullYear(n, 0, 4), s.setUTCHours(0, 0, 0, 0);
  var a = ga(s);
  return t.getTime() >= i.getTime() ? n + 1 : t.getTime() >= a.getTime() ? n : n - 1;
}
function WS(e) {
  ot(1, arguments);
  var t = kg(e), n = /* @__PURE__ */ new Date(0);
  n.setUTCFullYear(t, 0, 4), n.setUTCHours(0, 0, 0, 0);
  var r = ga(n);
  return r;
}
var qS = 6048e5;
function YS(e) {
  ot(1, arguments);
  var t = xt(e), n = ga(t).getTime() - WS(t).getTime();
  return Math.round(n / qS) + 1;
}
function ma(e, t) {
  var n, r, i, s, a, o, l, c;
  ot(1, arguments);
  var u = za(), h = Xt((n = (r = (i = (s = t == null ? void 0 : t.weekStartsOn) !== null && s !== void 0 ? s : t == null || (a = t.locale) === null || a === void 0 || (o = a.options) === null || o === void 0 ? void 0 : o.weekStartsOn) !== null && i !== void 0 ? i : u.weekStartsOn) !== null && r !== void 0 ? r : (l = u.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.weekStartsOn) !== null && n !== void 0 ? n : 0);
  if (!(h >= 0 && h <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var d = xt(e), f = d.getUTCDay(), p = (f < h ? 7 : 0) + f - h;
  return d.setUTCDate(d.getUTCDate() - p), d.setUTCHours(0, 0, 0, 0), d;
}
function Rg(e, t) {
  var n, r, i, s, a, o, l, c;
  ot(1, arguments);
  var u = xt(e), h = u.getUTCFullYear(), d = za(), f = Xt((n = (r = (i = (s = t == null ? void 0 : t.firstWeekContainsDate) !== null && s !== void 0 ? s : t == null || (a = t.locale) === null || a === void 0 || (o = a.options) === null || o === void 0 ? void 0 : o.firstWeekContainsDate) !== null && i !== void 0 ? i : d.firstWeekContainsDate) !== null && r !== void 0 ? r : (l = d.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.firstWeekContainsDate) !== null && n !== void 0 ? n : 1);
  if (!(f >= 1 && f <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var p = /* @__PURE__ */ new Date(0);
  p.setUTCFullYear(h + 1, 0, f), p.setUTCHours(0, 0, 0, 0);
  var m = ma(p, t), g = /* @__PURE__ */ new Date(0);
  g.setUTCFullYear(h, 0, f), g.setUTCHours(0, 0, 0, 0);
  var v = ma(g, t);
  return u.getTime() >= m.getTime() ? h + 1 : u.getTime() >= v.getTime() ? h : h - 1;
}
function XS(e, t) {
  var n, r, i, s, a, o, l, c;
  ot(1, arguments);
  var u = za(), h = Xt((n = (r = (i = (s = t == null ? void 0 : t.firstWeekContainsDate) !== null && s !== void 0 ? s : t == null || (a = t.locale) === null || a === void 0 || (o = a.options) === null || o === void 0 ? void 0 : o.firstWeekContainsDate) !== null && i !== void 0 ? i : u.firstWeekContainsDate) !== null && r !== void 0 ? r : (l = u.locale) === null || l === void 0 || (c = l.options) === null || c === void 0 ? void 0 : c.firstWeekContainsDate) !== null && n !== void 0 ? n : 1), d = Rg(e, t), f = /* @__PURE__ */ new Date(0);
  f.setUTCFullYear(d, 0, h), f.setUTCHours(0, 0, 0, 0);
  var p = ma(f, t);
  return p;
}
var ZS = 6048e5;
function KS(e, t) {
  ot(1, arguments);
  var n = xt(e), r = ma(n, t).getTime() - XS(n, t).getTime();
  return Math.round(r / ZS) + 1;
}
function wt(e, t) {
  for (var n = e < 0 ? "-" : "", r = Math.abs(e).toString(); r.length < t; )
    r = "0" + r;
  return n + r;
}
var QS = {
  // Year
  y: function(e, t) {
    var n = e.getUTCFullYear(), r = n > 0 ? n : 1 - n;
    return wt(t === "yy" ? r % 100 : r, t.length);
  },
  // Month
  M: function(e, t) {
    var n = e.getUTCMonth();
    return t === "M" ? String(n + 1) : wt(n + 1, 2);
  },
  // Day of the month
  d: function(e, t) {
    return wt(e.getUTCDate(), t.length);
  },
  // AM or PM
  a: function(e, t) {
    var n = e.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return n.toUpperCase();
      case "aaa":
        return n;
      case "aaaaa":
        return n[0];
      case "aaaa":
      default:
        return n === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function(e, t) {
    return wt(e.getUTCHours() % 12 || 12, t.length);
  },
  // Hour [0-23]
  H: function(e, t) {
    return wt(e.getUTCHours(), t.length);
  },
  // Minute
  m: function(e, t) {
    return wt(e.getUTCMinutes(), t.length);
  },
  // Second
  s: function(e, t) {
    return wt(e.getUTCSeconds(), t.length);
  },
  // Fraction of second
  S: function(e, t) {
    var n = t.length, r = e.getUTCMilliseconds(), i = Math.floor(r * Math.pow(10, n - 3));
    return wt(i, t.length);
  }
};
const Sn = QS;
var fr = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, JS = {
  // Era
  G: function(e, t, n) {
    var r = e.getUTCFullYear() > 0 ? 1 : 0;
    switch (t) {
      case "G":
      case "GG":
      case "GGG":
        return n.era(r, {
          width: "abbreviated"
        });
      case "GGGGG":
        return n.era(r, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return n.era(r, {
          width: "wide"
        });
    }
  },
  // Year
  y: function(e, t, n) {
    if (t === "yo") {
      var r = e.getUTCFullYear(), i = r > 0 ? r : 1 - r;
      return n.ordinalNumber(i, {
        unit: "year"
      });
    }
    return Sn.y(e, t);
  },
  // Local week-numbering year
  Y: function(e, t, n, r) {
    var i = Rg(e, r), s = i > 0 ? i : 1 - i;
    if (t === "YY") {
      var a = s % 100;
      return wt(a, 2);
    }
    return t === "Yo" ? n.ordinalNumber(s, {
      unit: "year"
    }) : wt(s, t.length);
  },
  // ISO week-numbering year
  R: function(e, t) {
    var n = kg(e);
    return wt(n, t.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(e, t) {
    var n = e.getUTCFullYear();
    return wt(n, t.length);
  },
  // Quarter
  Q: function(e, t, n) {
    var r = Math.ceil((e.getUTCMonth() + 1) / 3);
    switch (t) {
      case "Q":
        return String(r);
      case "QQ":
        return wt(r, 2);
      case "Qo":
        return n.ordinalNumber(r, {
          unit: "quarter"
        });
      case "QQQ":
        return n.quarter(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return n.quarter(r, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(e, t, n) {
    var r = Math.ceil((e.getUTCMonth() + 1) / 3);
    switch (t) {
      case "q":
        return String(r);
      case "qq":
        return wt(r, 2);
      case "qo":
        return n.ordinalNumber(r, {
          unit: "quarter"
        });
      case "qqq":
        return n.quarter(r, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return n.quarter(r, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return n.quarter(r, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(e, t, n) {
    var r = e.getUTCMonth();
    switch (t) {
      case "M":
      case "MM":
        return Sn.M(e, t);
      case "Mo":
        return n.ordinalNumber(r + 1, {
          unit: "month"
        });
      case "MMM":
        return n.month(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return n.month(r, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return n.month(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function(e, t, n) {
    var r = e.getUTCMonth();
    switch (t) {
      case "L":
        return String(r + 1);
      case "LL":
        return wt(r + 1, 2);
      case "Lo":
        return n.ordinalNumber(r + 1, {
          unit: "month"
        });
      case "LLL":
        return n.month(r, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return n.month(r, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return n.month(r, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function(e, t, n, r) {
    var i = KS(e, r);
    return t === "wo" ? n.ordinalNumber(i, {
      unit: "week"
    }) : wt(i, t.length);
  },
  // ISO week of year
  I: function(e, t, n) {
    var r = YS(e);
    return t === "Io" ? n.ordinalNumber(r, {
      unit: "week"
    }) : wt(r, t.length);
  },
  // Day of the month
  d: function(e, t, n) {
    return t === "do" ? n.ordinalNumber(e.getUTCDate(), {
      unit: "date"
    }) : Sn.d(e, t);
  },
  // Day of year
  D: function(e, t, n) {
    var r = jS(e);
    return t === "Do" ? n.ordinalNumber(r, {
      unit: "dayOfYear"
    }) : wt(r, t.length);
  },
  // Day of week
  E: function(e, t, n) {
    var r = e.getUTCDay();
    switch (t) {
      case "E":
      case "EE":
      case "EEE":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return n.day(r, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return n.day(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(e, t, n, r) {
    var i = e.getUTCDay(), s = (i - r.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      case "e":
        return String(s);
      case "ee":
        return wt(s, 2);
      case "eo":
        return n.ordinalNumber(s, {
          unit: "day"
        });
      case "eee":
        return n.day(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return n.day(i, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return n.day(i, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return n.day(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(e, t, n, r) {
    var i = e.getUTCDay(), s = (i - r.weekStartsOn + 8) % 7 || 7;
    switch (t) {
      case "c":
        return String(s);
      case "cc":
        return wt(s, t.length);
      case "co":
        return n.ordinalNumber(s, {
          unit: "day"
        });
      case "ccc":
        return n.day(i, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return n.day(i, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return n.day(i, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return n.day(i, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(e, t, n) {
    var r = e.getUTCDay(), i = r === 0 ? 7 : r;
    switch (t) {
      case "i":
        return String(i);
      case "ii":
        return wt(i, t.length);
      case "io":
        return n.ordinalNumber(i, {
          unit: "day"
        });
      case "iii":
        return n.day(r, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return n.day(r, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return n.day(r, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return n.day(r, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(e, t, n) {
    var r = e.getUTCHours(), i = r / 12 >= 1 ? "pm" : "am";
    switch (t) {
      case "a":
      case "aa":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return n.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return n.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(e, t, n) {
    var r = e.getUTCHours(), i;
    switch (r === 12 ? i = fr.noon : r === 0 ? i = fr.midnight : i = r / 12 >= 1 ? "pm" : "am", t) {
      case "b":
      case "bb":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return n.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return n.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(e, t, n) {
    var r = e.getUTCHours(), i;
    switch (r >= 17 ? i = fr.evening : r >= 12 ? i = fr.afternoon : r >= 4 ? i = fr.morning : i = fr.night, t) {
      case "B":
      case "BB":
      case "BBB":
        return n.dayPeriod(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return n.dayPeriod(i, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return n.dayPeriod(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(e, t, n) {
    if (t === "ho") {
      var r = e.getUTCHours() % 12;
      return r === 0 && (r = 12), n.ordinalNumber(r, {
        unit: "hour"
      });
    }
    return Sn.h(e, t);
  },
  // Hour [0-23]
  H: function(e, t, n) {
    return t === "Ho" ? n.ordinalNumber(e.getUTCHours(), {
      unit: "hour"
    }) : Sn.H(e, t);
  },
  // Hour [0-11]
  K: function(e, t, n) {
    var r = e.getUTCHours() % 12;
    return t === "Ko" ? n.ordinalNumber(r, {
      unit: "hour"
    }) : wt(r, t.length);
  },
  // Hour [1-24]
  k: function(e, t, n) {
    var r = e.getUTCHours();
    return r === 0 && (r = 24), t === "ko" ? n.ordinalNumber(r, {
      unit: "hour"
    }) : wt(r, t.length);
  },
  // Minute
  m: function(e, t, n) {
    return t === "mo" ? n.ordinalNumber(e.getUTCMinutes(), {
      unit: "minute"
    }) : Sn.m(e, t);
  },
  // Second
  s: function(e, t, n) {
    return t === "so" ? n.ordinalNumber(e.getUTCSeconds(), {
      unit: "second"
    }) : Sn.s(e, t);
  },
  // Fraction of second
  S: function(e, t) {
    return Sn.S(e, t);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(e, t, n, r) {
    var i = r._originalDate || e, s = i.getTimezoneOffset();
    if (s === 0)
      return "Z";
    switch (t) {
      case "X":
        return Zh(s);
      case "XXXX":
      case "XX":
        return Bn(s);
      case "XXXXX":
      case "XXX":
      default:
        return Bn(s, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(e, t, n, r) {
    var i = r._originalDate || e, s = i.getTimezoneOffset();
    switch (t) {
      case "x":
        return Zh(s);
      case "xxxx":
      case "xx":
        return Bn(s);
      case "xxxxx":
      case "xxx":
      default:
        return Bn(s, ":");
    }
  },
  // Timezone (GMT)
  O: function(e, t, n, r) {
    var i = r._originalDate || e, s = i.getTimezoneOffset();
    switch (t) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + Xh(s, ":");
      case "OOOO":
      default:
        return "GMT" + Bn(s, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(e, t, n, r) {
    var i = r._originalDate || e, s = i.getTimezoneOffset();
    switch (t) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + Xh(s, ":");
      case "zzzz":
      default:
        return "GMT" + Bn(s, ":");
    }
  },
  // Seconds timestamp
  t: function(e, t, n, r) {
    var i = r._originalDate || e, s = Math.floor(i.getTime() / 1e3);
    return wt(s, t.length);
  },
  // Milliseconds timestamp
  T: function(e, t, n, r) {
    var i = r._originalDate || e, s = i.getTime();
    return wt(s, t.length);
  }
};
function Xh(e, t) {
  var n = e > 0 ? "-" : "+", r = Math.abs(e), i = Math.floor(r / 60), s = r % 60;
  if (s === 0)
    return n + String(i);
  var a = t || "";
  return n + String(i) + a + wt(s, 2);
}
function Zh(e, t) {
  if (e % 60 === 0) {
    var n = e > 0 ? "-" : "+";
    return n + wt(Math.abs(e) / 60, 2);
  }
  return Bn(e, t);
}
function Bn(e, t) {
  var n = t || "", r = e > 0 ? "-" : "+", i = Math.abs(e), s = wt(Math.floor(i / 60), 2), a = wt(i % 60, 2);
  return r + s + n + a;
}
const tO = JS;
var Kh = function(e, t) {
  switch (e) {
    case "P":
      return t.date({
        width: "short"
      });
    case "PP":
      return t.date({
        width: "medium"
      });
    case "PPP":
      return t.date({
        width: "long"
      });
    case "PPPP":
    default:
      return t.date({
        width: "full"
      });
  }
}, Ig = function(e, t) {
  switch (e) {
    case "p":
      return t.time({
        width: "short"
      });
    case "pp":
      return t.time({
        width: "medium"
      });
    case "ppp":
      return t.time({
        width: "long"
      });
    case "pppp":
    default:
      return t.time({
        width: "full"
      });
  }
}, eO = function(e, t) {
  var n = e.match(/(P+)(p+)?/) || [], r = n[1], i = n[2];
  if (!i)
    return Kh(e, t);
  var s;
  switch (r) {
    case "P":
      s = t.dateTime({
        width: "short"
      });
      break;
    case "PP":
      s = t.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      s = t.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      s = t.dateTime({
        width: "full"
      });
      break;
  }
  return s.replace("{{date}}", Kh(r, t)).replace("{{time}}", Ig(i, t));
}, nO = {
  p: Ig,
  P: eO
};
const rO = nO;
var iO = ["D", "DD"], sO = ["YY", "YYYY"];
function aO(e) {
  return iO.indexOf(e) !== -1;
}
function oO(e) {
  return sO.indexOf(e) !== -1;
}
function Qh(e, t, n) {
  if (e === "YYYY")
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(t, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "YY")
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(t, "`) for formatting years to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "D")
    throw new RangeError("Use `d` instead of `D` (in `".concat(t, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (e === "DD")
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(t, "`) for formatting days of the month to the input `").concat(n, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
}
var lO = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, cO = function(e, t, n) {
  var r, i = lO[e];
  return typeof i == "string" ? r = i : t === 1 ? r = i.one : r = i.other.replace("{{count}}", t.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + r : r + " ago" : r;
};
const uO = cO;
var hO = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, dO = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, fO = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, pO = {
  date: Uo({
    formats: hO,
    defaultWidth: "full"
  }),
  time: Uo({
    formats: dO,
    defaultWidth: "full"
  }),
  dateTime: Uo({
    formats: fO,
    defaultWidth: "full"
  })
};
const gO = pO;
var mO = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, vO = function(e, t, n, r) {
  return mO[e];
};
const yO = vO;
var xO = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, bO = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, wO = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}, _O = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}, EO = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, SO = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, OO = function(e, t) {
  var n = Number(e), r = n % 100;
  if (r > 20 || r < 10)
    switch (r % 10) {
      case 1:
        return n + "st";
      case 2:
        return n + "nd";
      case 3:
        return n + "rd";
    }
  return n + "th";
}, TO = {
  ordinalNumber: OO,
  era: ni({
    values: xO,
    defaultWidth: "wide"
  }),
  quarter: ni({
    values: bO,
    defaultWidth: "wide",
    argumentCallback: function(e) {
      return e - 1;
    }
  }),
  month: ni({
    values: wO,
    defaultWidth: "wide"
  }),
  day: ni({
    values: _O,
    defaultWidth: "wide"
  }),
  dayPeriod: ni({
    values: EO,
    defaultWidth: "wide",
    formattingValues: SO,
    defaultFormattingWidth: "wide"
  })
};
const MO = TO;
var CO = /^(\d+)(th|st|nd|rd)?/i, $O = /\d+/i, AO = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, LO = {
  any: [/^b/i, /^(a|c)/i]
}, DO = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, kO = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, RO = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, IO = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}, NO = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, PO = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, UO = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, BO = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, VO = {
  ordinalNumber: BS({
    matchPattern: CO,
    parsePattern: $O,
    valueCallback: function(e) {
      return parseInt(e, 10);
    }
  }),
  era: ri({
    matchPatterns: AO,
    defaultMatchWidth: "wide",
    parsePatterns: LO,
    defaultParseWidth: "any"
  }),
  quarter: ri({
    matchPatterns: DO,
    defaultMatchWidth: "wide",
    parsePatterns: kO,
    defaultParseWidth: "any",
    valueCallback: function(e) {
      return e + 1;
    }
  }),
  month: ri({
    matchPatterns: RO,
    defaultMatchWidth: "wide",
    parsePatterns: IO,
    defaultParseWidth: "any"
  }),
  day: ri({
    matchPatterns: NO,
    defaultMatchWidth: "wide",
    parsePatterns: PO,
    defaultParseWidth: "any"
  }),
  dayPeriod: ri({
    matchPatterns: UO,
    defaultMatchWidth: "any",
    parsePatterns: BO,
    defaultParseWidth: "any"
  })
};
const HO = VO;
var FO = {
  code: "en-US",
  formatDistance: uO,
  formatLong: gO,
  formatRelative: yO,
  localize: MO,
  match: HO,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const Ng = FO;
var GO = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, zO = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, jO = /^'([^]*?)'?$/, WO = /''/g, qO = /[a-zA-Z]/;
function Vr(e, t, n) {
  var r, i, s, a, o, l, c, u, h, d, f, p, m, g, v, y, x, S;
  ot(2, arguments);
  var _ = String(t), E = za(), T = (r = (i = n == null ? void 0 : n.locale) !== null && i !== void 0 ? i : E.locale) !== null && r !== void 0 ? r : Ng, k = Xt((s = (a = (o = (l = n == null ? void 0 : n.firstWeekContainsDate) !== null && l !== void 0 ? l : n == null || (c = n.locale) === null || c === void 0 || (u = c.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && o !== void 0 ? o : E.firstWeekContainsDate) !== null && a !== void 0 ? a : (h = E.locale) === null || h === void 0 || (d = h.options) === null || d === void 0 ? void 0 : d.firstWeekContainsDate) !== null && s !== void 0 ? s : 1);
  if (!(k >= 1 && k <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var N = Xt((f = (p = (m = (g = n == null ? void 0 : n.weekStartsOn) !== null && g !== void 0 ? g : n == null || (v = n.locale) === null || v === void 0 || (y = v.options) === null || y === void 0 ? void 0 : y.weekStartsOn) !== null && m !== void 0 ? m : E.weekStartsOn) !== null && p !== void 0 ? p : (x = E.locale) === null || x === void 0 || (S = x.options) === null || S === void 0 ? void 0 : S.weekStartsOn) !== null && f !== void 0 ? f : 0);
  if (!(N >= 0 && N <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  if (!T.localize)
    throw new RangeError("locale must contain localize property");
  if (!T.formatLong)
    throw new RangeError("locale must contain formatLong property");
  var L = xt(e);
  if (!FS(L))
    throw new RangeError("Invalid time value");
  var C = Ml(L), V = GS(L, C), M = {
    firstWeekContainsDate: k,
    weekStartsOn: N,
    locale: T,
    _originalDate: L
  }, A = _.match(zO).map(function(w) {
    var P = w[0];
    if (P === "p" || P === "P") {
      var U = rO[P];
      return U(w, T.formatLong);
    }
    return w;
  }).join("").match(GO).map(function(w) {
    if (w === "''")
      return "'";
    var P = w[0];
    if (P === "'")
      return YO(w);
    var U = tO[P];
    if (U)
      return !(n != null && n.useAdditionalWeekYearTokens) && oO(w) && Qh(w, t, String(e)), !(n != null && n.useAdditionalDayOfYearTokens) && aO(w) && Qh(w, t, String(e)), U(V, w, T.localize, M);
    if (P.match(qO))
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + P + "`");
    return w;
  }).join("");
  return A;
}
function YO(e) {
  var t = e.match(jO);
  return t ? t[1].replace(WO, "'") : e;
}
var XO = typeof global == "object" && global && global.Object === Object && global;
const Pg = XO;
var ZO = typeof self == "object" && self && self.Object === Object && self, KO = Pg || ZO || Function("return this")();
const He = KO;
var QO = He.Symbol;
const $e = QO;
var Ug = Object.prototype, JO = Ug.hasOwnProperty, tT = Ug.toString, ii = $e ? $e.toStringTag : void 0;
function eT(e) {
  var t = JO.call(e, ii), n = e[ii];
  try {
    e[ii] = void 0;
    var r = !0;
  } catch {
  }
  var i = tT.call(e);
  return r && (t ? e[ii] = n : delete e[ii]), i;
}
var nT = Object.prototype, rT = nT.toString;
function iT(e) {
  return rT.call(e);
}
var sT = "[object Null]", aT = "[object Undefined]", Jh = $e ? $e.toStringTag : void 0;
function rr(e) {
  return e == null ? e === void 0 ? aT : sT : Jh && Jh in Object(e) ? eT(e) : iT(e);
}
function Ke(e) {
  return e != null && typeof e == "object";
}
var oT = "[object Symbol]";
function ja(e) {
  return typeof e == "symbol" || Ke(e) && rr(e) == oT;
}
function Bg(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )
    i[n] = t(e[n], n, e);
  return i;
}
var lT = Array.isArray;
const ee = lT;
var cT = 1 / 0, td = $e ? $e.prototype : void 0, ed = td ? td.toString : void 0;
function Vg(e) {
  if (typeof e == "string")
    return e;
  if (ee(e))
    return Bg(e, Vg) + "";
  if (ja(e))
    return ed ? ed.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -cT ? "-0" : t;
}
function Ae(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
function Hc(e) {
  return e;
}
var uT = "[object AsyncFunction]", hT = "[object Function]", dT = "[object GeneratorFunction]", fT = "[object Proxy]";
function Fc(e) {
  if (!Ae(e))
    return !1;
  var t = rr(e);
  return t == hT || t == dT || t == uT || t == fT;
}
var pT = He["__core-js_shared__"];
const Bo = pT;
var nd = function() {
  var e = /[^.]+$/.exec(Bo && Bo.keys && Bo.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function gT(e) {
  return !!nd && nd in e;
}
var mT = Function.prototype, vT = mT.toString;
function ir(e) {
  if (e != null) {
    try {
      return vT.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var yT = /[\\^$.*+?()[\]{}|]/g, xT = /^\[object .+?Constructor\]$/, bT = Function.prototype, wT = Object.prototype, _T = bT.toString, ET = wT.hasOwnProperty, ST = RegExp(
  "^" + _T.call(ET).replace(yT, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function OT(e) {
  if (!Ae(e) || gT(e))
    return !1;
  var t = Fc(e) ? ST : xT;
  return t.test(ir(e));
}
function TT(e, t) {
  return e == null ? void 0 : e[t];
}
function sr(e, t) {
  var n = TT(e, t);
  return OT(n) ? n : void 0;
}
var MT = sr(He, "WeakMap");
const Cl = MT;
var rd = Object.create, CT = function() {
  function e() {
  }
  return function(t) {
    if (!Ae(t))
      return {};
    if (rd)
      return rd(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
const $T = CT;
function AT(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function LT() {
}
function Hg(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
var DT = 800, kT = 16, RT = Date.now;
function IT(e) {
  var t = 0, n = 0;
  return function() {
    var r = RT(), i = kT - (r - n);
    if (n = r, i > 0) {
      if (++t >= DT)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function NT(e) {
  return function() {
    return e;
  };
}
var PT = function() {
  try {
    var e = sr(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}();
const va = PT;
var UT = va ? function(e, t) {
  return va(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: NT(t),
    writable: !0
  });
} : Hc;
const BT = UT;
var VT = IT(BT);
const HT = VT;
function FT(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
    ;
  return e;
}
function GT(e, t, n, r) {
  for (var i = e.length, s = n + (r ? 1 : -1); r ? s-- : ++s < i; )
    if (t(e[s], s, e))
      return s;
  return -1;
}
function zT(e) {
  return e !== e;
}
function jT(e, t, n) {
  for (var r = n - 1, i = e.length; ++r < i; )
    if (e[r] === t)
      return r;
  return -1;
}
function WT(e, t, n) {
  return t === t ? jT(e, t, n) : GT(e, zT, n);
}
function qT(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && WT(e, t, 0) > -1;
}
var YT = 9007199254740991, XT = /^(?:0|[1-9]\d*)$/;
function Gc(e, t) {
  var n = typeof e;
  return t = t ?? YT, !!t && (n == "number" || n != "symbol" && XT.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function Wa(e, t, n) {
  t == "__proto__" && va ? va(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function Qi(e, t) {
  return e === t || e !== e && t !== t;
}
var ZT = Object.prototype, KT = ZT.hasOwnProperty;
function Fg(e, t, n) {
  var r = e[t];
  (!(KT.call(e, t) && Qi(r, n)) || n === void 0 && !(t in e)) && Wa(e, t, n);
}
function Ji(e, t, n, r) {
  var i = !n;
  n || (n = {});
  for (var s = -1, a = t.length; ++s < a; ) {
    var o = t[s], l = r ? r(n[o], e[o], o, n, e) : void 0;
    l === void 0 && (l = e[o]), i ? Wa(n, o, l) : Fg(n, o, l);
  }
  return n;
}
var id = Math.max;
function QT(e, t, n) {
  return t = id(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, i = -1, s = id(r.length - t, 0), a = Array(s); ++i < s; )
      a[i] = r[t + i];
    i = -1;
    for (var o = Array(t + 1); ++i < t; )
      o[i] = r[i];
    return o[t] = n(a), AT(e, this, o);
  };
}
function Gg(e, t) {
  return HT(QT(e, t, Hc), e + "");
}
var JT = 9007199254740991;
function zc(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= JT;
}
function ar(e) {
  return e != null && zc(e.length) && !Fc(e);
}
function zg(e, t, n) {
  if (!Ae(n))
    return !1;
  var r = typeof t;
  return (r == "number" ? ar(n) && Gc(t, n.length) : r == "string" && t in n) ? Qi(n[t], e) : !1;
}
function tM(e) {
  return Gg(function(t, n) {
    var r = -1, i = n.length, s = i > 1 ? n[i - 1] : void 0, a = i > 2 ? n[2] : void 0;
    for (s = e.length > 3 && typeof s == "function" ? (i--, s) : void 0, a && zg(n[0], n[1], a) && (s = i < 3 ? void 0 : s, i = 1), t = Object(t); ++r < i; ) {
      var o = n[r];
      o && e(t, o, r, s);
    }
    return t;
  });
}
var eM = Object.prototype;
function qa(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || eM;
  return e === n;
}
function nM(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var rM = "[object Arguments]";
function sd(e) {
  return Ke(e) && rr(e) == rM;
}
var jg = Object.prototype, iM = jg.hasOwnProperty, sM = jg.propertyIsEnumerable, aM = sd(function() {
  return arguments;
}()) ? sd : function(e) {
  return Ke(e) && iM.call(e, "callee") && !sM.call(e, "callee");
};
const Hr = aM;
function oM() {
  return !1;
}
var Wg = typeof exports == "object" && exports && !exports.nodeType && exports, ad = Wg && typeof module == "object" && module && !module.nodeType && module, lM = ad && ad.exports === Wg, od = lM ? He.Buffer : void 0, cM = od ? od.isBuffer : void 0, uM = cM || oM;
const Fr = uM;
var hM = "[object Arguments]", dM = "[object Array]", fM = "[object Boolean]", pM = "[object Date]", gM = "[object Error]", mM = "[object Function]", vM = "[object Map]", yM = "[object Number]", xM = "[object Object]", bM = "[object RegExp]", wM = "[object Set]", _M = "[object String]", EM = "[object WeakMap]", SM = "[object ArrayBuffer]", OM = "[object DataView]", TM = "[object Float32Array]", MM = "[object Float64Array]", CM = "[object Int8Array]", $M = "[object Int16Array]", AM = "[object Int32Array]", LM = "[object Uint8Array]", DM = "[object Uint8ClampedArray]", kM = "[object Uint16Array]", RM = "[object Uint32Array]", kt = {};
kt[TM] = kt[MM] = kt[CM] = kt[$M] = kt[AM] = kt[LM] = kt[DM] = kt[kM] = kt[RM] = !0;
kt[hM] = kt[dM] = kt[SM] = kt[fM] = kt[OM] = kt[pM] = kt[gM] = kt[mM] = kt[vM] = kt[yM] = kt[xM] = kt[bM] = kt[wM] = kt[_M] = kt[EM] = !1;
function IM(e) {
  return Ke(e) && zc(e.length) && !!kt[rr(e)];
}
function jc(e) {
  return function(t) {
    return e(t);
  };
}
var qg = typeof exports == "object" && exports && !exports.nodeType && exports, Ci = qg && typeof module == "object" && module && !module.nodeType && module, NM = Ci && Ci.exports === qg, Vo = NM && Pg.process, PM = function() {
  try {
    var e = Ci && Ci.require && Ci.require("util").types;
    return e || Vo && Vo.binding && Vo.binding("util");
  } catch {
  }
}();
const Gr = PM;
var ld = Gr && Gr.isTypedArray, UM = ld ? jc(ld) : IM;
const Ya = UM;
var BM = Object.prototype, VM = BM.hasOwnProperty;
function Yg(e, t) {
  var n = ee(e), r = !n && Hr(e), i = !n && !r && Fr(e), s = !n && !r && !i && Ya(e), a = n || r || i || s, o = a ? nM(e.length, String) : [], l = o.length;
  for (var c in e)
    (t || VM.call(e, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    Gc(c, l))) && o.push(c);
  return o;
}
function Xg(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var HM = Xg(Object.keys, Object);
const FM = HM;
var GM = Object.prototype, zM = GM.hasOwnProperty;
function Zg(e) {
  if (!qa(e))
    return FM(e);
  var t = [];
  for (var n in Object(e))
    zM.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function ts(e) {
  return ar(e) ? Yg(e) : Zg(e);
}
function jM(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var WM = Object.prototype, qM = WM.hasOwnProperty;
function YM(e) {
  if (!Ae(e))
    return jM(e);
  var t = qa(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !qM.call(e, r)) || n.push(r);
  return n;
}
function es(e) {
  return ar(e) ? Yg(e, !0) : YM(e);
}
var XM = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, ZM = /^\w*$/;
function Wc(e, t) {
  if (ee(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || ja(e) ? !0 : ZM.test(e) || !XM.test(e) || t != null && e in Object(t);
}
var KM = sr(Object, "create");
const Vi = KM;
function QM() {
  this.__data__ = Vi ? Vi(null) : {}, this.size = 0;
}
function JM(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var tC = "__lodash_hash_undefined__", eC = Object.prototype, nC = eC.hasOwnProperty;
function rC(e) {
  var t = this.__data__;
  if (Vi) {
    var n = t[e];
    return n === tC ? void 0 : n;
  }
  return nC.call(t, e) ? t[e] : void 0;
}
var iC = Object.prototype, sC = iC.hasOwnProperty;
function aC(e) {
  var t = this.__data__;
  return Vi ? t[e] !== void 0 : sC.call(t, e);
}
var oC = "__lodash_hash_undefined__";
function lC(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = Vi && t === void 0 ? oC : t, this;
}
function Jn(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Jn.prototype.clear = QM;
Jn.prototype.delete = JM;
Jn.prototype.get = rC;
Jn.prototype.has = aC;
Jn.prototype.set = lC;
function cC() {
  this.__data__ = [], this.size = 0;
}
function Xa(e, t) {
  for (var n = e.length; n--; )
    if (Qi(e[n][0], t))
      return n;
  return -1;
}
var uC = Array.prototype, hC = uC.splice;
function dC(e) {
  var t = this.__data__, n = Xa(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : hC.call(t, n, 1), --this.size, !0;
}
function fC(e) {
  var t = this.__data__, n = Xa(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function pC(e) {
  return Xa(this.__data__, e) > -1;
}
function gC(e, t) {
  var n = this.__data__, r = Xa(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
function wn(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
wn.prototype.clear = cC;
wn.prototype.delete = dC;
wn.prototype.get = fC;
wn.prototype.has = pC;
wn.prototype.set = gC;
var mC = sr(He, "Map");
const Hi = mC;
function vC() {
  this.size = 0, this.__data__ = {
    hash: new Jn(),
    map: new (Hi || wn)(),
    string: new Jn()
  };
}
function yC(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Za(e, t) {
  var n = e.__data__;
  return yC(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function xC(e) {
  var t = Za(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function bC(e) {
  return Za(this, e).get(e);
}
function wC(e) {
  return Za(this, e).has(e);
}
function _C(e, t) {
  var n = Za(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
function _n(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
_n.prototype.clear = vC;
_n.prototype.delete = xC;
_n.prototype.get = bC;
_n.prototype.has = wC;
_n.prototype.set = _C;
var EC = "Expected a function";
function qc(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(EC);
  var n = function() {
    var r = arguments, i = t ? t.apply(this, r) : r[0], s = n.cache;
    if (s.has(i))
      return s.get(i);
    var a = e.apply(this, r);
    return n.cache = s.set(i, a) || s, a;
  };
  return n.cache = new (qc.Cache || _n)(), n;
}
qc.Cache = _n;
var SC = 500;
function OC(e) {
  var t = qc(e, function(r) {
    return n.size === SC && n.clear(), r;
  }), n = t.cache;
  return t;
}
var TC = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, MC = /\\(\\)?/g, CC = OC(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(TC, function(n, r, i, s) {
    t.push(i ? s.replace(MC, "$1") : r || n);
  }), t;
});
const $C = CC;
function ns(e) {
  return e == null ? "" : Vg(e);
}
function Kg(e, t) {
  return ee(e) ? e : Wc(e, t) ? [e] : $C(ns(e));
}
var AC = 1 / 0;
function Ka(e) {
  if (typeof e == "string" || ja(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -AC ? "-0" : t;
}
function Qg(e, t) {
  t = Kg(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[Ka(t[n++])];
  return n && n == r ? e : void 0;
}
function At(e, t, n) {
  var r = e == null ? void 0 : Qg(e, t);
  return r === void 0 ? n : r;
}
function Yc(e, t) {
  for (var n = -1, r = t.length, i = e.length; ++n < r; )
    e[i + n] = t[n];
  return e;
}
var cd = $e ? $e.isConcatSpreadable : void 0;
function LC(e) {
  return ee(e) || Hr(e) || !!(cd && e && e[cd]);
}
function Qa(e, t, n, r, i) {
  var s = -1, a = e.length;
  for (n || (n = LC), i || (i = []); ++s < a; ) {
    var o = e[s];
    t > 0 && n(o) ? t > 1 ? Qa(o, t - 1, n, r, i) : Yc(i, o) : r || (i[i.length] = o);
  }
  return i;
}
var DC = Xg(Object.getPrototypeOf, Object);
const Xc = DC;
var kC = "[object Object]", RC = Function.prototype, IC = Object.prototype, Jg = RC.toString, NC = IC.hasOwnProperty, PC = Jg.call(Object);
function UC(e) {
  if (!Ke(e) || rr(e) != kC)
    return !1;
  var t = Xc(e);
  if (t === null)
    return !0;
  var n = NC.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && Jg.call(n) == PC;
}
function BC() {
  this.__data__ = new wn(), this.size = 0;
}
function VC(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function HC(e) {
  return this.__data__.get(e);
}
function FC(e) {
  return this.__data__.has(e);
}
var GC = 200;
function zC(e, t) {
  var n = this.__data__;
  if (n instanceof wn) {
    var r = n.__data__;
    if (!Hi || r.length < GC - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new _n(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Pe(e) {
  var t = this.__data__ = new wn(e);
  this.size = t.size;
}
Pe.prototype.clear = BC;
Pe.prototype.delete = VC;
Pe.prototype.get = HC;
Pe.prototype.has = FC;
Pe.prototype.set = zC;
function jC(e, t) {
  return e && Ji(t, ts(t), e);
}
function WC(e, t) {
  return e && Ji(t, es(t), e);
}
var tm = typeof exports == "object" && exports && !exports.nodeType && exports, ud = tm && typeof module == "object" && module && !module.nodeType && module, qC = ud && ud.exports === tm, hd = qC ? He.Buffer : void 0, dd = hd ? hd.allocUnsafe : void 0;
function em(e, t) {
  if (t)
    return e.slice();
  var n = e.length, r = dd ? dd(n) : new e.constructor(n);
  return e.copy(r), r;
}
function YC(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = 0, s = []; ++n < r; ) {
    var a = e[n];
    t(a, n, e) && (s[i++] = a);
  }
  return s;
}
function nm() {
  return [];
}
var XC = Object.prototype, ZC = XC.propertyIsEnumerable, fd = Object.getOwnPropertySymbols, KC = fd ? function(e) {
  return e == null ? [] : (e = Object(e), YC(fd(e), function(t) {
    return ZC.call(e, t);
  }));
} : nm;
const Zc = KC;
function QC(e, t) {
  return Ji(e, Zc(e), t);
}
var JC = Object.getOwnPropertySymbols, t$ = JC ? function(e) {
  for (var t = []; e; )
    Yc(t, Zc(e)), e = Xc(e);
  return t;
} : nm;
const rm = t$;
function e$(e, t) {
  return Ji(e, rm(e), t);
}
function im(e, t, n) {
  var r = t(e);
  return ee(e) ? r : Yc(r, n(e));
}
function $l(e) {
  return im(e, ts, Zc);
}
function n$(e) {
  return im(e, es, rm);
}
var r$ = sr(He, "DataView");
const Al = r$;
var i$ = sr(He, "Promise");
const Ll = i$;
var s$ = sr(He, "Set");
const Ar = s$;
var pd = "[object Map]", a$ = "[object Object]", gd = "[object Promise]", md = "[object Set]", vd = "[object WeakMap]", yd = "[object DataView]", o$ = ir(Al), l$ = ir(Hi), c$ = ir(Ll), u$ = ir(Ar), h$ = ir(Cl), Vn = rr;
(Al && Vn(new Al(new ArrayBuffer(1))) != yd || Hi && Vn(new Hi()) != pd || Ll && Vn(Ll.resolve()) != gd || Ar && Vn(new Ar()) != md || Cl && Vn(new Cl()) != vd) && (Vn = function(e) {
  var t = rr(e), n = t == a$ ? e.constructor : void 0, r = n ? ir(n) : "";
  if (r)
    switch (r) {
      case o$:
        return yd;
      case l$:
        return pd;
      case c$:
        return gd;
      case u$:
        return md;
      case h$:
        return vd;
    }
  return t;
});
const zr = Vn;
var d$ = Object.prototype, f$ = d$.hasOwnProperty;
function p$(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && f$.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var g$ = He.Uint8Array;
const ya = g$;
function Kc(e) {
  var t = new e.constructor(e.byteLength);
  return new ya(t).set(new ya(e)), t;
}
function m$(e, t) {
  var n = t ? Kc(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var v$ = /\w*$/;
function y$(e) {
  var t = new e.constructor(e.source, v$.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var xd = $e ? $e.prototype : void 0, bd = xd ? xd.valueOf : void 0;
function x$(e) {
  return bd ? Object(bd.call(e)) : {};
}
function sm(e, t) {
  var n = t ? Kc(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var b$ = "[object Boolean]", w$ = "[object Date]", _$ = "[object Map]", E$ = "[object Number]", S$ = "[object RegExp]", O$ = "[object Set]", T$ = "[object String]", M$ = "[object Symbol]", C$ = "[object ArrayBuffer]", $$ = "[object DataView]", A$ = "[object Float32Array]", L$ = "[object Float64Array]", D$ = "[object Int8Array]", k$ = "[object Int16Array]", R$ = "[object Int32Array]", I$ = "[object Uint8Array]", N$ = "[object Uint8ClampedArray]", P$ = "[object Uint16Array]", U$ = "[object Uint32Array]";
function B$(e, t, n) {
  var r = e.constructor;
  switch (t) {
    case C$:
      return Kc(e);
    case b$:
    case w$:
      return new r(+e);
    case $$:
      return m$(e, n);
    case A$:
    case L$:
    case D$:
    case k$:
    case R$:
    case I$:
    case N$:
    case P$:
    case U$:
      return sm(e, n);
    case _$:
      return new r();
    case E$:
    case T$:
      return new r(e);
    case S$:
      return y$(e);
    case O$:
      return new r();
    case M$:
      return x$(e);
  }
}
function am(e) {
  return typeof e.constructor == "function" && !qa(e) ? $T(Xc(e)) : {};
}
var V$ = "[object Map]";
function H$(e) {
  return Ke(e) && zr(e) == V$;
}
var wd = Gr && Gr.isMap, F$ = wd ? jc(wd) : H$;
const G$ = F$;
var z$ = "[object Set]";
function j$(e) {
  return Ke(e) && zr(e) == z$;
}
var _d = Gr && Gr.isSet, W$ = _d ? jc(_d) : j$;
const q$ = W$;
var Y$ = 1, X$ = 2, Z$ = 4, om = "[object Arguments]", K$ = "[object Array]", Q$ = "[object Boolean]", J$ = "[object Date]", t2 = "[object Error]", lm = "[object Function]", e2 = "[object GeneratorFunction]", n2 = "[object Map]", r2 = "[object Number]", cm = "[object Object]", i2 = "[object RegExp]", s2 = "[object Set]", a2 = "[object String]", o2 = "[object Symbol]", l2 = "[object WeakMap]", c2 = "[object ArrayBuffer]", u2 = "[object DataView]", h2 = "[object Float32Array]", d2 = "[object Float64Array]", f2 = "[object Int8Array]", p2 = "[object Int16Array]", g2 = "[object Int32Array]", m2 = "[object Uint8Array]", v2 = "[object Uint8ClampedArray]", y2 = "[object Uint16Array]", x2 = "[object Uint32Array]", Ct = {};
Ct[om] = Ct[K$] = Ct[c2] = Ct[u2] = Ct[Q$] = Ct[J$] = Ct[h2] = Ct[d2] = Ct[f2] = Ct[p2] = Ct[g2] = Ct[n2] = Ct[r2] = Ct[cm] = Ct[i2] = Ct[s2] = Ct[a2] = Ct[o2] = Ct[m2] = Ct[v2] = Ct[y2] = Ct[x2] = !0;
Ct[t2] = Ct[lm] = Ct[l2] = !1;
function ks(e, t, n, r, i, s) {
  var a, o = t & Y$, l = t & X$, c = t & Z$;
  if (n && (a = i ? n(e, r, i, s) : n(e)), a !== void 0)
    return a;
  if (!Ae(e))
    return e;
  var u = ee(e);
  if (u) {
    if (a = p$(e), !o)
      return Hg(e, a);
  } else {
    var h = zr(e), d = h == lm || h == e2;
    if (Fr(e))
      return em(e, o);
    if (h == cm || h == om || d && !i) {
      if (a = l || d ? {} : am(e), !o)
        return l ? e$(e, WC(a, e)) : QC(e, jC(a, e));
    } else {
      if (!Ct[h])
        return i ? e : {};
      a = B$(e, h, o);
    }
  }
  s || (s = new Pe());
  var f = s.get(e);
  if (f)
    return f;
  s.set(e, a), q$(e) ? e.forEach(function(g) {
    a.add(ks(g, t, n, g, e, s));
  }) : G$(e) && e.forEach(function(g, v) {
    a.set(v, ks(g, t, n, v, e, s));
  });
  var p = c ? l ? n$ : $l : l ? es : ts, m = u ? void 0 : p(e);
  return FT(m || e, function(g, v) {
    m && (v = g, g = e[v]), Fg(a, v, ks(g, t, n, v, e, s));
  }), a;
}
var b2 = 1, w2 = 4;
function xn(e) {
  return ks(e, b2 | w2);
}
var _2 = "__lodash_hash_undefined__";
function E2(e) {
  return this.__data__.set(e, _2), this;
}
function S2(e) {
  return this.__data__.has(e);
}
function Fi(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new _n(); ++t < n; )
    this.add(e[t]);
}
Fi.prototype.add = Fi.prototype.push = E2;
Fi.prototype.has = S2;
function um(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function hm(e, t) {
  return e.has(t);
}
var O2 = 1, T2 = 2;
function dm(e, t, n, r, i, s) {
  var a = n & O2, o = e.length, l = t.length;
  if (o != l && !(a && l > o))
    return !1;
  var c = s.get(e), u = s.get(t);
  if (c && u)
    return c == t && u == e;
  var h = -1, d = !0, f = n & T2 ? new Fi() : void 0;
  for (s.set(e, t), s.set(t, e); ++h < o; ) {
    var p = e[h], m = t[h];
    if (r)
      var g = a ? r(m, p, h, t, e, s) : r(p, m, h, e, t, s);
    if (g !== void 0) {
      if (g)
        continue;
      d = !1;
      break;
    }
    if (f) {
      if (!um(t, function(v, y) {
        if (!hm(f, y) && (p === v || i(p, v, n, r, s)))
          return f.push(y);
      })) {
        d = !1;
        break;
      }
    } else if (!(p === m || i(p, m, n, r, s))) {
      d = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), d;
}
function M2(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r, i) {
    n[++t] = [i, r];
  }), n;
}
function Qc(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var C2 = 1, $2 = 2, A2 = "[object Boolean]", L2 = "[object Date]", D2 = "[object Error]", k2 = "[object Map]", R2 = "[object Number]", I2 = "[object RegExp]", N2 = "[object Set]", P2 = "[object String]", U2 = "[object Symbol]", B2 = "[object ArrayBuffer]", V2 = "[object DataView]", Ed = $e ? $e.prototype : void 0, Ho = Ed ? Ed.valueOf : void 0;
function H2(e, t, n, r, i, s, a) {
  switch (n) {
    case V2:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case B2:
      return !(e.byteLength != t.byteLength || !s(new ya(e), new ya(t)));
    case A2:
    case L2:
    case R2:
      return Qi(+e, +t);
    case D2:
      return e.name == t.name && e.message == t.message;
    case I2:
    case P2:
      return e == t + "";
    case k2:
      var o = M2;
    case N2:
      var l = r & C2;
      if (o || (o = Qc), e.size != t.size && !l)
        return !1;
      var c = a.get(e);
      if (c)
        return c == t;
      r |= $2, a.set(e, t);
      var u = dm(o(e), o(t), r, i, s, a);
      return a.delete(e), u;
    case U2:
      if (Ho)
        return Ho.call(e) == Ho.call(t);
  }
  return !1;
}
var F2 = 1, G2 = Object.prototype, z2 = G2.hasOwnProperty;
function j2(e, t, n, r, i, s) {
  var a = n & F2, o = $l(e), l = o.length, c = $l(t), u = c.length;
  if (l != u && !a)
    return !1;
  for (var h = l; h--; ) {
    var d = o[h];
    if (!(a ? d in t : z2.call(t, d)))
      return !1;
  }
  var f = s.get(e), p = s.get(t);
  if (f && p)
    return f == t && p == e;
  var m = !0;
  s.set(e, t), s.set(t, e);
  for (var g = a; ++h < l; ) {
    d = o[h];
    var v = e[d], y = t[d];
    if (r)
      var x = a ? r(y, v, d, t, e, s) : r(v, y, d, e, t, s);
    if (!(x === void 0 ? v === y || i(v, y, n, r, s) : x)) {
      m = !1;
      break;
    }
    g || (g = d == "constructor");
  }
  if (m && !g) {
    var S = e.constructor, _ = t.constructor;
    S != _ && "constructor" in e && "constructor" in t && !(typeof S == "function" && S instanceof S && typeof _ == "function" && _ instanceof _) && (m = !1);
  }
  return s.delete(e), s.delete(t), m;
}
var W2 = 1, Sd = "[object Arguments]", Od = "[object Array]", ms = "[object Object]", q2 = Object.prototype, Td = q2.hasOwnProperty;
function Y2(e, t, n, r, i, s) {
  var a = ee(e), o = ee(t), l = a ? Od : zr(e), c = o ? Od : zr(t);
  l = l == Sd ? ms : l, c = c == Sd ? ms : c;
  var u = l == ms, h = c == ms, d = l == c;
  if (d && Fr(e)) {
    if (!Fr(t))
      return !1;
    a = !0, u = !1;
  }
  if (d && !u)
    return s || (s = new Pe()), a || Ya(e) ? dm(e, t, n, r, i, s) : H2(e, t, l, n, r, i, s);
  if (!(n & W2)) {
    var f = u && Td.call(e, "__wrapped__"), p = h && Td.call(t, "__wrapped__");
    if (f || p) {
      var m = f ? e.value() : e, g = p ? t.value() : t;
      return s || (s = new Pe()), i(m, g, n, r, s);
    }
  }
  return d ? (s || (s = new Pe()), j2(e, t, n, r, i, s)) : !1;
}
function Ja(e, t, n, r, i) {
  return e === t ? !0 : e == null || t == null || !Ke(e) && !Ke(t) ? e !== e && t !== t : Y2(e, t, n, r, Ja, i);
}
var X2 = 1, Z2 = 2;
function K2(e, t, n, r) {
  var i = n.length, s = i, a = !r;
  if (e == null)
    return !s;
  for (e = Object(e); i--; ) {
    var o = n[i];
    if (a && o[2] ? o[1] !== e[o[0]] : !(o[0] in e))
      return !1;
  }
  for (; ++i < s; ) {
    o = n[i];
    var l = o[0], c = e[l], u = o[1];
    if (a && o[2]) {
      if (c === void 0 && !(l in e))
        return !1;
    } else {
      var h = new Pe();
      if (r)
        var d = r(c, u, l, e, t, h);
      if (!(d === void 0 ? Ja(u, c, X2 | Z2, r, h) : d))
        return !1;
    }
  }
  return !0;
}
function fm(e) {
  return e === e && !Ae(e);
}
function Q2(e) {
  for (var t = ts(e), n = t.length; n--; ) {
    var r = t[n], i = e[r];
    t[n] = [r, i, fm(i)];
  }
  return t;
}
function pm(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function J2(e) {
  var t = Q2(e);
  return t.length == 1 && t[0][2] ? pm(t[0][0], t[0][1]) : function(n) {
    return n === e || K2(n, e, t);
  };
}
function tA(e, t) {
  return e != null && t in Object(e);
}
function eA(e, t, n) {
  t = Kg(t, e);
  for (var r = -1, i = t.length, s = !1; ++r < i; ) {
    var a = Ka(t[r]);
    if (!(s = e != null && n(e, a)))
      break;
    e = e[a];
  }
  return s || ++r != i ? s : (i = e == null ? 0 : e.length, !!i && zc(i) && Gc(a, i) && (ee(e) || Hr(e)));
}
function nA(e, t) {
  return e != null && eA(e, t, tA);
}
var rA = 1, iA = 2;
function sA(e, t) {
  return Wc(e) && fm(t) ? pm(Ka(e), t) : function(n) {
    var r = At(n, e);
    return r === void 0 && r === t ? nA(n, e) : Ja(t, r, rA | iA);
  };
}
function aA(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function oA(e) {
  return function(t) {
    return Qg(t, e);
  };
}
function lA(e) {
  return Wc(e) ? aA(Ka(e)) : oA(e);
}
function to(e) {
  return typeof e == "function" ? e : e == null ? Hc : typeof e == "object" ? ee(e) ? sA(e[0], e[1]) : J2(e) : lA(e);
}
function cA(e) {
  return function(t, n, r) {
    for (var i = -1, s = Object(t), a = r(t), o = a.length; o--; ) {
      var l = a[e ? o : ++i];
      if (n(s[l], l, s) === !1)
        break;
    }
    return t;
  };
}
var uA = cA();
const gm = uA;
function Dl(e, t, n) {
  (n !== void 0 && !Qi(e[t], n) || n === void 0 && !(t in e)) && Wa(e, t, n);
}
function kl(e) {
  return Ke(e) && ar(e);
}
function Rl(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function hA(e) {
  return Ji(e, es(e));
}
function dA(e, t, n, r, i, s, a) {
  var o = Rl(e, n), l = Rl(t, n), c = a.get(l);
  if (c) {
    Dl(e, n, c);
    return;
  }
  var u = s ? s(o, l, n + "", e, t, a) : void 0, h = u === void 0;
  if (h) {
    var d = ee(l), f = !d && Fr(l), p = !d && !f && Ya(l);
    u = l, d || f || p ? ee(o) ? u = o : kl(o) ? u = Hg(o) : f ? (h = !1, u = em(l, !0)) : p ? (h = !1, u = sm(l, !0)) : u = [] : UC(l) || Hr(l) ? (u = o, Hr(o) ? u = hA(o) : (!Ae(o) || Fc(o)) && (u = am(l))) : h = !1;
  }
  h && (a.set(l, u), i(u, l, r, s, a), a.delete(l)), Dl(e, n, u);
}
function mm(e, t, n, r, i) {
  e !== t && gm(t, function(s, a) {
    if (i || (i = new Pe()), Ae(s))
      dA(e, t, a, n, mm, r, i);
    else {
      var o = r ? r(Rl(e, a), s, a + "", e, t, i) : void 0;
      o === void 0 && (o = s), Dl(e, a, o);
    }
  }, es);
}
function fA(e, t, n) {
  for (var r = -1, i = e == null ? 0 : e.length; ++r < i; )
    if (n(t, e[r]))
      return !0;
  return !1;
}
function pA(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
var gA = "[object Map]", mA = "[object Set]", vA = Object.prototype, yA = vA.hasOwnProperty;
function Re(e) {
  if (e == null)
    return !0;
  if (ar(e) && (ee(e) || typeof e == "string" || typeof e.splice == "function" || Fr(e) || Ya(e) || Hr(e)))
    return !e.length;
  var t = zr(e);
  if (t == gA || t == mA)
    return !e.size;
  if (qa(e))
    return !Zg(e).length;
  for (var n in e)
    if (yA.call(e, n))
      return !1;
  return !0;
}
var xA = tM(function(e, t, n) {
  mm(e, t, n);
});
const rt = xA;
var bA = 1 / 0, wA = Ar && 1 / Qc(new Ar([, -0]))[1] == bA ? function(e) {
  return new Ar(e);
} : LT;
const _A = wA;
var EA = 200;
function vm(e, t, n) {
  var r = -1, i = qT, s = e.length, a = !0, o = [], l = o;
  if (n)
    a = !1, i = fA;
  else if (s >= EA) {
    var c = t ? null : _A(e);
    if (c)
      return Qc(c);
    a = !1, i = hm, l = new Fi();
  } else
    l = t ? [] : o;
  t:
    for (; ++r < s; ) {
      var u = e[r], h = t ? t(u) : u;
      if (u = n || u !== 0 ? u : 0, a && h === h) {
        for (var d = l.length; d--; )
          if (l[d] === h)
            continue t;
        t && l.push(h), o.push(u);
      } else
        i(l, h, n) || (l !== o && l.push(h), o.push(u));
    }
  return o;
}
var SA = Gg(function(e) {
  var t = pA(e);
  return kl(t) && (t = void 0), vm(Qa(e, 1, kl, !0), to(t));
});
const OA = SA;
function Gi(e) {
  return e && e.length ? vm(e) : [];
}
const he = "cds", cn = {
  opacity: {
    unselected: 0.05,
    selected: 0.4
  }
}, An = {
  ticks: {
    number: 7,
    rotateIfSmallerThan: 30,
    verticalSpaceRatio: 2.5,
    horizontalSpaceRatio: 3.5
  },
  ratio: {
    reference: "value",
    compareTo: "marker"
  },
  paddingRatio: 0.1,
  hover: {
    rectanglePadding: 4
  }
}, Mr = {
  duration: 1e3,
  ease: Cp,
  zoomLevel: 3
}, xr = {
  circles: {
    fillOpacity: 0.3,
    hover: {
      stroke: "#FFF"
    }
  },
  padding: {
    mainGroup: 4,
    children: 2
  },
  hierarchyLevel: 2
}, ym = {
  pairingOptions: {
    "1-color": 4,
    "2-color": 5,
    "3-color": 5,
    "4-color": 3,
    "5-color": 2,
    "14-color": 1
  }
}, Oe = {
  circle: {
    radius: 4,
    opacity: {
      hovered: 1,
      default: 0.3
    }
  },
  box: {
    opacity: {
      hovered: 0.5,
      default: 0.3
    }
  },
  strokeWidth: {
    default: 1,
    thicker: 2
  }
}, TA = {
  defaultBins: 10
}, Bt = {
  items: {
    status: {
      ACTIVE: 1,
      DISABLED: 0
    },
    horizontalSpace: 12,
    verticalSpace: 24,
    textYOffset: 8,
    spaceAfter: 4
  },
  checkbox: {
    radius: 6.5
  },
  radius: {
    iconData: [
      { cx: 7, cy: 7, r: 6.5 },
      { cx: 7, cy: 10, r: 3.5 }
    ],
    fill: null,
    stroke: "#8c8c8c"
  },
  line: {
    yPosition: 6,
    width: 24,
    strokeWidth: 1.4,
    fill: null,
    stroke: "#999999"
  },
  area: {
    width: 24,
    height: 14,
    fill: "#6f6f6f",
    stroke: null
  },
  size: {
    iconData: [
      { width: 23, height: 12 },
      { width: 13, height: 6 }
    ],
    fill: null,
    stroke: "#8D8D8D"
  },
  quartile: {
    iconData: [
      { x: 0, y: 0, width: 24, height: 13 },
      { x: 11, y: 4, width: 1, height: 4 }
    ]
  },
  zoom: {
    iconData: [{ x: 0, y: 0, width: 12, height: 12 }],
    color: "#8D8D8D"
  },
  color: {
    barWidth: 300,
    barHeight: 8,
    axisYTranslation: 10
  }
}, ln = {
  opacity: {
    unselected: 0.3,
    selected: 1
  },
  weight: {
    selected: 2,
    unselected: 1
  }
}, Jt = {
  statusBar: {
    paddingRight: 5
  },
  status: {
    indicatorSize: 16,
    paddingLeft: 15
  },
  total: {
    paddingLeft: 36,
    paddingRight: 24
  },
  height: {
    default: 8,
    proportional: 16
  },
  dividerWidth: 2
}, $t = {
  radiusOffset: -15,
  innerRadius: 2,
  padAngle: 7e-3,
  hoverArc: {
    outerRadiusOffset: 3
  },
  xOffset: 30,
  yOffset: 20,
  yOffsetCallout: 10,
  callout: {
    minSliceDegree: 5,
    offsetX: 15,
    offsetY: 12,
    horizontalLineLength: 8,
    textMargin: 2
  }
}, Pn = {
  opacity: {
    unselected: 0.1,
    selected: 0.3
  },
  xLabelPadding: 10,
  yLabelPadding: 8,
  yTicksNumber: 4,
  minRange: 10,
  xAxisRectHeight: 50,
  dotsRadius: 5
}, Le = {
  nodeWidth: 4,
  nodeHoveredWidth: 8,
  minNodePadding: 24,
  opacity: {
    unfocus: 0.3,
    default: 0.8,
    selected: 1
  }
}, Md = {
  minCellDividerDimension: 16,
  // Ensures axes lines are displayed with or without stroke disabled
  chartPadding: 0.5
}, Cd = {
  default: {
    size: 24
  }
}, MA = {
  horizontalOffset: 10
}, $d = {
  default: {
    duration: 300
  },
  pie_slice_mouseover: {
    duration: 100
  },
  pie_chart_titles: {
    duration: 375
  },
  graph_element_mouseover_fill_update: {
    duration: 100
  },
  graph_element_mouseout_fill_update: {
    duration: 100
  }
}, ye = {
  height: {
    [We.GRAPH_VIEW]: 32,
    [We.SLIDER_VIEW]: 10
  },
  spacerHeight: 8,
  handleWidth: 5,
  handleBarWidth: 1,
  handleBarHeight: 12
}, CA = [
  {
    type: Wt.RADIUS,
    name: "Radius"
  },
  {
    type: Wt.AREA,
    name: "Poor area"
  },
  {
    type: Wt.AREA,
    name: "Satisfactory area"
  },
  {
    type: Wt.AREA,
    name: "Great area"
  },
  {
    type: Wt.QUARTILE,
    name: "Quartiles"
  }
], Cr = {
  type: Ie.END_LINE,
  threshold: 16,
  numCharacter: 14
}, $A = {
  enabled: !0,
  position: _i.BOTTOM,
  clickable: !0,
  truncation: Cr,
  alignment: Yt.LEFT,
  order: null,
  additionalItems: []
}, AA = {
  x: {
    // set enable to false will not draw grid and stroke of grid backdrop
    enabled: !0,
    numberOfTicks: 15,
    alignWithAxisTicks: !1
  },
  y: {
    // set enable to false will not draw grid and stroke of grid backdrop
    enabled: !0,
    numberOfTicks: 5,
    alignWithAxisTicks: !1
  }
}, LA = {
  // enable or disable ruler
  enabled: !0
}, xm = {
  enabled: !0,
  showTotal: !0,
  truncation: Cr,
  groupLabel: "Group"
}, bm = {
  top: {
    visible: !0,
    includeZero: !0,
    truncation: Cr
  },
  bottom: {
    visible: !0,
    includeZero: !0,
    truncation: Cr
  },
  left: {
    visible: !0,
    includeZero: !0,
    truncation: Cr
  },
  right: {
    visible: !0,
    includeZero: !0,
    truncation: Cr
  }
}, eo = {
  addSpaceOnEdges: 1,
  showDayName: !1,
  localeObject: Ng,
  timeIntervalFormats: {
    "15seconds": { primary: "MMM d, pp", secondary: "pp" },
    minute: { primary: "MMM d, p", secondary: "p" },
    "30minutes": { primary: "MMM d, p", secondary: "p" },
    hourly: { primary: "MMM d, hh a", secondary: "hh a" },
    daily: { primary: "MMM d", secondary: "d" },
    weekly: { primary: "eee, MMM d", secondary: "eee" },
    monthly: { primary: "MMM yyyy", secondary: "MMM" },
    quarterly: { primary: "QQQ ''yy", secondary: "QQQ" },
    yearly: { primary: "yyyy", secondary: "yyyy" }
  }
}, DA = typeof document < "u" && (document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled), ae = {
  width: null,
  height: null,
  resizable: !0,
  theme: Kf.WHITE,
  tooltip: xm,
  legend: $A,
  style: {
    prefix: "cc"
  },
  data: {
    groupMapsTo: "group",
    loading: !1,
    selectedGroups: []
  },
  color: {
    scale: null,
    pairing: {
      numberOfVariants: null,
      option: 1
    },
    gradient: {
      enabled: !1
    }
  },
  toolbar: {
    enabled: !0,
    numberOfIcons: 3,
    controls: [
      {
        type: Ut.SHOW_AS_DATATABLE
      },
      ...DA ? [
        {
          type: Ut.MAKE_FULLSCREEN
        }
      ] : [],
      {
        type: Ut.EXPORT_CSV
      },
      {
        type: Ut.EXPORT_PNG
      },
      {
        type: Ut.EXPORT_JPG
      }
    ]
  }
}, wm = rt({}, ae, {
  thematic: {
    projection: on.geoNaturalEarth1
  }
}), rs = rt({}, ae, {
  axes: bm,
  timeScale: eo,
  grid: AA,
  ruler: LA,
  zoomBar: {
    zoomRatio: 0.4,
    minZoomRatio: 0.01,
    top: {
      enabled: !1,
      type: We.GRAPH_VIEW
    }
  }
}), tr = rt({}, rs, {
  bars: {
    maxWidth: 16,
    spacingFactor: 0.25
  },
  timeScale: rt(eo, {
    addSpaceOnEdges: 1
  })
}), kA = rt({}, tr, {}), RA = rt({}, tr, {}), IA = rt({}, tr, {
  bars: rt({}, tr.bars, {
    dividerSize: 1.5
  })
}), NA = rt({}, tr, {}), Jc = rt({}, rs, {
  points: {
    // default point radius to 4
    radius: 4,
    fillOpacity: 0.3,
    filled: !0,
    enabled: !0
  }
}), PA = Jc, _m = rt({}, Jc, {
  points: {
    // default point radius to 3
    radius: 3,
    filled: !1,
    enabled: !0
  }
}), Em = rt({}, _m, {
  timeScale: rt(eo, {
    addSpaceOnEdges: 0
  })
}), UA = Em, BA = rt({}, rs, {
  bubble: {
    radiusMapsTo: "radius",
    radiusLabel: "Radius",
    radiusRange: (e) => {
      const t = Math.min(e.width, e.height);
      return [t * 3 / 400, t * 25 / 400];
    },
    fillOpacity: 0.2,
    enabled: !0
  },
  points: {
    filled: !0
  },
  legend: {
    additionalItems: [
      {
        type: Wt.RADIUS,
        name: "Radius"
      }
    ]
  }
}), VA = rt({}, rs, {
  bullet: {
    performanceAreaTitles: ["Poor", "Satisfactory", "Great"]
  },
  grid: {
    x: {
      enabled: !1
    },
    y: {
      enabled: !1
    }
  },
  legend: {
    additionalItems: [
      {
        type: Wt.AREA,
        name: "Poor area"
      },
      {
        type: Wt.AREA,
        name: "Satisfactory area"
      },
      {
        type: Wt.AREA,
        name: "Great area"
      },
      {
        type: Wt.QUARTILE,
        name: "Quartiles"
      }
    ]
  }
}), HA = rt({}, tr, {
  bars: {
    dividerSize: 1.5
  },
  timeScale: rt(eo, {
    addSpaceOnEdges: 0
  })
}), FA = rt({}, ae, {
  tooltip: rt({}, xm, {
    wordLabel: "Word",
    valueLabel: "Value"
  }),
  wordCloud: {
    fontSizeMapsTo: "value",
    fontSizeRange: (e) => {
      const t = Math.min(e.width, e.height);
      return [t * 20 / 400, t * 75 / 400];
    },
    wordMapsTo: "word"
  }
}), Sm = rt({}, ae, {
  pie: {
    labels: {
      formatter: null,
      enabled: !0
    },
    alignment: Yt.LEFT,
    sortFunction: null,
    valueMapsTo: "value"
  }
}), GA = rt({}, ae, {
  legend: {
    enabled: !1
  },
  gauge: {
    type: _r.SEMI,
    arcWidth: 16,
    deltaArrow: {
      size: (e) => e / 8,
      enabled: !0
    },
    showPercentageSymbol: !0,
    status: null,
    numberSpacing: 10,
    deltaFontSize: (e) => e / 8,
    valueFontSize: (e) => e / 2.5,
    numberFormatter: (e) => Number(e.toFixed(2)) % 1 !== 0 ? e.toFixed(2).toLocaleString() : e.toFixed().toLocaleString(),
    alignment: Yt.LEFT
  }
}), zA = rt({}, Sm, {
  donut: {
    center: {
      numberFontSize: (e) => `${Math.min(e / 100 * 24, 24)}px`,
      titleFontSize: (e) => `${Math.min(e / 100 * 15, 15)}px`,
      titleYPosition: (e) => Math.min(e / 80 * 20, 20),
      numberFormatter: (e) => Math.floor(e).toLocaleString()
    },
    alignment: Yt.LEFT
  }
}), Om = rt({}, ae, {
  legend: {
    enabled: !1,
    clickable: !1
  },
  meter: {
    showLabels: !0,
    proportional: null,
    statusBar: {
      percentageIndicator: {
        enabled: !0
      }
    }
  }
}), jA = rt({}, Om, {
  legend: {
    enabled: !0
  }
}), WA = rt({}, ae, {
  radar: {
    axes: {
      angle: "key",
      value: "value"
    },
    alignment: Yt.LEFT
  },
  tooltip: {
    gridline: {
      enabled: !0
    },
    valueFormatter: (e) => e ?? "N/A"
  }
}), qA = rt({}, tr, {
  comboChartTypes: []
}), YA = rt(
  {
    tree: {
      type: lc.TREE
    }
  },
  ae,
  {}
), XA = rt({}, ae, {
  data: rt(ae.data, {
    groupMapsTo: "name"
  })
}), ZA = rt({}, ae, xr, {
  data: rt(ae.data, {
    groupMapsTo: "name"
  })
}), KA = rt({}, ae, {
  alluvial: {
    data: rt(ae.data, {
      groupMapsTo: "source"
    }),
    nodeAlignment: Yt.CENTER,
    nodePadding: 24,
    monochrome: !1,
    nodes: []
  }
}), QA = rt({}, ae, {
  axes: bm,
  heatmap: {
    divider: {
      state: Ei.AUTO
    },
    colorLegend: {
      type: "linear"
    }
  }
}), JA = rt({}, wm, {
  choropleth: {
    colorLegend: {
      type: "linear"
    }
  }
}), Mt = {
  alluvialChart: KA,
  areaChart: Em,
  axisChart: rs,
  boxplotChart: NA,
  bubbleChart: BA,
  bulletChart: VA,
  chart: ae,
  circlePackChart: ZA,
  choroplethChart: JA,
  comboChart: qA,
  donutChart: zA,
  gaugeChart: GA,
  groupedBarChart: RA,
  heatmapChart: QA,
  histogramChart: HA,
  lineChart: _m,
  lollipopChart: PA,
  meterChart: Om,
  pieChart: Sm,
  proportionalMeterChart: jA,
  radarChart: WA,
  scatterChart: Jc,
  simpleBarChart: kA,
  stackedAreaChart: UA,
  stackedBarChart: IA,
  thematicChart: wm,
  treeChart: YA,
  treemapChart: XA,
  wordCloudChart: FA
};
function tL(e, t, n) {
  let r = null;
  return function(...i) {
    const s = this;
    s.mousePosition = Yn(i[0], n), clearTimeout(r), r = setTimeout(function() {
      e.apply(s, i);
    }, t);
  };
}
function Pt(e, t) {
  var n;
  const r = xn(e), i = Object.keys(t.axes || {});
  (n = t == null ? void 0 : t.toolbar) != null && n.controls && delete r.toolbar.controls, i.length === 0 && delete r.axes;
  for (const s in r.axes)
    if (i.includes(s)) {
      const a = t.axes[s];
      if ((a.primary || a.secondary) && console.warn(
        "`primary` & `secondary` are no longer needed for axis configurations. Read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/docs-tutorials--tabular-data-format"
      ), a.mapsTo == null) {
        const l = a.scaleType;
        l == null ? a.mapsTo = "value" : l === X.TIME ? a.mapsTo = "date" : l === X.LABELS && (a.mapsTo = "key");
      }
    } else
      delete r.axes[s];
  return tu(r, t), rt(r, t);
}
function an(e) {
  if (!e)
    return;
  const t = /translate\([0-9]+\.?[0-9]*,[0-9]+\.?[0-9]*\)/, n = e.getAttribute("transform").match(t);
  if (!n)
    return null;
  if (n[0]) {
    const r = n[0].replace(/translate\(/, "").replace(/\)/, "").split(",");
    return {
      tx: r[0],
      ty: r[1]
    };
  }
  return null;
}
function yi(e) {
  const t = /\(([^)]+)\)/.exec(e);
  if (t && t.length > 1) {
    const n = t[1].split(",");
    if (n.length > 1)
      return {
        x: parseFloat(n[0]),
        y: parseFloat(n[1])
      };
  }
  return { x: 0, y: 0 };
}
function Ad(e, t, n = "value") {
  const r = e / t.reduce((i, s) => i + s[n], 0) * 100;
  return r % 1 !== 0 ? parseFloat(r.toFixed(1)) : r;
}
function zi(e, t, n) {
  if (n > e.length)
    return e;
  if (t === Ie.MID_LINE)
    return e.substr(0, n / 2) + "..." + e.substr(-n / 2);
  if (t === Ie.FRONT_LINE)
    return "..." + e.substr(-n);
  if (t === Ie.END_LINE)
    return e.substr(0, n) + "...";
}
function tu(e, t) {
  const n = b(e, "legend", "additionalItems"), r = b(t, "legend", "additionalItems");
  if (n && r) {
    const i = r.map((o) => o.type), s = n.map((o) => o.type), a = CA.filter(
      (o) => s.includes(o.type) && !i.includes(o.type)
    );
    e.legend.additionalItems = a, t.legend.additionalItems = OA(
      a,
      r,
      "name"
    );
  }
}
const b = (e, ...t) => {
  let n = e;
  if (n) {
    for (const r of t)
      if (n[r] !== null && n[r] !== void 0)
        n = n[r];
      else
        return null;
    return n;
  }
  return null;
}, Tm = (e, t) => t === Kt.HORIZONTAL ? {
  y0: e.x0,
  y1: e.x1,
  x0: e.y0,
  x1: e.y1
} : e, ce = (e, t) => {
  const { x0: n, x1: r, y0: i, y1: s } = Tm(e, t);
  return `M${n},${i}L${n},${s}L${r},${s}L${r},${i}L${n},${i}`;
};
function dn(e, t, n) {
  return n === Kt.VERTICAL ? [e, t] : [t, e];
}
var Mm = /* @__PURE__ */ ((e) => (e["15seconds"] = "15seconds", e.minute = "minute", e["30minutes"] = "30minutes", e.hourly = "hourly", e.daily = "daily", e.weekly = "weekly", e.monthly = "monthly", e.quarterly = "quarterly", e.yearly = "yearly", e))(Mm || {});
const Fo = [
  ["15seconds", 15 * 1e3],
  ["minute", 60 * 1e3],
  ["30minutes", 30 * 60 * 1e3],
  ["hourly", 60 * 60 * 1e3],
  ["daily", 24 * 60 * 60 * 1e3],
  ["monthly", 30 * 24 * 60 * 60 * 1e3],
  ["quarterly", 3 * 30 * 24 * 60 * 60 * 1e3],
  ["yearly", 12 * 30 * 24 * 60 * 60 * 1e3]
];
function Cm(e, t, n, r, i) {
  const s = t === 0, a = Number(Vr(new Date(e), "c")) === 2, o = Number(Vr(new Date(e), "q")) === 1, l = t !== 0 ? n[t - 1] : null;
  switch (r) {
    case "15seconds":
      return s || vs(e) || si(e, l) || On(e);
    case "minute":
      return s || vs(e) || si(e, l) || On(e);
    case "30minutes":
      return s || vs(e) || si(e, l) || On(e);
    case "hourly":
      return s || vs(e) || si(e, l) || On(e);
    case "daily":
      return i ? s || a || On(e) : s || si(e, l) || On(e);
    case "weekly":
      return s || a || On(e);
    case "monthly":
      return s || On(e);
    case "quarterly":
      return s || o;
    case "yearly":
      return !1;
    default:
      throw new Error(`${r} is not a valid time interval.`);
  }
}
function Il(e, t, n, r, i) {
  const s = i.showDayName, a = r === "daily" && s ? "weekly" : r, o = new Date(e), l = b(i, "timeIntervalFormats")[a], c = b(l, "primary"), u = b(l, "secondary");
  let h = Cm(e, t, n, r, s) ? c : u;
  r === "15seconds" && o.getMilliseconds() !== 0 && (h = h.replace("pp", "h:mm:ss.SSS a"));
  const d = i.localeObject;
  return Vr(o, h, { locale: d });
}
function xa(e) {
  const t = new Date(e);
  return {
    M: t.getMonth() + 1,
    // month: 1-12
    d: t.getDate(),
    // day of the month: 1-31
    H: t.getHours(),
    // 24-hour clock: 0-23
    m: t.getMinutes(),
    // minute: 0-59
    s: t.getSeconds()
    // seconds: 0-59
  };
}
function eL(e) {
  if (e)
    return e.slice(1).map((t, n) => t - e[n]);
}
function nL(e) {
  const t = Fo.reduce((n, [, r], i) => {
    const s = Fo[n][1], a = Math.abs(s - e), o = Math.abs(r - e);
    return a < o ? n : i;
  }, 0);
  return Fo[t][0];
}
function Nl(e, t) {
  if (Mm[t])
    return t;
  if (e.length === 1)
    return "15seconds";
  const n = eL(e), r = Ln(n);
  return nL(r);
}
function vs(e) {
  const { s: t, m: n, H: r } = xa(e);
  return r === 0 && n === 0 && t === 0;
}
function si(e, t) {
  const n = xa(e).M, r = xa(t).M;
  return n !== r;
}
function On(e) {
  const { M: t, d: n, s: r, m: i, H: s } = xa(e);
  return t === 1 && n === 1 && s === 0 && i === 0 && r === 0;
}
function Ld(e) {
  return e === void 0 ? "" : e.toISOString();
}
function $m(e) {
  const t = Ne(e, (r) => r.value), n = Be().domain(t).nice().domain();
  if (n[0] > 0)
    n[0] = 0;
  else if (n[0] === 0 && n[1] === 0)
    return [0, 1];
  return n[0] < 0 && n[1] > 0 && (Math.abs(n[0]) > n[1] ? n[1] = Math.abs(n[0]) : n[0] = -n[1]), n;
}
function Am(e, t) {
  const n = b(t, "gradient", "colors"), r = !Re(n);
  let i = b(t, "pairing", "option");
  const s = $m(e), a = s[0] < 0 && s[1] > 0 ? "diverge" : "mono";
  (i < 1 && i > 4 && a === "mono" || i < 1 && i > 2 && a === "diverge") && (i = 1);
  const o = r ? n : [];
  if (!r) {
    const l = a === "diverge" ? 17 : 11;
    for (let c = 1; c < l + 1; c++)
      o.push(`fill-${a}-${i}-${c}`);
  }
  return Cc().domain(s).range(o);
}
var at = /* @__PURE__ */ ((e) => (e.GRAPHICS_DOCUMENT = "graphics-document", e.GRAPHICS_OBJECT = "graphics-object", e.GRAPHICS_SYMBOL = "graphics-symbol", e.GROUP = "group", e.DOCUMENT = "document", e.CHECKBOX = "checkbox", e.BUTTON = "button", e.MENU = "menu", e.MENU_ITEM = "menuitem", e.IMG = "img", e))(at || {});
function rL(e, t) {
  return e && gm(e, t, ts);
}
function iL(e, t) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!ar(n))
      return e(n, r);
    for (var i = n.length, s = t ? i : -1, a = Object(n); (t ? s-- : ++s < i) && r(a[s], s, a) !== !1; )
      ;
    return n;
  };
}
var sL = iL(rL);
const eu = sL;
function aL(e, t, n, r) {
  for (var i = -1, s = e == null ? 0 : e.length; ++i < s; ) {
    var a = e[i];
    t(r, a, n(a), e);
  }
  return r;
}
function oL(e, t, n, r) {
  return eu(e, function(i, s, a) {
    t(r, i, n(i), a);
  }), r;
}
function lL(e, t) {
  return function(n, r) {
    var i = ee(n) ? aL : oL, s = t ? t() : {};
    return i(n, e, to(r), s);
  };
}
function cL(e) {
  for (var t = -1, n = e == null ? 0 : e.length, r = {}; ++t < n; ) {
    var i = e[t];
    r[i[0]] = i[1];
  }
  return r;
}
var uL = Object.prototype, hL = uL.hasOwnProperty, dL = lL(function(e, t, n) {
  hL.call(e, n) ? e[n].push(t) : Wa(e, n, [t]);
});
const fL = dL;
class Je {
  constructor(t) {
    this.state = {
      options: {}
    }, this.colorScale = {}, this.colorClassNames = {}, this.services = t;
  }
  getAllDataFromDomain(t) {
    if (!this.getData())
      return null;
    const n = this.getOptions();
    let r = this.getData();
    const i = this.getDataGroups(), { groupMapsTo: s } = b(n, "data"), a = b(n, "axes");
    return t && (r = r.filter((o) => t.includes(o[s]))), a && Object.keys(a).forEach((o) => {
      const l = a[o].mapsTo, c = a[o].scaleType;
      if ((c === X.LINEAR || c === X.LOG) && (r = r.map((u) => ({
        ...u,
        [l]: u[l] === null ? u[l] : Number(u[l])
      }))), l && a[o].domain)
        if (c === X.LABELS)
          r = r.filter(
            (u) => a[o].domain.includes(u[l])
          );
        else {
          const [u, h] = a[o].domain;
          r = r.filter(
            (d) => !(l in d) || d[l] >= u && d[l] <= h
          );
        }
    }), r.filter((o) => i.find((l) => l.name === o[s]));
  }
  /**
   * Charts that have group configs passed into them, only want to retrieve the display data relevant to that chart
   * @param groups the included datasets for the particular chart
   */
  getDisplayData(t) {
    if (!this.get("data"))
      return null;
    const { ACTIVE: n } = Bt.items.status, r = this.getDataGroups(t), { groupMapsTo: i } = this.getOptions().data;
    return this.getAllDataFromDomain(t).filter((s) => r.find(
      (a) => a.name === s[i] && a.status === n
    ));
  }
  getData() {
    return this.get("data");
  }
  isDataEmpty() {
    return !this.getData().length;
  }
  /**
   *
   * @param newData The new raw data to be set
   */
  setData(t) {
    const n = this.sanitize(xn(t)), r = this.generateDataGroups(n);
    return this.set({
      data: n,
      dataGroups: r
    }), n;
  }
  getDataGroups(t) {
    return b(this.getOptions(), "data", "loading") ? [] : t ? this.get("dataGroups").filter((n) => t.includes(n.name)) : this.get("dataGroups");
  }
  getActiveDataGroups(t) {
    const { ACTIVE: n } = Bt.items.status;
    return this.getDataGroups(t).filter((r) => r.status === n);
  }
  getDataGroupNames(t) {
    return this.getDataGroups(t).map((n) => n.name);
  }
  getActiveDataGroupNames(t) {
    return this.getActiveDataGroups(t).map((n) => n.name);
  }
  aggregateBinDataByGroup(t) {
    return fL(t, "group");
  }
  getBinConfigurations() {
    const t = this.getDisplayData(), n = this.getOptions(), r = this.services.cartesianScales.getMainXAxisPosition(), i = this.services.cartesianScales.getDomainIdentifier(), s = n.axes[r], { groupMapsTo: a } = n.data, { bins: o = TA.defaultBins } = s, l = Array.isArray(o), c = M0().value((f) => f[i]).thresholds(o)(t);
    if (l)
      c[c.length - 1].x1 = o[o.length - 1];
    else {
      const f = c[0].x1 - c[0].x0;
      c[c.length - 1].x1 = +c[c.length - 1].x0 + f;
    }
    const u = l ? [o[0], o[o.length - 1]] : [c[0].x0, c[c.length - 1].x1], h = Array.from(new Set(t.map((f) => f[a]))), d = [];
    return c.forEach((f) => {
      const p = `${f.x0}-${f.x1}`, m = this.aggregateBinDataByGroup(f);
      h.forEach((g) => {
        d.push({
          group: g,
          key: p,
          value: m[g] || 0,
          bin: f.x0
        });
      });
    }), {
      bins: c,
      binsDomain: u
    };
  }
  getBinnedStackedData() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getActiveDataGroupNames(), { bins: i } = this.getBinConfigurations(), s = this.getDataValuesGroupedByKeys({
      bins: i
    });
    return Po().keys(r)(s).map((a, o) => Object.keys(a).filter((l) => !isNaN(l)).map((l) => {
      const c = a[l];
      return c[n] = r[o], c;
    }));
  }
  getGroupedData(t) {
    const n = this.getDisplayData(t), r = {}, { groupMapsTo: i } = this.getOptions().data;
    return n.map((s) => {
      const a = s[i];
      r[a] !== null && r[a] !== void 0 ? r[a].push(s) : r[a] = [s];
    }), Object.keys(r).map((s) => ({
      name: s,
      data: r[s]
    }));
  }
  getStackKeys({ bins: t = null, groups: n = null } = { bins: null, groups: null }) {
    const r = this.getOptions(), i = this.getDisplayData(n);
    let s;
    t ? s = t.map((l) => `${l.x0}-${l.x1}`) : s = Gi(
      i.map((l) => {
        const c = this.services.cartesianScales.getDomainIdentifier(l);
        return l[c] instanceof Date ? Ld(l[c]) : l[c] && typeof l[c].toString == "function" ? l[c].toString() : l[c];
      })
    );
    const a = this.services.cartesianScales.domainAxisPosition, o = r.axes[a].scaleType;
    return o === X.TIME ? s.sort((l, c) => {
      const u = new Date(l), h = new Date(c);
      return u - h;
    }) : (o === X.LOG || o === X.LINEAR) && s.sort((l, c) => l - c), s;
  }
  getDataValuesGroupedByKeys({ bins: t = null, groups: n = null }) {
    const r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.getDisplayData(n), a = this.getDataGroupNames(), o = this.getStackKeys({ bins: t, groups: n });
    return t ? o.map((l) => {
      const [c, u] = l.split("-"), h = { x0: c, x1: u }, d = t.find((f) => f.x0.toString() === c.toString());
      return a.forEach((f) => {
        h[f] = d.filter(
          (p) => p[i] === f
        ).length;
      }), h;
    }) : o.map((l) => {
      const c = { sharedStackKey: l };
      return a.forEach((u) => {
        const h = s.find((f) => {
          const p = this.services.cartesianScales.getDomainIdentifier(f);
          return f[i] === u && Object.prototype.hasOwnProperty.call(f, p) && (f[p] instanceof Date ? Ld(f[p]) === l : f[p].toString() === l);
        }), d = this.services.cartesianScales.getRangeIdentifier(c);
        c[u] = h ? h[d] : null;
      }), c;
    });
  }
  getStackedData({ percentage: t = !1, groups: n = null, divergent: r = !1 }) {
    const i = this.getOptions(), { groupMapsTo: s } = i.data, a = this.getActiveDataGroupNames(n), o = this.getDataValuesGroupedByKeys({
      groups: n
    });
    if (t) {
      const l = cL(o.map((c) => [c.sharedStackKey, 0]));
      o.forEach((c) => {
        a.forEach((u) => {
          l[c.sharedStackKey] += c[u];
        });
      }), o.forEach((c) => {
        a.forEach((u) => {
          const h = l[c.sharedStackKey];
          l[c.sharedStackKey] ? c[u] = c[u] / h * 100 : c[u] = 0;
        });
      });
    }
    return (r ? Po().offset(NS) : Po()).keys(a)(o).map((l, c) => Object.keys(l).filter((u) => !isNaN(u)).map((u) => {
      const h = l[u];
      return h[s] = a[c], h;
    }));
  }
  /**
   * @return {Object} The chart's options
   */
  getOptions() {
    return this.state.options;
  }
  set(t, n) {
    this.state = Object.assign({}, this.state, t);
    const r = Object.assign(
      { skipUpdate: !1, animate: !0 },
      // default configs
      n
    );
    r.skipUpdate || this.update(r.animate);
  }
  get(t) {
    return t ? this.state[t] : this.state;
  }
  /**
   *
   * @param newOptions New options to be set
   */
  setOptions(t) {
    const n = this.getOptions();
    tu(n, t), this.set({
      options: rt(n, t)
    });
  }
  /**
   *
   * Updates miscellanous information within the model
   * such as the color scales, or the legend data labels
   */
  update(t = !0) {
    this.getDisplayData() && (this.updateAllDataGroups(), this.setCustomColorScale(), this.setColorClassNames(), this.services.events.dispatchEvent(O.Model.UPDATE, { animate: t }));
  }
  /*
   * Data labels
   */
  toggleDataLabel(t) {
    const { ACTIVE: n, DISABLED: r } = Bt.items.status, i = this.getDataGroups(), s = i.some((c) => c.status === r), a = i.filter((c) => c.status === n);
    if (s)
      if (a.length === 1 && a[0].name === t)
        i.forEach((c, u) => {
          i[u].status = n;
        });
      else {
        const c = i.findIndex((u) => u.name === t);
        i[c].status = i[c].status === r ? n : r;
      }
    else
      i.forEach((c, u) => {
        i[u].status = c.name === t ? n : r;
      });
    const o = i.filter((c) => c.status === n), l = this.getOptions();
    i.some((c) => c.status === r) ? l.data.selectedGroups = o.map((c) => c.name) : l.data.selectedGroups = [], this.services.events.dispatchEvent(O.Legend.ITEMS_UPDATE, {
      dataGroups: i
    }), this.set({
      dataGroups: i
    });
  }
  /**
   * Should the data point be filled?
   * @param group
   * @param key
   * @param data
   * @param defaultFilled the default for this chart
   */
  getIsFilled(t, n, r, i) {
    const s = this.getOptions();
    return s.getIsFilled ? s.getIsFilled(t, n, r, i) : i;
  }
  getFillColor(t, n, r) {
    const i = this.getOptions(), s = b(this.colorScale, t);
    return i.getFillColor ? i.getFillColor(t, n, r, s) : s;
  }
  getStrokeColor(t, n, r) {
    const i = this.getOptions(), s = b(this.colorScale, t);
    return i.getStrokeColor ? i.getStrokeColor(t, n, r, s) : s;
  }
  isUserProvidedColorScaleValid() {
    const t = b(this.getOptions(), "color", "scale"), n = this.getDataGroups();
    return t == null || Object.keys(t).length == 0 ? !1 : n.some(
      (r) => Object.keys(t).includes(r.name)
    );
  }
  getColorClassName(t) {
    const n = this.colorClassNames(t.dataGroupName);
    let r = t.originalClassName;
    return t.classNameTypes.forEach(
      (i) => r = t.originalClassName ? `${r} ${i}-${n}` : `${i}-${n}`
    ), r || "";
  }
  /**
   * For charts that might hold an associated status for their dataset
   */
  getStatus() {
    return null;
  }
  getAllDataGroupsNames() {
    return this.allDataGroups;
  }
  /**
   * Converts data provided in the older format to tabular
   *
   */
  transformToTabularData(t) {
    console.warn(
      "We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/docs-tutorials--tabular-data-format"
    );
    const n = [], { datasets: r, labels: i } = t;
    return r.forEach((s) => {
      s.data.forEach((a, o) => {
        let l;
        const c = b(s, "label");
        if (c === null) {
          const h = b(i, o);
          h ? l = h : l = "Ungrouped";
        } else
          l = c;
        const u = {
          group: l,
          key: i[o]
        };
        isNaN(a) ? (u.value = a.value, u.date = a.date) : u.value = a, n.push(u);
      });
    }), n;
  }
  getTabularDataArray() {
    return [];
  }
  exportToCSV() {
    const t = this.getTabularDataArray().map(
      (i) => i.map((s) => `"${s === "&ndash;" ? "" : s}"`)
    );
    let n = "", r = "";
    t.forEach(function(i, s) {
      r = i.join(","), n += s < t.length ? r + `
` : r;
    }), this.services.files.downloadCSV(n, "myChart.csv");
  }
  getTabularData(t) {
    return Array.isArray(t) ? t : this.transformToTabularData(t);
  }
  sanitize(t) {
    return t = this.getTabularData(t), t;
  }
  /*
   * Data groups
   */
  updateAllDataGroups() {
    this.allDataGroups ? this.getDataGroupNames().forEach((t) => {
      this.allDataGroups.indexOf(t) === -1 && this.allDataGroups.push(t);
    }) : this.allDataGroups = this.getDataGroupNames();
  }
  generateDataGroups(t) {
    const { groupMapsTo: n } = this.getOptions().data, { ACTIVE: r, DISABLED: i } = Bt.items.status, s = this.getOptions(), a = Gi(t.map((l) => l[n]));
    s.data.selectedGroups.length && (s.data.selectedGroups.every(
      (l) => a.includes(l)
    ) || (s.data.selectedGroups = []));
    const o = (l) => !s.data.selectedGroups.length || s.data.selectedGroups.includes(l) ? r : i;
    return a.map((l) => ({
      name: l,
      status: o(l)
    }));
  }
  /*
   * Fill scales
   */
  setCustomColorScale() {
    if (!this.isUserProvidedColorScaleValid())
      return;
    const t = this.getOptions(), n = b(t, "color", "scale");
    Object.keys(n).forEach((r) => {
      this.allDataGroups.includes(r) || console.warn(`"${r}" does not exist in data groups.`);
    }), this.allDataGroups.filter(
      (r) => n[r]
    ).forEach(
      (r) => this.colorScale[r] = n[r]
    );
  }
  /*
   * Color palette
   */
  setColorClassNames() {
    const t = b(this.getOptions(), "color", "pairing");
    let n = b(t, "numberOfVariants");
    (!n || n < this.allDataGroups.length) && (n = this.allDataGroups.length);
    let r = b(t, "option");
    const i = ym.pairingOptions, s = n > 5 ? 14 : n, a = `${s}-color`;
    r = r <= i[a] ? r : 1;
    const o = this.allDataGroups.map(
      (l, c) => `${s}-${r}-${c % 14 + 1}`
    );
    this.colorClassNames = Na().range(o).domain(this.allDataGroups);
  }
}
class or extends Je {
  // can't be protected as it's used by two-dimensional-axes.ts
  constructor(t) {
    super(t), this.axisFlavor = Aa.DEFAULT;
  }
  // get the scales information
  // needed for getTabularArray()
  assignRangeAndDomains() {
    const { cartesianScales: t } = this.services, n = this.getOptions(), r = t.isDualAxes(), i = {
      primaryDomain: t.domainAxisPosition,
      primaryRange: t.rangeAxisPosition,
      secondaryDomain: null,
      secondaryRange: null
    };
    return r && (i.secondaryDomain = t.secondaryDomainAxisPosition, i.secondaryRange = t.secondaryRangeAxisPosition), Object.keys(i).forEach((s) => {
      const a = i[s];
      t.scales[a] ? i[s] = {
        position: a,
        label: t.getScaleLabel(a),
        identifier: b(n, "axes", a, "mapsTo")
      } : i[s] = null;
    }), i;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, { cartesianScales: i } = this.services, { primaryDomain: s, primaryRange: a, secondaryDomain: o, secondaryRange: l } = this.assignRangeAndDomains(), c = i.getDomainAxisScaleType();
    let u;
    return c === X.TIME && (u = (h) => Vr(h, "MMM d, yyyy")), [
      [
        "Group",
        s.label,
        a.label,
        ...o ? [o.label] : [],
        ...l ? [l.label] : []
      ],
      ...t.map((h) => [
        h[r],
        h[s.identifier] === null ? "&ndash;" : u ? u(h[s.identifier]) : h[s.identifier],
        h[a.identifier] === null || isNaN(h[a.identifier]) ? "&ndash;" : h[a.identifier].toLocaleString(),
        ...o ? [
          h[o.identifier] === null ? "&ndash;" : h[o.identifier]
        ] : [],
        ...l ? [
          h[l.identifier] === null || isNaN(h[l.identifier]) ? "&ndash;" : h[l.identifier]
        ] : []
      ])
    ];
  }
  setData(t) {
    let n;
    if (t && (n = super.setData(t), b(this.getOptions(), "zoomBar", H.TOP, "enabled"))) {
      const r = b(
        this.getOptions(),
        "zoomBar",
        H.TOP,
        "data"
      );
      this.setZoomBarData(r);
    }
    return n;
  }
  /**
   * @param zoomBarData any special zoom bar data to use instead of the model data
   */
  setZoomBarData(t) {
    const n = t ? this.sanitize(xn(t)) : this.getDisplayData();
    let r = n;
    const { cartesianScales: i } = this.services;
    if (n && i.domainAxisPosition && i.rangeAxisPosition) {
      const s = i.getDomainIdentifier(), a = i.getRangeIdentifier();
      let o = n.map((l) => l[s].getTime());
      o = Gi(o).sort(), r = o.map((l) => {
        let c = 0;
        const u = {};
        return n.forEach((h) => {
          h[s].getTime() === l && (c += h[a]);
        }), u[s] = new Date(l), u[a] = c, u;
      });
    }
    this.set({ zoomBarData: r });
  }
  getZoomBarData() {
    return this.get("zoomBarData");
  }
  sanitizeDateValues(t) {
    const n = this.getOptions();
    if (!n.axes)
      return t;
    const r = [];
    return Object.keys(H).forEach((i) => {
      const s = H[i], a = n.axes[s];
      if (a && a.scaleType === X.TIME) {
        const o = a.mapsTo;
        (o !== null || o !== void 0) && r.push(o);
      }
    }), r.length > 0 && t.forEach((i) => {
      r.forEach((s) => {
        b(i, s, "getTime") === null && (i[s] = new Date(i[s]));
      });
    }), t;
  }
  sanitize(t) {
    return t = super.sanitize(t), t = this.sanitizeDateValues(t), t;
  }
}
let pL = class extends or {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData();
    return t.sort((n, r) => n.source.localeCompare(r.source)), [
      ["Source", "Target", "Value"],
      ...t.map((n) => [n.source, n.target, n.value])
    ];
  }
}, gL = class extends or {
  constructor(t) {
    super(t);
  }
  getBoxQuartiles(t) {
    return {
      q_25: po(t, 0.25),
      q_50: po(t, 0.5),
      q_75: po(t, 0.75)
    };
  }
  getBoxplotData() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getGroupedData(), i = [];
    for (const { name: s, data: a } of r) {
      const o = this.services.cartesianScales.getRangeIdentifier(), l = a.map((x) => x[o]).sort(zn), c = {
        [n]: s,
        counts: l,
        quartiles: this.getBoxQuartiles(l),
        outliers: null,
        whiskers: null
      }, u = c.quartiles.q_25, h = c.quartiles.q_75, d = (h - u) * 1.5, f = u - d, p = h + d, m = [], g = [];
      for (const x of l)
        x < f || x > p ? m.push(x) : g.push(x);
      c.outliers = m;
      const v = Ln(g), y = qn(g);
      c.whiskers = {
        min: v || Ln([c.quartiles.q_25, c.quartiles.q_50, c.quartiles.q_75]),
        max: y || qn([c.quartiles.q_25, c.quartiles.q_50, c.quartiles.q_75])
      }, i.push(c);
    }
    return i;
  }
  getTabularDataArray() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getBoxplotData();
    return [
      ["Group", "Minimum", "Q1", "Median", "Q3", "Maximum", "IQR", "Outlier(s)"],
      ...r.map((i) => {
        let s = b(i, "outliers");
        return (s === null || s.length === 0) && (s = ["&ndash;"]), [
          i[n],
          b(i, "whiskers", "min") !== null ? b(i, "whiskers", "min").toLocaleString() : "&ndash;",
          b(i, "quartiles", "q_25") !== null ? b(i, "quartiles", "q_25").toLocaleString() : "&ndash;",
          b(i, "quartiles", "q_50") !== null ? b(i, "quartiles", "q_50").toLocaleString() : "&ndash;",
          b(i, "quartiles", "q_75") !== null ? b(i, "quartiles", "q_75").toLocaleString() : "&ndash;",
          b(i, "whiskers", "max") !== null ? b(i, "whiskers", "max").toLocaleString() : "&ndash;",
          b(i, "quartiles", "q_75") !== null && b(i, "quartiles", "q_25") !== null ? (b(i, "quartiles", "q_75") - b(i, "quartiles", "q_25")).toLocaleString() : "&ndash;",
          s.map((a) => a.toLocaleString()).join(",")
        ];
      })
    ];
  }
  setColorClassNames() {
    const t = b(this.getOptions(), "color", "pairing");
    let n = b(t, "option");
    const r = ym.pairingOptions;
    n = n <= r["1-color"] ? n : 1;
    const i = this.allDataGroups.map(() => `1-${n}-1`);
    this.colorClassNames = Na().range(i).domain(this.allDataGroups);
  }
}, mL = class extends or {
  constructor(t) {
    super(t);
  }
  /**
   * Determines the index of the performance area titles to use
   * @param datum
   * @returns number
   */
  getMatchingRangeIndexForDatapoint(t) {
    let n;
    for (let r = t.ranges.length - 1; r > 0; r--) {
      const i = t.ranges[r];
      if (t.value >= i)
        return n = r, n;
    }
    return 0;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier(), s = b(n, "bullet", "performanceAreaTitles");
    return [
      ["Title", "Group", "Value", "Target", "Percentage", "Performance"],
      ...t.map((a) => [
        a.title,
        a[r],
        a.value === null ? "&ndash;" : a.value,
        b(a, "marker") === null ? "&ndash;" : a.marker,
        b(a, "marker") === null ? "&ndash;" : `${Math.floor(a[i] / a.marker * 100)}%`,
        s[this.getMatchingRangeIndexForDatapoint(a)]
      ])
    ];
  }
}, vL = class extends Je {
  constructor(t) {
    super(t), this._colorScale = void 0, this._matrix = {};
  }
  /**
   * @override
   * @param value
   * @returns string
   */
  getFillColor(t) {
    return this._colorScale(t);
  }
  /**
   * Helper function that will generate a dictionary
   */
  getCombinedData() {
    if (Re(this._matrix)) {
      const t = this.getOptions(), n = this.getDisplayData();
      !Re(n) && !Re(t.geoData.objects.countries) && (t.geoData.objects.countries.geometries.forEach((r) => {
        this._matrix[r.properties.NAME] = r;
      }), n.forEach((r) => {
        this._matrix[r.name] ? this._matrix[r.name].value = r.value || null : console.warn(`Data point ${r} is missing geographical data.`);
      }));
    }
    return this._matrix;
  }
  /**
   * Generate tabular data from display data
   * @returns Array<Object>
   */
  getTabularDataArray() {
    const t = this.getDisplayData();
    return [
      ["Country ID", "Country Name", "Value"],
      ...t.map((n) => [
        n.id === null ? "&ndash;" : n.id,
        n.name,
        n.value
      ])
    ];
  }
  // Uses quantize scale to return class names
  getColorClassName(t) {
    return `${t.originalClassName} ${this._colorScale(t.value)}`;
  }
  setColorClassNames() {
    const t = b(this.getOptions(), "color");
    this._colorScale = Am(this.getDisplayData(), t);
  }
}, yL = class extends Je {
  constructor(t) {
    super(t), this.parentNode = !1, this.set({ depth: 2 }, { skipUpdate: !0 });
  }
  setData(t) {
    super.setData(t), this.setDataGroups(), t.length === 1 && (this.parentNode = !0), this.setZoom();
  }
  setOptions(t) {
    const n = this.getOptions(), r = rt({}, t, this.getZoomOptions(t));
    tu(n, r);
    const i = this.getHierarchyLevel(), s = b(n, "circlePack", "hierarchyLevel");
    this.set({
      options: rt(n, r),
      depth: s && s < 4 ? s : i
    });
  }
  getZoomOptions(t) {
    if (!this.getDisplayData())
      return {};
    const n = this.getDisplayData(), r = t || this.getOptions(), i = n.length === 1 && b(n, 0, "children") ? b(n, 0, "children") : n;
    let s = this.getHierarchyLevel();
    return i.some((a) => {
      if (a.children && a.children.some((o) => o.children))
        return s = 3, !1;
    }), b(r, "canvasZoom", "enabled") === !0 && s > 2 ? {
      legend: {
        additionalItems: [
          {
            type: Wt.ZOOM,
            name: "Click to zoom"
          }
        ]
      }
    } : null;
  }
  setZoom(t) {
    this.setOptions(this.getZoomOptions(t));
  }
  // update the hierarchy level
  updateHierarchyLevel(t) {
    this.set({ depth: t });
  }
  getHierarchyLevel() {
    return this.get("depth");
  }
  hasParentNode() {
    return this.parentNode;
  }
  // set the datagroup name on the items that are it's children
  setDataGroups() {
    const t = this.getData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = t.map((s) => {
      const a = s[r];
      return this.setChildrenDataGroup(s, a);
    });
    this.set(
      {
        data: i
      },
      { skipUpdate: !0 }
    );
  }
  // sets name recursively down the node tree
  setChildrenDataGroup(t, n) {
    return t.children ? {
      ...t,
      dataGroupName: n,
      children: t.children.map((r) => this.setChildrenDataGroup(r, n))
    } : { ...t, dataGroupName: n };
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = [["Child", "Parent", "Value"]];
    return t.forEach((r) => {
      let i = r.value ? r.value : 0;
      r.children && (i += this.getChildrenDatums(r.children, r.name, n, 0)), n.push(["&ndash;", r.name, i]);
    }), n;
  }
  /**
   * Recursively determine the relationship between all the nested elements in the child
   * @param children: Object
   * @param parent: String
   * @param result: Array<Object>
   * @param totalSum: number
   * @returns: number
   */
  getChildrenDatums(t, n, r = [], i = 0) {
    const s = n;
    return t.forEach((a) => {
      const o = a.name;
      let l = 0;
      if (a.children)
        a.children.length > 0 && (typeof a.value == "number" && (i += a.value), l += this.getChildrenDatums(a.children, o, r, l), r.push([o, s, l]), i += l);
      else {
        let c = 0;
        typeof a.value == "number" && (c = a.value, i += a.value), r.push([a.name, s, c]);
      }
    }), i;
  }
}, xL = class extends Je {
  constructor(t) {
    super(t);
  }
  getTabularData(t) {
    const n = super.getTabularData(t);
    return t !== n && n.forEach((r) => {
      r.key && r.key !== r.group && (r.group = r.key);
    }), n;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data;
    return [
      ["Group", "Value"],
      ...t.map((i) => [
        i[r],
        i.value === null ? "&ndash;" : i.value.toLocaleString()
      ])
    ];
  }
  sanitize(t) {
    return this.getTabularData(t).sort((n, r) => r.value - n.value);
  }
}, bL = class extends Je {
  constructor(t) {
    super(t);
  }
  getDataGroups() {
    return super.getDataGroups().filter((t) => t.name !== "delta");
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data;
    return [
      ["Group", "Value"],
      ...t.map((i) => [
        i[r],
        i.value === null ? "&ndash;" : i.value.toLocaleString()
      ])
    ];
  }
}, wL = class extends or {
  constructor(t) {
    super(t), this.axisFlavor = Aa.HOVERABLE, this._colorScale = void 0, this._domains = [], this._ranges = [], this._matrix = {};
    const n = b(this.getOptions(), "axes");
    if (b(n, "left", "scaleType") && b(n, "left", "scaleType") !== X.LABELS || b(n, "right", "scaleType") && b(n, "right", "scaleType") !== X.LABELS || b(n, "top", "scaleType") && b(n, "top", "scaleType") !== X.LABELS || b(n, "bottom", "scaleType") && b(n, "bottom", "scaleType") !== X.LABELS)
      throw Error("Heatmap only supports label scaletypes.");
  }
  /**
   * Get min and maximum value of the display data
   * @returns Array consisting of smallest and largest values in  data
   */
  getValueDomain() {
    const t = Ne(this.getDisplayData(), (r) => r.value), n = Be().domain(t).nice().domain();
    if (n[0] > 0)
      n[0] = 0;
    else if (n[0] === 0 && n[1] === 0)
      return [0, 1];
    return n[0] < 0 && n[1] > 0 && (Math.abs(n[0]) > n[1] ? n[1] = Math.abs(n[0]) : n[0] = -n[1]), n;
  }
  /**
   * @override
   * @param value
   * @returns string
   */
  getFillColor(t) {
    return this._colorScale(t);
  }
  /**
   * Generate a list of all unique domains
   * @returns String[]
   */
  getUniqueDomain() {
    if (Re(this._domains)) {
      const t = this.getDisplayData(), { cartesianScales: n } = this.services, r = n.getDomainIdentifier(), i = n.getMainXAxisPosition(), s = n.getCustomDomainValuesByposition(i);
      if (s)
        return s;
      this._domains = Array.from(
        new Set(
          t.map((a) => a[r])
        )
      );
    }
    return this._domains;
  }
  /**
   * Generates a list of all unique ranges
   * @returns String[]
   */
  getUniqueRanges() {
    if (Re(this._ranges)) {
      const t = this.getDisplayData(), { cartesianScales: n } = this.services, r = n.getRangeIdentifier(), i = n.getMainYAxisPosition(), s = n.getCustomDomainValuesByposition(i);
      if (s)
        return s;
      this._ranges = Array.from(
        new Set(
          t.map((a) => a[r])
        )
      );
    }
    return this._ranges;
  }
  /**
   * Generates a matrix (If doesn't exist) and returns it
   * @returns Object
   */
  getMatrix() {
    if (Re(this._matrix)) {
      const t = this.getUniqueDomain(), n = this.getUniqueRanges(), r = this.services.cartesianScales.getDomainIdentifier(), i = this.services.cartesianScales.getRangeIdentifier(), s = {};
      n.forEach((a) => {
        s[a] = {
          value: null,
          index: -1
        };
      }), t.forEach((a) => {
        this._matrix[a] = xn(s);
      }), this.getDisplayData().forEach((a, o) => {
        this._matrix[a[r]][a[i]] = {
          value: a.value,
          index: o
        };
      });
    }
    return this._matrix;
  }
  /**
   *
   * @param newData The new raw data to be set
   */
  setData(t) {
    const n = this.sanitize(xn(t)), r = this.generateDataGroups(n);
    return this.set({
      data: n,
      dataGroups: r
    }), this._domains = [], this._ranges = [], this._matrix = {}, n;
  }
  /**
   * Converts Object matrix into a single array
   * @returns object[]
   */
  getMatrixAsArray() {
    Re(this._matrix) && this.getMatrix();
    const t = this.getUniqueDomain(), n = this.getUniqueRanges(), r = this.services.cartesianScales.getDomainIdentifier(), i = this.services.cartesianScales.getRangeIdentifier(), s = [];
    return t.forEach((a) => {
      n.forEach((o) => {
        const l = {
          value: this._matrix[a][o].value,
          index: this._matrix[a][o].index
        };
        l[r] = a, l[i] = o, s.push(l);
      });
    }), s;
  }
  /**
   * Generate tabular data from display data
   * @returns Array<Object>
   */
  getTabularDataArray() {
    const t = this.getDisplayData(), { primaryDomain: n, primaryRange: r } = this.assignRangeAndDomains();
    return [
      [n.label, r.label, "Value"],
      ...t.map((i) => [
        i[n.identifier] === null ? "&ndash;" : i[n.identifier],
        i[r.identifier] === null ? "&ndash;" : i[r.identifier].toLocaleString(),
        i.value
      ])
    ];
  }
  // Uses quantize scale to return class names
  getColorClassName(t) {
    return `${t.originalClassName} ${this._colorScale(t.value)}`;
  }
  setColorClassNames() {
    const t = this.getOptions(), n = b(t, "color", "gradient", "colors"), r = !Re(n);
    let i = b(t, "color", "pairing", "option");
    const s = this.getValueDomain(), a = s[0] < 0 && s[1] > 0 ? "diverge" : "mono";
    (i < 1 && i > 4 && a === "mono" || i < 1 && i > 2 && a === "diverge") && (i = 1);
    const o = r ? n : [];
    if (!r) {
      const c = a === "diverge" ? 17 : 11;
      for (let u = 1; u < c + 1; u++)
        o.push(`fill-${a}-${i}-${u}`);
    }
    this._colorScale = Cc().domain(s).range(o);
    const l = b(this.getOptions(), "color");
    this._colorScale = Am(this.getDisplayData(), l);
  }
}, _L = class extends or {
  getTabularDataArray() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this.getBinnedStackedData();
    return [
      [
        At(t, "bins.rangeLabel") || "Range",
        ...r.map((i) => At(i, `0.${n}`))
      ],
      ...At(r, 0).map((i, s) => [
        `${At(i, "data.x0")}  ${At(i, "data.x1")}`,
        ...r.map((a) => At(a[s], `data.${At(a[s], n)}`))
      ])
    ];
  }
}, EL = class extends Je {
  constructor(t) {
    super(t);
  }
  getMaximumDomain(t) {
    return t.reduce((n, r) => n + r.value, 0);
  }
  /**
   * Use a provided color for the bar or default to carbon color if no status provided.
   * Defaults to carbon color otherwise.
   * @param group dataset group label
   */
  getFillColor(t) {
    const n = this.getOptions(), r = b(n, "color", "scale"), i = this.getStatus();
    return r || !i ? super.getFillColor(t) : null;
  }
  /**
   * Get the associated status for the data by checking the ranges
   */
  getStatus() {
    const t = this.getOptions(), n = b(this.getDisplayData()), r = (n == null ? void 0 : n.reduce((a, o) => a + o.value, 0)) ?? 0, i = b(t, "meter", "proportional") ? r : r > 100 ? 100 : r, s = b(t, "meter", "status", "ranges");
    if (s) {
      const a = s.filter(
        (o) => o.range[0] <= i && i <= o.range[1]
      );
      if (a.length > 0)
        return a[0].status;
    }
    return null;
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getStatus(), s = b(n, "meter", "proportional");
    let a = [], o;
    if (s === null) {
      o = 100;
      const l = t[0];
      a = [
        ["Group", "Value", ...i ? ["Status"] : []],
        [l[r], l.value, ...i ? [i] : []]
      ];
    } else
      o = b(s, "total") || this.getMaximumDomain(t), a = [
        ["Group", "Value", "Percentage of total"],
        ...t.map((c) => [
          c[r],
          c.value,
          (c.value / o * 100).toFixed(2) + " %"
        ])
      ];
    return a;
  }
}, SL = class extends or {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getOptions(), n = this.getGroupedData(), { angle: r, value: i } = b(t, "radar", "axes"), s = b(n, "0", "data").map((a) => a[r]);
    return [
      ["Group", ...s],
      ...n.map((a) => [
        a.name,
        ...s.map(
          (o, l) => b(a, "data", l, i) !== null ? b(a, "data", l, i).toLocaleString() : "&ndash;"
        )
      ])
    ];
  }
}, OL = class extends Je {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = [["Child", "Parent"]];
    return t.forEach((r) => {
      this.getChildrenDatums(r, n), n.push([r.name, "&ndash;"]);
    }), n;
  }
  /**
   * Determine the child parent relationship in nested data
   * @param datum: Object
   * @param result: Array<Object>
   */
  getChildrenDatums(t, n = []) {
    t.children && t.children.length > 0 && t.children.forEach((r) => {
      this.getChildrenDatums(r, n), n.push([r.name, t.name]);
    });
  }
}, TL = class extends Je {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = [["Child", "Group", "Value"]];
    return t.forEach((r) => {
      Array.isArray(r.children) ? r.children.forEach((i) => {
        n.push([i.name, r.name, i.value]);
      }) : b(r.name) !== null && b(r.value) && n.push(["", r.name, r.value]);
    }), n;
  }
};
class ML extends Je {
  constructor(t) {
    super(t);
  }
  getTabularDataArray() {
    const t = this.getDisplayData(), n = this.getOptions(), { fontSizeMapsTo: r, wordMapsTo: i } = n.wordCloud, { groupMapsTo: s } = n.data;
    return [
      [n.tooltip.wordLabel, "Group", n.tooltip.valueLabel],
      ...t.map((a) => [
        a[i],
        a[s],
        a[r]
      ])
    ];
  }
}
var CL = /\s/;
function $L(e) {
  for (var t = e.length; t-- && CL.test(e.charAt(t)); )
    ;
  return t;
}
var AL = /^\s+/;
function LL(e) {
  return e && e.slice(0, $L(e) + 1).replace(AL, "");
}
var Dd = 0 / 0, DL = /^[-+]0x[0-9a-f]+$/i, kL = /^0b[01]+$/i, RL = /^0o[0-7]+$/i, IL = parseInt;
function $i(e) {
  if (typeof e == "number")
    return e;
  if (ja(e))
    return Dd;
  if (Ae(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Ae(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = LL(e);
  var n = kL.test(e);
  return n || RL.test(e) ? IL(e.slice(2), n ? 2 : 8) : DL.test(e) ? Dd : +e;
}
var NL = function() {
  return He.Date.now();
};
const Go = NL;
var PL = "Expected a function", UL = Math.max, BL = Math.min;
function ba(e, t, n) {
  var r, i, s, a, o, l, c = 0, u = !1, h = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(PL);
  t = $i(t) || 0, Ae(n) && (u = !!n.leading, h = "maxWait" in n, s = h ? UL($i(n.maxWait) || 0, t) : s, d = "trailing" in n ? !!n.trailing : d);
  function f(E) {
    var T = r, k = i;
    return r = i = void 0, c = E, a = e.apply(k, T), a;
  }
  function p(E) {
    return c = E, o = setTimeout(v, t), u ? f(E) : a;
  }
  function m(E) {
    var T = E - l, k = E - c, N = t - T;
    return h ? BL(N, s - k) : N;
  }
  function g(E) {
    var T = E - l, k = E - c;
    return l === void 0 || T >= t || T < 0 || h && k >= s;
  }
  function v() {
    var E = Go();
    if (g(E))
      return y(E);
    o = setTimeout(v, m(E));
  }
  function y(E) {
    return o = void 0, d && r ? f(E) : (r = i = void 0, a);
  }
  function x() {
    o !== void 0 && clearTimeout(o), c = 0, r = l = i = o = void 0;
  }
  function S() {
    return o === void 0 ? a : y(Go());
  }
  function _() {
    var E = Go(), T = g(E);
    if (r = arguments, i = this, l = E, T) {
      if (o === void 0)
        return p(l);
      if (h)
        return clearTimeout(o), o = setTimeout(v, t), f(l);
    }
    return o === void 0 && (o = setTimeout(v, t)), a;
  }
  return _.cancel = x, _.flush = S, _;
}
function VL(e, t) {
  if (e.match(/^[a-z]+:\/\//i))
    return e;
  if (e.match(/^\/\//))
    return window.location.protocol + e;
  if (e.match(/^[a-z]+:/i))
    return e;
  const n = document.implementation.createHTMLDocument(), r = n.createElement("base"), i = n.createElement("a");
  return n.head.appendChild(r), n.body.appendChild(i), t && (r.href = t), i.href = e, i.href;
}
const HL = (() => {
  let e = 0;
  const t = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => (e += 1, `u${t()}${e}`);
})();
function fn(e) {
  const t = [];
  for (let n = 0, r = e.length; n < r; n++)
    t.push(e[n]);
  return t;
}
function wa(e, t) {
  const n = (e.ownerDocument.defaultView || window).getComputedStyle(e).getPropertyValue(t);
  return n ? parseFloat(n.replace("px", "")) : 0;
}
function FL(e) {
  const t = wa(e, "border-left-width"), n = wa(e, "border-right-width");
  return e.clientWidth + t + n;
}
function GL(e) {
  const t = wa(e, "border-top-width"), n = wa(e, "border-bottom-width");
  return e.clientHeight + t + n;
}
function Lm(e, t = {}) {
  const n = t.width || FL(e), r = t.height || GL(e);
  return { width: n, height: r };
}
function zL() {
  let e, t;
  try {
    t = process;
  } catch {
  }
  const n = t && t.env ? t.env.devicePixelRatio : null;
  return n && (e = parseInt(n, 10), Number.isNaN(e) && (e = 1)), e || window.devicePixelRatio || 1;
}
const ve = 16384;
function jL(e) {
  (e.width > ve || e.height > ve) && (e.width > ve && e.height > ve ? e.width > e.height ? (e.height *= ve / e.width, e.width = ve) : (e.width *= ve / e.height, e.height = ve) : e.width > ve ? (e.height *= ve / e.width, e.width = ve) : (e.width *= ve / e.height, e.height = ve));
}
function _a(e) {
  return new Promise((t, n) => {
    const r = new Image();
    r.decode = () => t(r), r.onload = () => t(r), r.onerror = n, r.crossOrigin = "anonymous", r.decoding = "async", r.src = e;
  });
}
async function WL(e) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(e)).then(encodeURIComponent).then((t) => `data:image/svg+xml;charset=utf-8,${t}`);
}
async function qL(e, t, n) {
  const r = "http://www.w3.org/2000/svg", i = document.createElementNS(r, "svg"), s = document.createElementNS(r, "foreignObject");
  return i.setAttribute("width", `${t}`), i.setAttribute("height", `${n}`), i.setAttribute("viewBox", `0 0 ${t} ${n}`), s.setAttribute("width", "100%"), s.setAttribute("height", "100%"), s.setAttribute("x", "0"), s.setAttribute("y", "0"), s.setAttribute("externalResourcesRequired", "true"), i.appendChild(s), s.appendChild(e), WL(i);
}
const pe = (e, t) => {
  if (e instanceof t)
    return !0;
  const n = Object.getPrototypeOf(e);
  return n === null ? !1 : n.constructor.name === t.name || pe(n, t);
};
function YL(e) {
  const t = e.getPropertyValue("content");
  return `${e.cssText} content: '${t.replace(/'|"/g, "")}';`;
}
function XL(e) {
  return fn(e).map((t) => {
    const n = e.getPropertyValue(t), r = e.getPropertyPriority(t);
    return `${t}: ${n}${r ? " !important" : ""};`;
  }).join(" ");
}
function ZL(e, t, n) {
  const r = `.${e}:${t}`, i = n.cssText ? YL(n) : XL(n);
  return document.createTextNode(`${r}{${i}}`);
}
function kd(e, t, n) {
  const r = window.getComputedStyle(e, n), i = r.getPropertyValue("content");
  if (i === "" || i === "none")
    return;
  const s = HL();
  try {
    t.className = `${t.className} ${s}`;
  } catch {
    return;
  }
  const a = document.createElement("style");
  a.appendChild(ZL(s, n, r)), t.appendChild(a);
}
function KL(e, t) {
  kd(e, t, ":before"), kd(e, t, ":after");
}
const Rd = "application/font-woff", Id = "image/jpeg", QL = {
  woff: Rd,
  woff2: Rd,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: Id,
  jpeg: Id,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function JL(e) {
  const t = /\.([^./]*?)$/g.exec(e);
  return t ? t[1] : "";
}
function nu(e) {
  const t = JL(e).toLowerCase();
  return QL[t] || "";
}
function tD(e) {
  return e.split(/,/)[1];
}
function Pl(e) {
  return e.search(/^(data:)/) !== -1;
}
function Dm(e, t) {
  return `data:${t};base64,${e}`;
}
async function km(e, t, n) {
  const r = await fetch(e, t);
  if (r.status === 404)
    throw new Error(`Resource "${r.url}" not found`);
  const i = await r.blob();
  return new Promise((s, a) => {
    const o = new FileReader();
    o.onerror = a, o.onloadend = () => {
      try {
        s(n({ res: r, result: o.result }));
      } catch (l) {
        a(l);
      }
    }, o.readAsDataURL(i);
  });
}
const zo = {};
function eD(e, t, n) {
  let r = e.replace(/\?.*/, "");
  return n && (r = e), /ttf|otf|eot|woff2?/i.test(r) && (r = r.replace(/.*\//, "")), t ? `[${t}]${r}` : r;
}
async function ru(e, t, n) {
  const r = eD(e, t, n.includeQueryParams);
  if (zo[r] != null)
    return zo[r];
  n.cacheBust && (e += (/\?/.test(e) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime());
  let i;
  try {
    const s = await km(e, n.fetchRequestInit, ({ res: a, result: o }) => (t || (t = a.headers.get("Content-Type") || ""), tD(o)));
    i = Dm(s, t);
  } catch (s) {
    i = n.imagePlaceholder || "";
    let a = `Failed to fetch resource: ${e}`;
    s && (a = typeof s == "string" ? s : s.message), a && console.warn(a);
  }
  return zo[r] = i, i;
}
async function nD(e) {
  const t = e.toDataURL();
  return t === "data:," ? e.cloneNode(!1) : _a(t);
}
async function rD(e, t) {
  if (e.currentSrc) {
    const s = document.createElement("canvas"), a = s.getContext("2d");
    s.width = e.clientWidth, s.height = e.clientHeight, a == null || a.drawImage(e, 0, 0, s.width, s.height);
    const o = s.toDataURL();
    return _a(o);
  }
  const n = e.poster, r = nu(n), i = await ru(n, r, t);
  return _a(i);
}
async function iD(e) {
  var t;
  try {
    if (!((t = e == null ? void 0 : e.contentDocument) === null || t === void 0) && t.body)
      return await no(e.contentDocument.body, {}, !0);
  } catch {
  }
  return e.cloneNode(!1);
}
async function sD(e, t) {
  return pe(e, HTMLCanvasElement) ? nD(e) : pe(e, HTMLVideoElement) ? rD(e, t) : pe(e, HTMLIFrameElement) ? iD(e) : e.cloneNode(!1);
}
const aD = (e) => e.tagName != null && e.tagName.toUpperCase() === "SLOT";
async function oD(e, t, n) {
  var r, i;
  let s = [];
  return aD(e) && e.assignedNodes ? s = fn(e.assignedNodes()) : pe(e, HTMLIFrameElement) && !((r = e.contentDocument) === null || r === void 0) && r.body ? s = fn(e.contentDocument.body.childNodes) : s = fn(((i = e.shadowRoot) !== null && i !== void 0 ? i : e).childNodes), s.length === 0 || pe(e, HTMLVideoElement) || await s.reduce((a, o) => a.then(() => no(o, n)).then((l) => {
    l && t.appendChild(l);
  }), Promise.resolve()), t;
}
function lD(e, t) {
  const n = t.style;
  if (!n)
    return;
  const r = window.getComputedStyle(e);
  r.cssText ? (n.cssText = r.cssText, n.transformOrigin = r.transformOrigin) : fn(r).forEach((i) => {
    let s = r.getPropertyValue(i);
    i === "font-size" && s.endsWith("px") && (s = `${Math.floor(parseFloat(s.substring(0, s.length - 2))) - 0.1}px`), pe(e, HTMLIFrameElement) && i === "display" && s === "inline" && (s = "block"), i === "d" && t.getAttribute("d") && (s = `path(${t.getAttribute("d")})`), n.setProperty(i, s, r.getPropertyPriority(i));
  });
}
function cD(e, t) {
  pe(e, HTMLTextAreaElement) && (t.innerHTML = e.value), pe(e, HTMLInputElement) && t.setAttribute("value", e.value);
}
function uD(e, t) {
  if (pe(e, HTMLSelectElement)) {
    const n = t, r = Array.from(n.children).find((i) => e.value === i.getAttribute("value"));
    r && r.setAttribute("selected", "");
  }
}
function hD(e, t) {
  return pe(t, Element) && (lD(e, t), KL(e, t), cD(e, t), uD(e, t)), t;
}
async function dD(e, t) {
  const n = e.querySelectorAll ? e.querySelectorAll("use") : [];
  if (n.length === 0)
    return e;
  const r = {};
  for (let s = 0; s < n.length; s++) {
    const a = n[s].getAttribute("xlink:href");
    if (a) {
      const o = e.querySelector(a), l = document.querySelector(a);
      !o && l && !r[a] && (r[a] = await no(l, t, !0));
    }
  }
  const i = Object.values(r);
  if (i.length) {
    const s = "http://www.w3.org/1999/xhtml", a = document.createElementNS(s, "svg");
    a.setAttribute("xmlns", s), a.style.position = "absolute", a.style.width = "0", a.style.height = "0", a.style.overflow = "hidden", a.style.display = "none";
    const o = document.createElementNS(s, "defs");
    a.appendChild(o);
    for (let l = 0; l < i.length; l++)
      o.appendChild(i[l]);
    e.appendChild(a);
  }
  return e;
}
async function no(e, t, n) {
  return !n && t.filter && !t.filter(e) ? null : Promise.resolve(e).then((r) => sD(r, t)).then((r) => oD(e, r, t)).then((r) => hD(e, r)).then((r) => dD(r, t));
}
const Rm = /url\((['"]?)([^'"]+?)\1\)/g, fD = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g, pD = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function gD(e) {
  const t = e.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${t})(['"]?\\))`, "g");
}
function mD(e) {
  const t = [];
  return e.replace(Rm, (n, r, i) => (t.push(i), n)), t.filter((n) => !Pl(n));
}
async function vD(e, t, n, r, i) {
  try {
    const s = n ? VL(t, n) : t, a = nu(t);
    let o;
    if (i) {
      const l = await i(s);
      o = Dm(l, a);
    } else
      o = await ru(s, a, r);
    return e.replace(gD(t), `$1${o}$3`);
  } catch {
  }
  return e;
}
function yD(e, { preferredFontFormat: t }) {
  return t ? e.replace(pD, (n) => {
    for (; ; ) {
      const [r, , i] = fD.exec(n) || [];
      if (!i)
        return "";
      if (i === t)
        return `src: ${r};`;
    }
  }) : e;
}
function Im(e) {
  return e.search(Rm) !== -1;
}
async function Nm(e, t, n) {
  if (!Im(e))
    return e;
  const r = yD(e, n);
  return mD(r).reduce((i, s) => i.then((a) => vD(a, s, t, n)), Promise.resolve(r));
}
async function ys(e, t, n) {
  var r;
  const i = (r = t.style) === null || r === void 0 ? void 0 : r.getPropertyValue(e);
  if (i) {
    const s = await Nm(i, null, n);
    return t.style.setProperty(e, s, t.style.getPropertyPriority(e)), !0;
  }
  return !1;
}
async function xD(e, t) {
  await ys("background", e, t) || await ys("background-image", e, t), await ys("mask", e, t) || await ys("mask-image", e, t);
}
async function bD(e, t) {
  const n = pe(e, HTMLImageElement);
  if (!(n && !Pl(e.src)) && !(pe(e, SVGImageElement) && !Pl(e.href.baseVal)))
    return;
  const r = n ? e.src : e.href.baseVal, i = await ru(r, nu(r), t);
  await new Promise((s, a) => {
    e.onload = s, e.onerror = a;
    const o = e;
    o.decode && (o.decode = s), o.loading === "lazy" && (o.loading = "eager"), n ? (e.srcset = "", e.src = i) : e.href.baseVal = i;
  });
}
async function wD(e, t) {
  const n = fn(e.childNodes).map((r) => Pm(r, t));
  await Promise.all(n).then(() => e);
}
async function Pm(e, t) {
  pe(e, Element) && (await xD(e, t), await bD(e, t), await wD(e, t));
}
function _D(e, t) {
  const { style: n } = e;
  t.backgroundColor && (n.backgroundColor = t.backgroundColor), t.width && (n.width = `${t.width}px`), t.height && (n.height = `${t.height}px`);
  const r = t.style;
  return r != null && Object.keys(r).forEach((i) => {
    n[i] = r[i];
  }), e;
}
const Nd = {};
async function Pd(e) {
  let t = Nd[e];
  if (t != null)
    return t;
  const n = await (await fetch(e)).text();
  return t = { url: e, cssText: n }, Nd[e] = t, t;
}
async function Ud(e, t) {
  let n = e.cssText;
  const r = /url\(["']?([^"')]+)["']?\)/g, i = (n.match(/url\([^)]+\)/g) || []).map(async (s) => {
    let a = s.replace(r, "$1");
    return a.startsWith("https://") || (a = new URL(a, e.url).href), km(a, t.fetchRequestInit, ({ result: o }) => (n = n.replace(s, `url(${o})`), [s, o]));
  });
  return Promise.all(i).then(() => n);
}
function Bd(e) {
  if (e == null)
    return [];
  const t = [], n = /(\/\*[\s\S]*?\*\/)/gi;
  let r = e.replace(n, "");
  const i = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  for (; ; ) {
    const l = i.exec(r);
    if (l === null)
      break;
    t.push(l[0]);
  }
  r = r.replace(i, "");
  const s = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi, a = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})", o = new RegExp(a, "gi");
  for (; ; ) {
    let l = s.exec(r);
    if (l === null) {
      if (l = o.exec(r), l === null)
        break;
      s.lastIndex = o.lastIndex;
    } else
      o.lastIndex = s.lastIndex;
    t.push(l[0]);
  }
  return t;
}
async function ED(e, t) {
  const n = [], r = [];
  return e.forEach((i) => {
    if ("cssRules" in i)
      try {
        fn(i.cssRules || []).forEach((s, a) => {
          if (s.type === CSSRule.IMPORT_RULE) {
            let o = a + 1;
            const l = s.href, c = Pd(l).then((u) => Ud(u, t)).then((u) => Bd(u).forEach((h) => {
              try {
                i.insertRule(h, h.startsWith("@import") ? o += 1 : i.cssRules.length);
              } catch (d) {
                console.error("Error inserting rule from remote css", {
                  rule: h,
                  error: d
                });
              }
            })).catch((u) => {
              console.error("Error loading remote css", u.toString());
            });
            r.push(c);
          }
        });
      } catch (s) {
        const a = e.find((o) => o.href == null) || document.styleSheets[0];
        i.href != null && r.push(Pd(i.href).then((o) => Ud(o, t)).then((o) => Bd(o).forEach((l) => {
          a.insertRule(l, i.cssRules.length);
        })).catch((o) => {
          console.error("Error loading remote stylesheet", o);
        })), console.error("Error inlining remote css file", s);
      }
  }), Promise.all(r).then(() => (e.forEach((i) => {
    if ("cssRules" in i)
      try {
        fn(i.cssRules || []).forEach((s) => {
          n.push(s);
        });
      } catch (s) {
        console.error(`Error while reading CSS rules from ${i.href}`, s);
      }
  }), n));
}
function SD(e) {
  return e.filter((t) => t.type === CSSRule.FONT_FACE_RULE).filter((t) => Im(t.style.getPropertyValue("src")));
}
async function OD(e, t) {
  if (e.ownerDocument == null)
    throw new Error("Provided element is not within a Document");
  const n = fn(e.ownerDocument.styleSheets), r = await ED(n, t);
  return SD(r);
}
async function TD(e, t) {
  const n = await OD(e, t);
  return (await Promise.all(n.map((r) => {
    const i = r.parentStyleSheet ? r.parentStyleSheet.href : null;
    return Nm(r.cssText, i, t);
  }))).join(`
`);
}
async function MD(e, t) {
  const n = t.fontEmbedCSS != null ? t.fontEmbedCSS : t.skipFonts ? null : await TD(e, t);
  if (n) {
    const r = document.createElement("style"), i = document.createTextNode(n);
    r.appendChild(i), e.firstChild ? e.insertBefore(r, e.firstChild) : e.appendChild(r);
  }
}
async function CD(e, t = {}) {
  const { width: n, height: r } = Lm(e, t), i = await no(e, t, !0);
  return await MD(i, t), await Pm(i, t), _D(i, t), await qL(i, n, r);
}
async function Um(e, t = {}) {
  const { width: n, height: r } = Lm(e, t), i = await CD(e, t), s = await _a(i), a = document.createElement("canvas"), o = a.getContext("2d"), l = t.pixelRatio || zL(), c = t.canvasWidth || n, u = t.canvasHeight || r;
  return a.width = c * l, a.height = u * l, t.skipAutoScale || jL(a), a.style.width = `${c}`, a.style.height = `${u}`, t.backgroundColor && (o.fillStyle = t.backgroundColor, o.fillRect(0, 0, a.width, a.height)), o.drawImage(s, 0, 0, a.width, a.height), a;
}
async function $D(e, t = {}) {
  return (await Um(e, t)).toDataURL();
}
async function AD(e, t = {}) {
  return (await Um(e, t)).toDataURL("image/jpeg", t.quality || 1);
}
class En {
  constructor(t, n) {
    this.model = t, this.services = n, this.init();
  }
  init() {
  }
  update() {
  }
  // Used to pass down information to the components
  setModel(t) {
    this.model = t;
  }
  // Used to pass down services to the components
  setServices(t) {
    this.services = t;
  }
}
const LD = "DONT_STYLE_ME_css_styles_verifier";
class D extends En {
  // initialized in initializeID() called by init()
  constructor(t, n) {
    super(t, n), this.chartID = "";
  }
  static getHTMLElementSize(t) {
    return {
      width: t.clientWidth,
      height: t.clientHeight
    };
  }
  static getSVGElementSize(t, n = {
    useAttrs: !1,
    useClientDimensions: !1,
    useBBox: !1,
    useBoundingRect: !1
  }) {
    t.attr || (t = R(t));
    const r = {
      width: 0,
      height: 0
    }, i = (d) => {
      d && Object.keys(r).forEach((f) => {
        if (d[f]) {
          const p = d[f], m = parseFloat(p);
          p && m > r[f] && ("" + p).indexOf("%") === -1 && (r[f] = m);
        }
      });
    }, s = {
      width: t.attr("width"),
      height: t.attr("height")
    }, a = t.node();
    let o, l, c, u;
    try {
      typeof a.getBBox == "function" && (o = a.getBBox(), l = {
        width: o.width,
        height: o.height
      });
    } catch (d) {
      console.error(d);
    }
    try {
      typeof (a == null ? void 0 : a.getBoundingClientRect) == "function" && (c = a.getBoundingClientRect(), u = {
        width: c.width,
        height: c.height
      });
    } catch (d) {
      console.error(d);
    }
    let h;
    if (a instanceof SVGSVGElement && (h = {
      width: a.clientWidth,
      height: a.clientHeight
    }), n) {
      if (n.useAttrs && (i(s), r.width > 0 && r.height > 0))
        return r;
      if (n.useClientDimensions && (i(h), r.width > 0 && r.height > 0))
        return h;
      if (n.useBBox && (i(l), r.width > 0 && r.height > 0))
        return l;
      if (n.useBoundingRect && (i(u), r.width > 0 && r.height > 0))
        return u;
    }
    try {
      const d = {
        width: b(t.node(), "width", "baseVal", "value"),
        height: b(t.node(), "height", "baseVal", "value")
      };
      i(d);
    } catch {
      i(h), i(l), i(s);
    }
    return r;
  }
  static appendOrSelect(t, n) {
    const r = t.select(`${n}`);
    if (r.empty()) {
      let i = n.split("#"), s, a;
      return i.length === 2 ? (s = i[0], i = i[1].split("."), a = i[0]) : (i = n.split("."), s = i[0]), t.append(s).attr("id", a).attr("class", i.slice(1).join(" "));
    }
    return r;
  }
  init() {
    this.styleHolderElement(), this.initializeID(), this.addMainContainer(), this.model.getOptions().resizable && this.addResizeListener(), this.addHolderListeners(), this.handleFullscreenChange();
  }
  getChartID() {
    return this.chartID;
  }
  generateElementIDString(t) {
    return `chart-${this.chartID}-${t}`;
  }
  initializeID() {
    this.chartID = Math.floor((1 + Math.random()) * 281474976710656).toString(16);
  }
  addMainContainer() {
    const t = this.model.getOptions(), n = b(t, "style", "prefix"), r = R(this.getHolder()).append("div").classed(`${he}--${n}--chart-wrapper`, !0).attr("id", `chart-${this.getChartID()}`).style("height", "100%").style("width", "100%");
    r.append("g").attr("class", LD), this.mainContainer = r.node();
  }
  update() {
    this.styleHolderElement();
  }
  styleHolderElement() {
    const t = this.getHolder(), { width: n, height: r, theme: i } = this.model.getOptions();
    n !== this.width && (t.style.width = n, this.width = n), r !== this.height && (t.style.height = r, this.height = r), R(this.getHolder()).classed(`${he}--chart-holder`, !0).attr("data-carbon-theme", i);
  }
  getHolder() {
    return this.model.get("holder");
  }
  exportToJPG() {
    const t = this, n = this.getHolder(), r = R(n);
    r.classed("filled", !0), AD(this.getMainContainer(), {
      quality: 1,
      // Remove toolbar
      filter: (i) => !(i.classList && i.classList.contains("cds--cc--toolbar"))
    }).then(function(i) {
      var s;
      (s = t.services.files) == null || s.downloadImage(i, "myChart.jpg"), r.classed("filled", !1);
    });
  }
  exportToPNG() {
    const t = this, n = this.getHolder(), r = R(n);
    r.classed("filled", !0), $D(this.getMainContainer(), {
      quality: 1,
      // Remove toolbar
      filter: (i) => !(i.classList && i.classList.contains("cds--cc--toolbar"))
    }).then(function(i) {
      var s;
      (s = t.services.files) == null || s.downloadImage(i, "myChart.png"), r.classed("filled", !1);
    }).catch(function(i) {
      console.error("oops, something went wrong!", i);
    });
  }
  toggleFullscreen() {
    const t = this.getHolder();
    R(t).classed("fullscreen") && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) ? document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen() : t.requestFullscreen ? t.requestFullscreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.msRequestFullscreen && t.msRequestFullscreen();
  }
  handleFullscreenChange() {
    document.addEventListener("fullscreenchange", () => {
      const t = R(this.getHolder()), n = t.classed("fullscreen");
      t.classed("fullscreen", !n);
    });
  }
  setSVGMaxHeight() {
    if (!this.model.getOptions().height) {
      const { height: t } = D.getSVGElementSize(
        R(this.mainContainer),
        {
          useBBox: !0
        }
      ), n = R(this.mainContainer).attr("class"), r = R(this.mainContainer).selectAll(`.${n} > svg`);
      let i = 0;
      r.nodes().forEach(function(s) {
        i += Number(
          D.getSVGElementSize(R(s), {
            useBBox: !0
          }).height
        );
      }), i <= t ? R(this.mainContainer).attr("height", i) : R(this.mainContainer).attr("height", "100%");
    }
  }
  getMainContainer() {
    return this.mainContainer;
  }
  addHolderListeners() {
    const t = this.getHolder();
    t && R(t).on("mouseover", () => {
      var n;
      (n = this.services.events) == null || n.dispatchEvent(O.Chart.MOUSEOVER);
    }).on("mouseout", () => {
      var n;
      (n = this.services.events) == null || n.dispatchEvent(O.Chart.MOUSEOUT);
    });
  }
  addResizeListener() {
    const t = this.getHolder();
    if (!t)
      return;
    let n = t.clientWidth, r = t.clientHeight;
    const i = ba(() => {
      var s;
      t && (Math.abs(n - t.clientWidth) > 1 || Math.abs(r - t.clientHeight) > 1) && (n = t.clientWidth, r = t.clientHeight, (s = this.services.events) == null || s.dispatchEvent(O.Chart.RESIZE));
    }, 12.5);
    new ResizeObserver(i).observe(t);
  }
}
let Ul = class Bm extends En {
  static appendOrUpdateLinearGradient(t) {
    let n = t.svg.select(`defs linearGradient#${t.id}`);
    n.empty() && (n = t.svg.append("defs").append("linearGradient").attr("id", t.id).attr("x1", t.x1).attr("x2", t.x2).attr("y1", t.y1).attr("y2", t.y2)), n.selectAll("stop").remove(), n.selectAll("stop").data(t.stops).enter().append("stop").attr("offset", (r) => r.offset).style("stop-color", (r) => r.color).style("stop-opacity", (r) => r.opacity);
  }
  static getOffsetRatio(t) {
    return (Math.abs(t[1]) * 100 / Math.abs(t[0] - t[1])).toFixed(2) + "%";
  }
  static getStops(t, n) {
    const r = t[0] < 0 && t[1] > 0;
    let i = [
      {
        offset: "0%",
        color: n,
        opacity: "0.6"
      },
      {
        offset: "80%",
        color: n,
        opacity: "0"
      }
    ];
    return r && (i = [
      {
        offset: "0%",
        color: n,
        opacity: "0.6"
      },
      {
        offset: Bm.getOffsetRatio(t),
        color: n,
        opacity: "0"
      },
      {
        offset: "100%",
        color: n,
        opacity: "0.6"
      }
    ]), i;
  }
};
function Vd(e) {
  const t = DD(Vm(e), 360);
  return Tn(t, [0, 10]) || Tn(t, [350, 0]) ? {
    textAnchor: rn.START,
    dominantBaseline: sn.MIDDLE
  } : Tn(t, [10, 80]) ? {
    textAnchor: rn.START,
    dominantBaseline: sn.HANGING
  } : Tn(t, [80, 100]) ? {
    textAnchor: rn.MIDDLE,
    dominantBaseline: sn.HANGING
  } : Tn(t, [100, 170]) ? {
    textAnchor: rn.END,
    dominantBaseline: sn.HANGING
  } : Tn(t, [170, 190]) ? {
    textAnchor: rn.END,
    dominantBaseline: sn.MIDDLE
  } : Tn(t, [190, 260]) ? {
    textAnchor: rn.END,
    dominantBaseline: sn.BASELINE
  } : Tn(t, [260, 280]) ? {
    textAnchor: rn.MIDDLE,
    dominantBaseline: sn.BASELINE
  } : {
    textAnchor: rn.START,
    dominantBaseline: sn.BASELINE
  };
}
function DD(e, t) {
  return (e % t + t) % t;
}
function Tn(e, [t, n]) {
  return e >= t && e <= n;
}
function Vm(e) {
  return e * (180 / Math.PI);
}
function Vt(e, t, n = { x: 0, y: 0 }) {
  const r = t * Math.cos(e) + n.x, i = t * Math.sin(e) + n.y;
  return { x: isNaN(r) ? 0 : r, y: isNaN(i) ? 0 : i };
}
function kD(e, t) {
  return t * Math.sin(e - Math.PI / 2);
}
function Hd(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function RD(e, t) {
  let n;
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e)
      (i = t(i, ++r, e)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function jo(e, t) {
  let n = 0;
  if (t === void 0)
    for (let r of e)
      (r = +r) && (n += r);
  else {
    let r = -1;
    for (let i of e)
      (i = +t(i, ++r, e)) && (n += i);
  }
  return n;
}
function ID(e) {
  return e.depth;
}
function ND(e, t) {
  return t - 1 - e.height;
}
function Hm(e, t) {
  return e.sourceLinks.length ? e.depth : t - 1;
}
function xs(e) {
  return function() {
    return e;
  };
}
function Fd(e, t) {
  return Ea(e.source, t.source) || e.index - t.index;
}
function Gd(e, t) {
  return Ea(e.target, t.target) || e.index - t.index;
}
function Ea(e, t) {
  return e.y0 - t.y0;
}
function Wo(e) {
  return e.value;
}
function PD(e) {
  return e.index;
}
function UD(e) {
  return e.nodes;
}
function BD(e) {
  return e.links;
}
function zd(e, t) {
  const n = e.get(t);
  if (!n)
    throw new Error("missing: " + t);
  return n;
}
function jd({ nodes: e }) {
  for (const t of e) {
    let n = t.y0, r = n;
    for (const i of t.sourceLinks)
      i.y0 = n + i.width / 2, n += i.width;
    for (const i of t.targetLinks)
      i.y1 = r + i.width / 2, r += i.width;
  }
}
function VD() {
  let e = 0, t = 0, n = 1, r = 1, i = 24, s = 8, a, o = PD, l = Hm, c, u, h = UD, d = BD, f = 6;
  function p() {
    const w = { nodes: h.apply(null, arguments), links: d.apply(null, arguments) };
    return m(w), g(w), v(w), y(w), _(w), jd(w), w;
  }
  p.update = function(w) {
    return jd(w), w;
  }, p.nodeId = function(w) {
    return arguments.length ? (o = typeof w == "function" ? w : xs(w), p) : o;
  }, p.nodeAlign = function(w) {
    return arguments.length ? (l = typeof w == "function" ? w : xs(w), p) : l;
  }, p.nodeSort = function(w) {
    return arguments.length ? (c = w, p) : c;
  }, p.nodeWidth = function(w) {
    return arguments.length ? (i = +w, p) : i;
  }, p.nodePadding = function(w) {
    return arguments.length ? (s = a = +w, p) : s;
  }, p.nodes = function(w) {
    return arguments.length ? (h = typeof w == "function" ? w : xs(w), p) : h;
  }, p.links = function(w) {
    return arguments.length ? (d = typeof w == "function" ? w : xs(w), p) : d;
  }, p.linkSort = function(w) {
    return arguments.length ? (u = w, p) : u;
  }, p.size = function(w) {
    return arguments.length ? (e = t = 0, n = +w[0], r = +w[1], p) : [n - e, r - t];
  }, p.extent = function(w) {
    return arguments.length ? (e = +w[0][0], n = +w[1][0], t = +w[0][1], r = +w[1][1], p) : [[e, t], [n, r]];
  }, p.iterations = function(w) {
    return arguments.length ? (f = +w, p) : f;
  };
  function m({ nodes: w, links: P }) {
    for (const [I, B] of w.entries())
      B.index = I, B.sourceLinks = [], B.targetLinks = [];
    const U = new Map(w.map((I, B) => [o(I, B, w), I]));
    for (const [I, B] of P.entries()) {
      B.index = I;
      let { source: j, target: Y } = B;
      typeof j != "object" && (j = B.source = zd(U, j)), typeof Y != "object" && (Y = B.target = zd(U, Y)), j.sourceLinks.push(B), Y.targetLinks.push(B);
    }
    if (u != null)
      for (const { sourceLinks: I, targetLinks: B } of w)
        I.sort(u), B.sort(u);
  }
  function g({ nodes: w }) {
    for (const P of w)
      P.value = P.fixedValue === void 0 ? Math.max(jo(P.sourceLinks, Wo), jo(P.targetLinks, Wo)) : P.fixedValue;
  }
  function v({ nodes: w }) {
    const P = w.length;
    let U = new Set(w), I = /* @__PURE__ */ new Set(), B = 0;
    for (; U.size; ) {
      for (const j of U) {
        j.depth = B;
        for (const { target: Y } of j.sourceLinks)
          I.add(Y);
      }
      if (++B > P)
        throw new Error("circular link");
      U = I, I = /* @__PURE__ */ new Set();
    }
  }
  function y({ nodes: w }) {
    const P = w.length;
    let U = new Set(w), I = /* @__PURE__ */ new Set(), B = 0;
    for (; U.size; ) {
      for (const j of U) {
        j.height = B;
        for (const { source: Y } of j.targetLinks)
          I.add(Y);
      }
      if (++B > P)
        throw new Error("circular link");
      U = I, I = /* @__PURE__ */ new Set();
    }
  }
  function x({ nodes: w }) {
    const P = Hd(w, (B) => B.depth) + 1, U = (n - e - i) / (P - 1), I = new Array(P);
    for (const B of w) {
      const j = Math.max(0, Math.min(P - 1, Math.floor(l.call(null, B, P))));
      B.layer = j, B.x0 = e + j * U, B.x1 = B.x0 + i, I[j] ? I[j].push(B) : I[j] = [B];
    }
    if (c)
      for (const B of I)
        B.sort(c);
    return I;
  }
  function S(w) {
    const P = RD(w, (U) => (r - t - (U.length - 1) * a) / jo(U, Wo));
    for (const U of w) {
      let I = t;
      for (const B of U) {
        B.y0 = I, B.y1 = I + B.value * P, I = B.y1 + a;
        for (const j of B.sourceLinks)
          j.width = j.value * P;
      }
      I = (r - I + a) / (U.length + 1);
      for (let B = 0; B < U.length; ++B) {
        const j = U[B];
        j.y0 += I * (B + 1), j.y1 += I * (B + 1);
      }
      V(U);
    }
  }
  function _(w) {
    const P = x(w);
    a = Math.min(s, (r - t) / (Hd(P, (U) => U.length) - 1)), S(P);
    for (let U = 0; U < f; ++U) {
      const I = Math.pow(0.99, U), B = Math.max(1 - I, (U + 1) / f);
      T(P, I, B), E(P, I, B);
    }
  }
  function E(w, P, U) {
    for (let I = 1, B = w.length; I < B; ++I) {
      const j = w[I];
      for (const Y of j) {
        let J = 0, ft = 0;
        for (const { source: Z, value: ut } of Y.targetLinks) {
          let nt = ut * (Y.layer - Z.layer);
          J += M(Z, Y) * nt, ft += nt;
        }
        if (!(ft > 0))
          continue;
        let z = (J / ft - Y.y0) * P;
        Y.y0 += z, Y.y1 += z, C(Y);
      }
      c === void 0 && j.sort(Ea), k(j, U);
    }
  }
  function T(w, P, U) {
    for (let I = w.length, B = I - 2; B >= 0; --B) {
      const j = w[B];
      for (const Y of j) {
        let J = 0, ft = 0;
        for (const { target: Z, value: ut } of Y.sourceLinks) {
          let nt = ut * (Z.layer - Y.layer);
          J += A(Y, Z) * nt, ft += nt;
        }
        if (!(ft > 0))
          continue;
        let z = (J / ft - Y.y0) * P;
        Y.y0 += z, Y.y1 += z, C(Y);
      }
      c === void 0 && j.sort(Ea), k(j, U);
    }
  }
  function k(w, P) {
    const U = w.length >> 1, I = w[U];
    L(w, I.y0 - a, U - 1, P), N(w, I.y1 + a, U + 1, P), L(w, r, w.length - 1, P), N(w, t, 0, P);
  }
  function N(w, P, U, I) {
    for (; U < w.length; ++U) {
      const B = w[U], j = (P - B.y0) * I;
      j > 1e-6 && (B.y0 += j, B.y1 += j), P = B.y1 + a;
    }
  }
  function L(w, P, U, I) {
    for (; U >= 0; --U) {
      const B = w[U], j = (B.y1 - P) * I;
      j > 1e-6 && (B.y0 -= j, B.y1 -= j), P = B.y0 - a;
    }
  }
  function C({ sourceLinks: w, targetLinks: P }) {
    if (u === void 0) {
      for (const { source: { sourceLinks: U } } of P)
        U.sort(Gd);
      for (const { target: { targetLinks: U } } of w)
        U.sort(Fd);
    }
  }
  function V(w) {
    if (u === void 0)
      for (const { sourceLinks: P, targetLinks: U } of w)
        P.sort(Gd), U.sort(Fd);
  }
  function M(w, P) {
    let U = w.y0 - (w.sourceLinks.length - 1) * a / 2;
    for (const { target: I, width: B } of w.sourceLinks) {
      if (I === P)
        break;
      U += B + a;
    }
    for (const { source: I, width: B } of P.targetLinks) {
      if (I === w)
        break;
      U -= B;
    }
    return U;
  }
  function A(w, P) {
    let U = P.y0 - (P.targetLinks.length - 1) * a / 2;
    for (const { source: I, width: B } of P.targetLinks) {
      if (I === w)
        break;
      U += B + a;
    }
    for (const { target: I, width: B } of w.sourceLinks) {
      if (I === P)
        break;
      U -= B;
    }
    return U;
  }
  return p;
}
var Bl = Math.PI, Vl = 2 * Bl, Hn = 1e-6, HD = Vl - Hn;
function Hl() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function Fm() {
  return new Hl();
}
Hl.prototype = Fm.prototype = {
  constructor: Hl,
  moveTo: function(e, t) {
    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(e, t) {
    this._ += "L" + (this._x1 = +e) + "," + (this._y1 = +t);
  },
  quadraticCurveTo: function(e, t, n, r) {
    this._ += "Q" + +e + "," + +t + "," + (this._x1 = +n) + "," + (this._y1 = +r);
  },
  bezierCurveTo: function(e, t, n, r, i, s) {
    this._ += "C" + +e + "," + +t + "," + +n + "," + +r + "," + (this._x1 = +i) + "," + (this._y1 = +s);
  },
  arcTo: function(e, t, n, r, i) {
    e = +e, t = +t, n = +n, r = +r, i = +i;
    var s = this._x1, a = this._y1, o = n - e, l = r - t, c = s - e, u = a - t, h = c * c + u * u;
    if (i < 0)
      throw new Error("negative radius: " + i);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = e) + "," + (this._y1 = t);
    else if (h > Hn)
      if (!(Math.abs(u * o - l * c) > Hn) || !i)
        this._ += "L" + (this._x1 = e) + "," + (this._y1 = t);
      else {
        var d = n - s, f = r - a, p = o * o + l * l, m = d * d + f * f, g = Math.sqrt(p), v = Math.sqrt(h), y = i * Math.tan((Bl - Math.acos((p + h - m) / (2 * g * v))) / 2), x = y / v, S = y / g;
        Math.abs(x - 1) > Hn && (this._ += "L" + (e + x * c) + "," + (t + x * u)), this._ += "A" + i + "," + i + ",0,0," + +(u * d > c * f) + "," + (this._x1 = e + S * o) + "," + (this._y1 = t + S * l);
      }
  },
  arc: function(e, t, n, r, i, s) {
    e = +e, t = +t, n = +n, s = !!s;
    var a = n * Math.cos(r), o = n * Math.sin(r), l = e + a, c = t + o, u = 1 ^ s, h = s ? r - i : i - r;
    if (n < 0)
      throw new Error("negative radius: " + n);
    this._x1 === null ? this._ += "M" + l + "," + c : (Math.abs(this._x1 - l) > Hn || Math.abs(this._y1 - c) > Hn) && (this._ += "L" + l + "," + c), n && (h < 0 && (h = h % Vl + Vl), h > HD ? this._ += "A" + n + "," + n + ",0,1," + u + "," + (e - a) + "," + (t - o) + "A" + n + "," + n + ",0,1," + u + "," + (this._x1 = l) + "," + (this._y1 = c) : h > Hn && (this._ += "A" + n + "," + n + ",0," + +(h >= Bl) + "," + u + "," + (this._x1 = e + n * Math.cos(i)) + "," + (this._y1 = t + n * Math.sin(i))));
  },
  rect: function(e, t, n, r) {
    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t) + "h" + +n + "v" + +r + "h" + -n + "Z";
  },
  toString: function() {
    return this._;
  }
};
function Wd(e) {
  return function() {
    return e;
  };
}
function FD(e) {
  return e[0];
}
function GD(e) {
  return e[1];
}
var zD = Array.prototype.slice;
function jD(e) {
  return e.source;
}
function WD(e) {
  return e.target;
}
function qD(e) {
  var t = jD, n = WD, r = FD, i = GD, s = null;
  function a() {
    var o, l = zD.call(arguments), c = t.apply(this, l), u = n.apply(this, l);
    if (s || (s = o = Fm()), e(s, +r.apply(this, (l[0] = c, l)), +i.apply(this, l), +r.apply(this, (l[0] = u, l)), +i.apply(this, l)), o)
      return s = null, o + "" || null;
  }
  return a.source = function(o) {
    return arguments.length ? (t = o, a) : t;
  }, a.target = function(o) {
    return arguments.length ? (n = o, a) : n;
  }, a.x = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : Wd(+o), a) : r;
  }, a.y = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : Wd(+o), a) : i;
  }, a.context = function(o) {
    return arguments.length ? (s = o ?? null, a) : s;
  }, a;
}
function YD(e, t, n, r, i) {
  e.moveTo(t, n), e.bezierCurveTo(t = (t + r) / 2, n, t, i, r, i);
}
function XD() {
  return qD(YD);
}
function ZD(e) {
  return [e.source.x1, e.y0];
}
function KD(e) {
  return [e.target.x0, e.y1];
}
function QD() {
  return XD().source(ZD).target(KD);
}
function Gm(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function JD(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var tk = { value: function() {
} };
function zm() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r))
      throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new Rs(n);
}
function Rs(e) {
  this._ = e;
}
function ek(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
Rs.prototype = zm.prototype = {
  constructor: Rs,
  on: function(e, t) {
    var n = this._, r = ek(e + "", n), i, s = -1, a = r.length;
    if (arguments.length < 2) {
      for (; ++s < a; )
        if ((i = (e = r[s]).type) && (i = nk(n[i], e.name)))
          return i;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++s < a; )
      if (i = (e = r[s]).type)
        n[i] = qd(n[i], e.name, t);
      else if (t == null)
        for (i in n)
          n[i] = qd(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new Rs(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), r = 0, i, s; r < i; ++r)
        n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (s = this._[e], r = 0, i = s.length; r < i; ++r)
      s[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var r = this._[e], i = 0, s = r.length; i < s; ++i)
      r[i].value.apply(t, n);
  }
};
function nk(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function qd(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      e[r] = tk, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
const rk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dispatch: zm
}, Symbol.toStringTag, { value: "Module" })), ik = /* @__PURE__ */ JD(rk), sk = ik.dispatch, qo = Math.PI / 180, ak = {
  archimedean: jm,
  rectangular: vk
}, xi = 64, Is = 2048;
var ok = function() {
  var e = [256, 256], t = lk, n = ck, r = uk, i = Yd, s = Yd, a = hk, o = dk, l = jm, c = [], u = 1 / 0, h = sk("word", "end"), d = null, f = Math.random, p = {}, m = xk;
  p.canvas = function(y) {
    return arguments.length ? (m = Mn(y), p) : m;
  }, p.start = function() {
    var y = g(m()), x = yk((e[0] >> 5) * e[1]), S = null, _ = c.length, E = -1, T = [], k = c.map(function(L, C) {
      return L.text = t.call(this, L, C), L.font = n.call(this, L, C), L.style = i.call(this, L, C), L.weight = s.call(this, L, C), L.rotate = a.call(this, L, C), L.size = ~~r.call(this, L, C), L.padding = o.call(this, L, C), L;
    }).sort(function(L, C) {
      return C.size - L.size;
    });
    return d && clearInterval(d), d = setInterval(N, 0), N(), p;
    function N() {
      for (var L = Date.now(); Date.now() - L < u && ++E < _ && d; ) {
        var C = k[E];
        C.x = e[0] * (f() + 0.5) >> 1, C.y = e[1] * (f() + 0.5) >> 1, fk(y, C, k, E), C.hasText && v(x, C, S) && (T.push(C), h.call("word", p, C), S ? gk(S, C) : S = [{ x: C.x + C.x0, y: C.y + C.y0 }, { x: C.x + C.x1, y: C.y + C.y1 }], C.x -= e[0] >> 1, C.y -= e[1] >> 1);
      }
      E >= _ && (p.stop(), h.call("end", p, T, S));
    }
  }, p.stop = function() {
    d && (clearInterval(d), d = null);
    for (const y of c)
      delete y.sprite;
    return p;
  };
  function g(y) {
    const x = y.getContext("2d", { willReadFrequently: !0 });
    y.width = y.height = 1;
    const S = Math.sqrt(x.getImageData(0, 0, 1, 1).data.length >> 2);
    return y.width = (xi << 5) / S, y.height = Is / S, x.fillStyle = x.strokeStyle = "red", { context: x, ratio: S };
  }
  function v(y, x, S) {
    e[0], e[1];
    for (var _ = x.x, E = x.y, T = Math.sqrt(e[0] * e[0] + e[1] * e[1]), k = l(e), N = f() < 0.5 ? 1 : -1, L = -N, C, V, M; (C = k(L += N)) && (V = ~~C[0], M = ~~C[1], !(Math.min(Math.abs(V), Math.abs(M)) >= T)); )
      if (x.x = _ + V, x.y = E + M, !(x.x + x.x0 < 0 || x.y + x.y0 < 0 || x.x + x.x1 > e[0] || x.y + x.y1 > e[1]) && (!S || mk(x, S)) && !pk(x, y, e[0])) {
        for (var A = x.sprite, w = x.width >> 5, P = e[0] >> 5, U = x.x - (w << 4), I = U & 127, B = 32 - I, j = x.y1 - x.y0, Y = (x.y + x.y0) * P + (U >> 5), J, ft = 0; ft < j; ft++) {
          J = 0;
          for (var z = 0; z <= w; z++)
            y[Y + z] |= J << B | (z < w ? (J = A[ft * w + z]) >>> I : 0);
          Y += P;
        }
        return !0;
      }
    return !1;
  }
  return p.timeInterval = function(y) {
    return arguments.length ? (u = y ?? 1 / 0, p) : u;
  }, p.words = function(y) {
    return arguments.length ? (c = y, p) : c;
  }, p.size = function(y) {
    return arguments.length ? (e = [+y[0], +y[1]], p) : e;
  }, p.font = function(y) {
    return arguments.length ? (n = Mn(y), p) : n;
  }, p.fontStyle = function(y) {
    return arguments.length ? (i = Mn(y), p) : i;
  }, p.fontWeight = function(y) {
    return arguments.length ? (s = Mn(y), p) : s;
  }, p.rotate = function(y) {
    return arguments.length ? (a = Mn(y), p) : a;
  }, p.text = function(y) {
    return arguments.length ? (t = Mn(y), p) : t;
  }, p.spiral = function(y) {
    return arguments.length ? (l = ak[y] || y, p) : l;
  }, p.fontSize = function(y) {
    return arguments.length ? (r = Mn(y), p) : r;
  }, p.padding = function(y) {
    return arguments.length ? (o = Mn(y), p) : o;
  }, p.random = function(y) {
    return arguments.length ? (f = y, p) : f;
  }, p.on = function() {
    var y = h.on.apply(h, arguments);
    return y === h ? p : y;
  }, p;
};
function lk(e) {
  return e.text;
}
function ck() {
  return "serif";
}
function Yd() {
  return "normal";
}
function uk(e) {
  return Math.sqrt(e.value);
}
function hk() {
  return (~~(random() * 6) - 3) * 30;
}
function dk() {
  return 1;
}
function fk(e, t, n, r) {
  if (!t.sprite) {
    var i = e.context, s = e.ratio;
    i.clearRect(0, 0, (xi << 5) / s, Is / s);
    var a = 0, o = 0, l = 0, c = n.length;
    for (--r; ++r < c; ) {
      t = n[r], i.save(), i.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / s) + "px " + t.font;
      const C = i.measureText(t.text), V = -Math.floor(C.width / 2);
      let M = (C.width + 1) * s, A = t.size << 1;
      if (t.rotate) {
        var u = Math.sin(t.rotate * qo), h = Math.cos(t.rotate * qo), d = M * h, f = M * u, p = A * h, m = A * u;
        M = Math.max(Math.abs(d + m), Math.abs(d - m)) + 31 >> 5 << 5, A = ~~Math.max(Math.abs(f + p), Math.abs(f - p));
      } else
        M = M + 31 >> 5 << 5;
      if (A > l && (l = A), a + M >= xi << 5 && (a = 0, o += l, l = 0), o + A >= Is)
        break;
      i.translate((a + (M >> 1)) / s, (o + (A >> 1)) / s), t.rotate && i.rotate(t.rotate * qo), i.fillText(t.text, V, 0), t.padding && (i.lineWidth = 2 * t.padding, i.strokeText(t.text, V, 0)), i.restore(), t.width = M, t.height = A, t.xoff = a, t.yoff = o, t.x1 = M >> 1, t.y1 = A >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, a += M;
    }
    for (var g = i.getImageData(0, 0, (xi << 5) / s, Is / s).data, v = []; --r >= 0; )
      if (t = n[r], !!t.hasText) {
        for (var y = t.width, x = y >> 5, S = t.y1 - t.y0, _ = 0; _ < S * x; _++)
          v[_] = 0;
        if (a = t.xoff, a == null)
          return;
        o = t.yoff;
        for (var E = 0, T = -1, k = 0; k < S; k++) {
          for (var _ = 0; _ < y; _++) {
            var N = x * k + (_ >> 5), L = g[(o + k) * (xi << 5) + (a + _) << 2] ? 1 << 31 - _ % 32 : 0;
            v[N] |= L, E |= L;
          }
          E ? T = k : (t.y0++, S--, k--, o++);
        }
        t.y1 = t.y0 + T, t.sprite = v.slice(0, (t.y1 - t.y0) * x);
      }
  }
}
function pk(e, t, n) {
  n >>= 5;
  for (var r = e.sprite, i = e.width >> 5, s = e.x - (i << 4), a = s & 127, o = 32 - a, l = e.y1 - e.y0, c = (e.y + e.y0) * n + (s >> 5), u, h = 0; h < l; h++) {
    u = 0;
    for (var d = 0; d <= i; d++)
      if ((u << o | (d < i ? (u = r[h * i + d]) >>> a : 0)) & t[c + d])
        return !0;
    c += n;
  }
  return !1;
}
function gk(e, t) {
  var n = e[0], r = e[1];
  t.x + t.x0 < n.x && (n.x = t.x + t.x0), t.y + t.y0 < n.y && (n.y = t.y + t.y0), t.x + t.x1 > r.x && (r.x = t.x + t.x1), t.y + t.y1 > r.y && (r.y = t.y + t.y1);
}
function mk(e, t) {
  return e.x + e.x1 > t[0].x && e.x + e.x0 < t[1].x && e.y + e.y1 > t[0].y && e.y + e.y0 < t[1].y;
}
function jm(e) {
  var t = e[0] / e[1];
  return function(n) {
    return [t * (n *= 0.1) * Math.cos(n), n * Math.sin(n)];
  };
}
function vk(e) {
  var t = 4, n = t * e[0] / e[1], r = 0, i = 0;
  return function(s) {
    var a = s < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * a * s) - a & 3) {
      case 0:
        r += n;
        break;
      case 1:
        i += t;
        break;
      case 2:
        r -= n;
        break;
      default:
        i -= t;
        break;
    }
    return [r, i];
  };
}
function yk(e) {
  for (var t = [], n = -1; ++n < e; )
    t[n] = 0;
  return t;
}
function xk() {
  return document.createElement("canvas");
}
function Mn(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const bk = /* @__PURE__ */ Gm(ok);
function wk(e, t, n, r) {
  var i = -1, s = e == null ? 0 : e.length;
  for (r && s && (n = e[++i]); ++i < s; )
    n = t(n, e[i], i, e);
  return n;
}
function _k(e) {
  return function(t) {
    return e == null ? void 0 : e[t];
  };
}
var Ek = {
  // Latin-1 Supplement block.
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "C",
  : "c",
  : "D",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "N",
  : "n",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "Y",
  : "y",
  : "y",
  : "Ae",
  : "ae",
  : "Th",
  : "th",
  : "ss",
  // Latin Extended-A block.
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "C",
  : "C",
  : "C",
  : "C",
  : "c",
  : "c",
  : "c",
  : "c",
  : "D",
  : "D",
  : "d",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "G",
  : "G",
  : "G",
  : "G",
  : "g",
  : "g",
  : "g",
  : "g",
  : "H",
  : "H",
  : "h",
  : "h",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "J",
  : "j",
  : "K",
  : "k",
  : "k",
  : "L",
  : "L",
  : "L",
  : "L",
  : "L",
  : "l",
  : "l",
  : "l",
  : "l",
  : "l",
  : "N",
  : "N",
  : "N",
  : "N",
  : "n",
  : "n",
  : "n",
  : "n",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "R",
  : "R",
  : "R",
  : "r",
  : "r",
  : "r",
  : "S",
  : "S",
  : "S",
  : "S",
  : "s",
  : "s",
  : "s",
  : "s",
  : "T",
  : "T",
  : "T",
  : "t",
  : "t",
  : "t",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "W",
  : "w",
  : "Y",
  : "y",
  : "Y",
  : "Z",
  : "Z",
  : "Z",
  : "z",
  : "z",
  : "z",
  : "IJ",
  : "ij",
  : "Oe",
  : "oe",
  : "'n",
  : "s"
}, Sk = _k(Ek);
const Ok = Sk;
var Tk = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Mk = "\\u0300-\\u036f", Ck = "\\ufe20-\\ufe2f", $k = "\\u20d0-\\u20ff", Ak = Mk + Ck + $k, Lk = "[" + Ak + "]", Dk = RegExp(Lk, "g");
function kk(e) {
  return e = ns(e), e && e.replace(Tk, Ok).replace(Dk, "");
}
var Rk = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function Ik(e) {
  return e.match(Rk) || [];
}
var Nk = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function Pk(e) {
  return Nk.test(e);
}
var Wm = "\\ud800-\\udfff", Uk = "\\u0300-\\u036f", Bk = "\\ufe20-\\ufe2f", Vk = "\\u20d0-\\u20ff", Hk = Uk + Bk + Vk, qm = "\\u2700-\\u27bf", Ym = "a-z\\xdf-\\xf6\\xf8-\\xff", Fk = "\\xac\\xb1\\xd7\\xf7", Gk = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", zk = "\\u2000-\\u206f", jk = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Xm = "A-Z\\xc0-\\xd6\\xd8-\\xde", Wk = "\\ufe0e\\ufe0f", Zm = Fk + Gk + zk + jk, Km = "[']", Xd = "[" + Zm + "]", qk = "[" + Hk + "]", Qm = "\\d+", Yk = "[" + qm + "]", Jm = "[" + Ym + "]", tv = "[^" + Wm + Zm + Qm + qm + Ym + Xm + "]", Xk = "\\ud83c[\\udffb-\\udfff]", Zk = "(?:" + qk + "|" + Xk + ")", Kk = "[^" + Wm + "]", ev = "(?:\\ud83c[\\udde6-\\uddff]){2}", nv = "[\\ud800-\\udbff][\\udc00-\\udfff]", br = "[" + Xm + "]", Qk = "\\u200d", Zd = "(?:" + Jm + "|" + tv + ")", Jk = "(?:" + br + "|" + tv + ")", Kd = "(?:" + Km + "(?:d|ll|m|re|s|t|ve))?", Qd = "(?:" + Km + "(?:D|LL|M|RE|S|T|VE))?", rv = Zk + "?", iv = "[" + Wk + "]?", tR = "(?:" + Qk + "(?:" + [Kk, ev, nv].join("|") + ")" + iv + rv + ")*", eR = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", nR = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rR = iv + rv + tR, iR = "(?:" + [Yk, ev, nv].join("|") + ")" + rR, sR = RegExp([
  br + "?" + Jm + "+" + Kd + "(?=" + [Xd, br, "$"].join("|") + ")",
  Jk + "+" + Qd + "(?=" + [Xd, br + Zd, "$"].join("|") + ")",
  br + "?" + Zd + "+" + Kd,
  br + "+" + Qd,
  nR,
  eR,
  Qm,
  iR
].join("|"), "g");
function aR(e) {
  return e.match(sR) || [];
}
function oR(e, t, n) {
  return e = ns(e), t = n ? void 0 : t, t === void 0 ? Pk(e) ? aR(e) : Ik(e) : e.match(t) || [];
}
var lR = "[']", cR = RegExp(lR, "g");
function sv(e) {
  return function(t) {
    return wk(oR(kk(t).replace(cR, "")), e, "");
  };
}
function uR(e, t, n) {
  return e === e && (n !== void 0 && (e = e <= n ? e : n), t !== void 0 && (e = e >= t ? e : t)), e;
}
function av(e, t, n) {
  return n === void 0 && (n = t, t = void 0), n !== void 0 && (n = $i(n), n = n === n ? n : 0), t !== void 0 && (t = $i(t), t = t === t ? t : 0), uR($i(e), t, n);
}
function hR(e, t) {
  var n = -1, r = ar(e) ? Array(e.length) : [];
  return eu(e, function(i, s, a) {
    r[++n] = t(i, s, a);
  }), r;
}
function dR(e, t) {
  var n = ee(e) ? Bg : hR;
  return n(e, to(t));
}
var fR = 1 / 0;
function pR(e, t) {
  return Qa(dR(e, t), fR);
}
function ov(e, t) {
  return Ja(e, t);
}
var gR = sv(function(e, t, n) {
  return e + (n ? "-" : "") + t.toLowerCase();
});
const pr = gR;
function mR(e, t) {
  var n;
  return eu(e, function(r, i, s) {
    return n = t(r, i, s), !n;
  }), !!n;
}
function vR(e, t, n) {
  var r = ee(e) ? um : mR;
  return n && zg(e, t, n) && (t = void 0), r(e, to(t));
}
class dt {
  constructor(t, n, r) {
    if (this.type = "", this.renderType = K.HTML, this.id = "", this.parent = void 0, this.configs = {}, this.model = t, this.services = n, r && (this.configs = r, this.configs.id)) {
      const i = b(this.model.getOptions(), "style", "prefix");
      this.id = `${i}--${this.configs.id}`;
    }
    this.parent || this.setParent(R(this.services.domUtils.getMainContainer()));
  }
  init() {
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    console.error("Error: Component did not provide the required render function.");
  }
  destroy() {
  }
  // Used to pass down information to the components
  setModel(t) {
    this.model = t;
  }
  // Used to pass down information to the components
  setServices(t) {
    this.services = t;
  }
  setParent(t) {
    var n;
    const r = this.parent;
    if (this.parent = t, !(r && r.node() === t.node()) && this.type) {
      const i = b(this.model.getOptions(), "style", "prefix");
      (n = this.parent) == null || n.classed(`${he}--${i}--${this.type}`, !0), r && r.classed(`${he}--${i}--${this.type}`, !1);
    }
  }
  getParent() {
    return this.parent;
  }
  getComponentContainer(t = { withinChartClip: !1 }) {
    if (this.type) {
      const n = b(this.model.getOptions(), "style", "prefix"), r = this.id ? `#${this.id}` : "", i = D.appendOrSelect(
        this.parent,
        `${this.renderType === K.SVG ? "svg" : "div"}${r}.${he}--${n}--${this.type}`
      );
      if (t.withinChartClip) {
        const s = this.model.get("chartClipId");
        if (s) {
          const a = R(`#${s}`).select("rect");
          a.size() !== 0 && parseFloat(a.attr("height")) > 0 && i.attr("clip-path", `url(#${s})`);
        }
      }
      return i.attr("width", "100%").attr("height", "100%");
    }
    return this.parent;
  }
  /**
   * graphs used in combo charts share a model with global options but can receive their own local options.
   * this function retrieves the global options and merges it with any options passed into this
   * component's config.options object.
   */
  getOptions() {
    return this.configs.options ? rt({}, this.model.getOptions(), this.configs.options) : this.model.getOptions();
  }
}
const lv = class cv extends dt {
  constructor() {
    super(...arguments), this.type = "toolbar", this.renderType = K.HTML;
  }
  init() {
    const t = () => this.updateOverflowMenu(!1);
    this.services.events.addEventListener(O.Toolbar.SHOW_OVERFLOW_MENU, () => {
      this.renderOverflowMenu(), document.body.addEventListener("click", t);
    }), this.services.events.addEventListener(O.Toolbar.HIDE_OVERFLOW_MENU, () => {
      document.body.removeEventListener("click", t);
    });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer().attr("role", "toolbar").attr("aria-label", `chart-${this.services.domUtils.getChartID()} toolbar`);
    if (b(this.getOptions(), "data", "loading"))
      n.html(""), this.overflowMenu = null;
    else {
      this.overflowMenu || (this.overflowMenu = n.append("div").attr(
        "class",
        "cds--overflow-menu-options cds--overflow-menu--flip cds--overflow-menu-options cds--overflow-menu--flip"
      ).attr("tabindex", -1).html("<ul role='menu'></ul>"));
      const { buttonList: r, overflowMenuItemList: i } = this.getControlConfigs();
      i && r.push(this.getOverflowButtonConfig());
      const s = n.selectAll("div.toolbar-control").data(r, (l) => l.id);
      s.exit().remove();
      const a = s.enter().append("div").attr("class", "toolbar-control cds--overflow-menu cds--overflow-menu").attr("role", "button"), o = this;
      a.merge(s).classed("disabled", (l) => l.shouldBeDisabled()).attr("aria-disabled", (l) => l.shouldBeDisabled()).attr("aria-label", (l) => l.title).html(
        (l) => `
			<button
				class="cds--overflow-menu__trigger cds--overflow-menu__trigger"
				aria-haspopup="true" aria-expanded="false" id="${this.services.domUtils.generateElementIDString(
          `control-${l.id}`
        )}" aria-label="${l.title}">
				<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" class="cds--overflow-menu__icon cds--overflow-menu__icon" viewBox="0 0 32 32" aria-hidden="true">
					${l.iconSVG.content}
				</svg>
			</button>`
      ).each(function(l, c) {
        R(this).select("svg").style("will-change", "transform").style("width", l.iconSVG.width !== void 0 ? l.iconSVG.width : "20px").style("height", l.iconSVG.height !== void 0 ? l.iconSVG.height : "20px"), R(this).select("button").on("click", (u) => {
          l.shouldBeDisabled() || o.triggerFunctionAndEvent(l, u, this);
        }).on("keydown", (u) => {
          u.key && u.key === "Enter" || u.key === " " ? (u.preventDefault(), o.triggerFunctionAndEvent(l, u, this)) : u.key && u.key === "ArrowLeft" ? o.focusOnPreviousEnabledToolbarItem(c) : u.key && u.key === "ArrowRight" && o.focusOnNextEnabledToolbarItem(c);
        });
      }), this.overflowButton = this.getComponentContainer().select(
        `button.cds--overflow-menu__trigger#${this.services.domUtils.generateElementIDString(
          "control-toolbar-overflow-menu"
        )}`
      );
    }
  }
  renderOverflowMenu() {
    const { overflowMenuItemList: t } = this.getControlConfigs(), n = this.overflowMenu.select("ul").selectAll("li.cds--overflow-menu-options__option").data(t, (i) => b(i, "id"));
    n.exit().remove();
    const r = n.enter().append("li").attr("id", (i) => this.services.domUtils.generateElementIDString(`control-${i.id}`)).attr("class", "cds--overflow-menu-options__option cds--overflow-menu-options__option").attr("role", "menuitem").attr("tabindex", 1);
    r.append("button").attr("class", "cds--overflow-menu-options__btn cds--overflow-menu-options__btn"), r.merge(n).classed("cds--overflow-menu-options__option--disabled", (i) => i.shouldBeDisabled()).classed("cds--overflow-menu-options__option--disabled", (i) => i.shouldBeDisabled()).attr("aria-disabled", (i) => i.shouldBeDisabled()).selectAll("button").text((i) => i.text);
  }
  isOverflowMenuOpen() {
    return this.overflowMenu.classed("is-open");
  }
  // show/hide overflow menu
  updateOverflowMenu(t) {
    this.overflowMenu && (this.overflowMenu.classed("is-open", t), this.overflowButton && (this.overflowButton.attr("aria-expanded", t), R(this.overflowButton.node().parentNode).classed("cds--overflow-menu--open", t).classed("cds--overflow-menu--open", t)), t ? this.services.events.dispatchEvent(O.Toolbar.SHOW_OVERFLOW_MENU) : this.services.events.dispatchEvent(O.Toolbar.HIDE_OVERFLOW_MENU));
  }
  // Toolbar controllers
  focusOnPreviousEnabledToolbarItem(t) {
    const n = this.getToolbarButtonItems();
    let r = n.length;
    for (let i = t - 1; i >= 0; i--)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r < n.length) {
      const i = R(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )}`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnNextEnabledToolbarItem(t) {
    const n = this.getToolbarButtonItems();
    let r = -1;
    for (let i = t + 1; i < n.length; i++)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r > -1) {
      const i = R(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )}`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnPreviousEnabledMenuItem(t) {
    const n = this.getOverflowMenuItems();
    let r = n.length;
    for (let i = t - 1; i >= 0; i--)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r < n.length) {
      const i = R(
        `#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )} button`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnNextEnabledMenuItem(t) {
    const n = this.getOverflowMenuItems();
    let r = -1;
    for (let i = t + 1; i < n.length; i++)
      if (!n[i].shouldBeDisabled()) {
        r = i;
        break;
      }
    if (r > -1) {
      const i = R(
        `#${this.services.domUtils.generateElementIDString(
          `control-${n[r].id}`
        )} button`
      ).node();
      "focus" in i && i.focus();
    }
  }
  toggleOverflowMenu(t) {
    if (this.isOverflowMenuOpen())
      this.updateOverflowMenu(!1);
    else {
      this.updateOverflowMenu(!0);
      const n = this;
      this.getOverflowMenuItems().forEach((r, i) => {
        const s = R(
          `#${this.services.domUtils.generateElementIDString(`control-${r.id}`)}`
        );
        s !== null && (s.on("click", () => {
          n.triggerFunctionAndEvent(r, t, s.node()), n.updateOverflowMenu(!1);
        }), s.on("keydown", (a) => {
          a && a.key === "Enter" ? n.triggerFunctionAndEvent(r, t, s.node()) : a && a.key === "ArrowUp" ? n.focusOnPreviousEnabledMenuItem(i) : a && a.key === "ArrowDown" ? n.focusOnNextEnabledMenuItem(i) : a && a.key === "Escape" && n.updateOverflowMenu(!1), a.preventDefault();
        }));
      }), n.focusOnNextEnabledMenuItem(-1);
    }
    t && t.stopImmediatePropagation();
  }
  // Calls passed function && dispatches event
  triggerFunctionAndEvent(t, n, r) {
    typeof t.shouldBeDisabled == "function" && t.shouldBeDisabled() || (typeof t.clickFunction == "function" && t.clickFunction(n), this.services.events.dispatchEvent(O.Toolbar.BUTTON_CLICK, {
      control: t,
      event: n,
      element: r
    }));
  }
  getControlConfigs() {
    const t = b(this.getOptions(), "toolbar", "numberOfIcons") - 1, n = b(this.getOptions(), "toolbar", "controls"), r = [], i = [], s = [];
    return n.forEach((a) => {
      let o = null;
      a.type === Ut.CUSTOM ? (b(a, "id") === null && (a.id = `toolbar-button-${cv.buttonID++}`), b(a, "shouldBeDisabled") === null && (a.shouldBeDisabled = () => !1), o = a) : o = this.getControlConfigByType(a.type), o && (o.text = a.text ? a.text : a.type, o.id.indexOf("toolbar-export") !== -1 ? r.push(o) : i.length < t ? b(o, "iconSVG", "content") === null ? s.push(o) : i.push(o) : s.push(o));
    }), s.push(...r), s.length ? {
      buttonList: i,
      overflowMenuItemList: s
    } : {
      buttonList: i
    };
  }
  getToolbarButtonItems() {
    const { buttonList: t, overflowMenuItemList: n } = this.getControlConfigs();
    return n && t.push(this.getOverflowButtonConfig()), t || [];
  }
  getOverflowMenuItems() {
    const { overflowMenuItemList: t } = this.getControlConfigs();
    return t || [];
  }
  // special button config for overflow button
  getOverflowButtonConfig() {
    return {
      id: "toolbar-overflow-menu",
      title: "More options",
      shouldBeDisabled: () => !1,
      iconSVG: {
        content: `<circle cx="16" cy="8" r="2"></circle>
				<circle cx="16" cy="16" r="2"></circle>
				<circle cx="16" cy="24" r="2"></circle>`
      },
      clickFunction: (t) => this.toggleOverflowMenu(t)
    };
  }
  getControlConfigByType(t) {
    const n = this.services.zoom && this.services.zoom.isZoomBarEnabled() && !this.services.zoom.isEmptyState(), r = this.model.getDisplayData();
    let i;
    switch (t) {
      case Ut.ZOOM_IN:
        n && (i = {
          id: "toolbar-zoomIn",
          title: "Zoom in",
          shouldBeDisabled: () => this.services.zoom.isMinZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomIn()
        });
        break;
      case Ut.ZOOM_OUT:
        n && (i = {
          id: "toolbar-zoomOut",
          title: "Zoom out",
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomOut()
        });
        break;
      case Ut.RESET_ZOOM:
        n && (i = {
          id: "toolbar-resetZoom",
          title: "Reset zoom",
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.resetZoomDomain()
        });
        break;
      case Ut.MAKE_FULLSCREEN:
        i = {
          id: "toolbar-makefullscreen",
          iconSVG: {
            content: this.getControlIconByType(t),
            width: "15px",
            height: "15px"
          },
          title: "Make fullscreen",
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case Ut.SHOW_AS_DATATABLE:
        i = {
          id: "toolbar-showasdatatable",
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          title: "Show as table",
          shouldBeDisabled: () => r.length === 0,
          clickFunction: () => this.services.events.dispatchEvent(O.Modal.SHOW)
        };
        break;
      case Ut.EXPORT_CSV:
        i = {
          id: "toolbar-export-CSV",
          title: "Export as CSV",
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.model.exportToCSV()
        };
        break;
      case Ut.EXPORT_PNG:
        i = {
          id: "toolbar-export-PNG",
          title: "Export as PNG",
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToPNG()
        };
        break;
      case Ut.EXPORT_JPG:
        i = {
          id: "toolbar-export-JPG",
          title: "Export as JPG",
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToJPG()
        };
        break;
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
    return i;
  }
  getControlIconByType(t) {
    switch (t) {
      case Ut.ZOOM_IN:
        return `<polygon points="19 13 15 13 15 9 13 9 13 13 9 13 9 15 13 15 13 19 15 19 15 15 19 15 19 13"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case Ut.ZOOM_OUT:
        return `<rect x="9" y="13" width="10" height="2"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case Ut.RESET_ZOOM:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case Ut.MAKE_FULLSCREEN:
        return '<polygon points="21 2 21 4 26.59 4 17 13.58 18.41 15 28 5.41 28 11 30 11 30 2 21 2"/><polygon points="15 18.42 13.59 17 4 26.59 4 21 2 21 2 30 11 30 11 28 5.41 28 15 18.42"/>';
      case Ut.SHOW_AS_DATATABLE:
        return '<rect x="4" y="6" width="18" height="2"/><rect x="4" y="12" width="18" height="2"/><rect x="4" y="18" width="18" height="2"/><rect x="4" y="24" width="18" height="2"/><rect x="26" y="6" width="2" height="2"/><rect x="26" y="12" width="2" height="2"/><rect x="26" y="18" width="2" height="2"/><rect x="26" y="24" width="2" height="2"/>';
      case Ut.EXPORT_CSV:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case Ut.EXPORT_JPG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case Ut.EXPORT_PNG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
  }
};
lv.buttonID = 0;
let ro = lv;
const uv = class hv extends dt {
  constructor(t, n, r, i) {
    super(t, n, i), this.type = "layout", this.configs = i, this.children = r, this._instanceID = hv.instanceID++, this.init();
  }
  init() {
    this.children.forEach((t) => {
      t.components.forEach((n) => {
        n.init();
      });
    });
  }
  getPreferedAndFixedSizeSum() {
    const t = this.parent;
    let n = 0;
    return t.selectAll(`div.layout-child-${this._instanceID}`).filter((r) => {
      const i = b(r, "growth");
      return i === st.PREFERRED || i === st.FIXED;
    }).each(function(r) {
      n += r.size;
    }), n;
  }
  getNumOfStretchChildren() {
    return this.parent.selectAll(`div.layout-child-${this._instanceID}`).filter((t) => b(t, "growth") === st.STRETCH).size();
  }
  render(t = !0) {
    const n = this.parent, { width: r, height: i } = D.getHTMLElementSize(n.node()), s = this.configs.direction === Lt.ROW || this.configs.direction === Lt.ROW_REVERSE, a = b(this.model.getOptions(), "style", "prefix"), o = n.classed(
      `${he}--${a}--layout-row`,
      this.configs.direction === Lt.ROW
    ).classed(
      `${he}--${a}--layout-row-reverse`,
      this.configs.direction === Lt.ROW_REVERSE
    ).classed(
      `${he}--${a}--layout-column`,
      this.configs.direction === Lt.COLUMN
    ).classed(
      `${he}--${a}--layout-column-reverse`,
      this.configs.direction === Lt.COLUMN_REVERSE
    ).classed(
      `${he}--${a}--layout-alignitems-center`,
      this.configs.alignItems === Wr.CENTER
    ).selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (c) => c.id);
    o.enter().append("div").merge(n.selectAll(`div.layout-child-${this._instanceID}`)).attr("class", (c) => `layout-child layout-child-${this._instanceID} ${c.id}`).each(function(c) {
      c.components.forEach((u) => {
        const h = R(this), d = b(c, "renderType") === K.SVG;
        u.setParent(
          d ? D.appendOrSelect(h, "svg.layout-svg-wrapper").attr("width", "100%").attr("height", "100%") : h
        );
        const f = b(c, "growth");
        (f === st.PREFERRED || f === st.FIXED) && u.render(t);
      });
    }), n.selectAll(`div.layout-child-${this._instanceID}`).style("height", null).style("width", null).each(function(c) {
      const u = b(c, "growth"), h = b(c, "renderType") === K.SVG ? D.getSVGElementSize(R(this).select("svg.layout-svg-wrapper"), {
        useBBox: !0
      }) : D.getHTMLElementSize(this);
      if (u === st.PREFERRED) {
        const d = s ? h.width : h.height, f = s ? r : i;
        c.size = d / f * 100;
      }
    }), o.exit().remove(), this.children.filter((c) => b(c, "growth") === st.STRETCH).forEach((c) => {
      c.size = (100 - +this.getPreferedAndFixedSizeSum()) / +this.getNumOfStretchChildren();
    });
    const l = n.selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (c) => c.id);
    s ? l.style("width", (c) => `${c.size / 100 * r}px`).style("height", "100%") : l.style("height", (c) => `${c.size / 100 * i}px`).style("width", "100%"), l.each(function(c) {
      c.components.forEach((u) => {
        b(c, "growth") === st.STRETCH && u.render(t);
      });
    });
  }
  // Pass on model to children as well
  setModel(t) {
    super.setModel(t), this.children.forEach((n) => {
      n.components.forEach((r) => r.setModel(t));
    });
  }
  // Pass on essentials to children as well
  setServices(t) {
    super.setServices(t), this.children.forEach((n) => {
      n.components.forEach((r) => r.setServices(t));
    });
  }
  destroy() {
    this.children.forEach((t) => {
      t.components.forEach((n) => n.destroy());
    });
  }
};
uv.instanceID = Math.floor(Math.random() * 99999999999);
let be = uv;
class bn extends dt {
  constructor() {
    super(...arguments), this.type = "spacer";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    this.getComponentContainer().style("width", `${this.configs.size || Cd.default.size}px`).style("height", `${this.configs.size || Cd.default.size}px`).attr("opacity", 0);
  }
}
var yR = {
  prefix: "bx",
  selectorTabbable: `
    a[href], area[href], input:not([disabled]):not([tabindex='-1']),
    button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
    textarea:not([disabled]):not([tabindex='-1']),
    iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]
  `,
  selectorFocusable: `
    a[href], area[href], input:not([disabled]),
    button:not([disabled]),select:not([disabled]),
    textarea:not([disabled]),
    iframe, object, embed, *[tabindex], *[contenteditable=true]
  `
}, Yo = yR;
function Jd(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function xR(e, t, n) {
  return t && Jd(e.prototype, t), n && Jd(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function bR(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function wR(e) {
  return OR(e) || SR(e) || ER(e) || _R();
}
function _R() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ER(e, t) {
  if (e) {
    if (typeof e == "string")
      return Fl(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Fl(e, t);
  }
}
function SR(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function OR(e) {
  if (Array.isArray(e))
    return Fl(e);
}
function Fl(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function dv(e) {
  return e.reduce(function(t, n) {
    return Array.isArray(n) ? t.push.apply(t, wR(dv(n))) : t.push(n), t;
  }, []);
}
function TR() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return dv(t).reduce(function(r, i) {
    return i(r);
  }, /* @__PURE__ */ function() {
    function r() {
      bR(this, r);
    }
    return xR(r);
  }());
}
function Gl(e) {
  "@babel/helpers - typeof";
  return Gl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Gl(e);
}
function MR(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function tf(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function CR(e, t, n) {
  return t && tf(e.prototype, t), n && tf(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function $R(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && zl(e, t);
}
function zl(e, t) {
  return zl = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, zl(e, t);
}
function AR(e) {
  var t = DR();
  return function() {
    var n = Sa(e), r;
    if (t) {
      var i = Sa(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return LR(this, r);
  };
}
function LR(e, t) {
  if (t && (Gl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return fv(e);
}
function fv(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function DR() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Sa(e) {
  return Sa = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Sa(e);
}
function kR(e) {
  var t = /* @__PURE__ */ function(n) {
    $R(i, n);
    var r = AR(i);
    function i(s) {
      var a, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (MR(this, i), a = r.call(this, s, o), a.children = [], !s || s.nodeType !== Node.ELEMENT_NODE)
        throw new TypeError("DOM element should be given to initialize this widget.");
      return a.element = s, a.options = Object.assign(Object.create(a.constructor.options), o), a.constructor.components.set(a.element, fv(a)), a;
    }
    return CR(i, [{
      key: "release",
      value: (
        /**
         * Releases this component's instance from the associated element.
         */
        function() {
          for (var s = this.children.pop(); s; s = this.children.pop())
            s.release();
          return this.constructor.components.delete(this.element), null;
        }
      )
    }], [{
      key: "create",
      value: function(s, a) {
        return this.components.get(s) || new this(s, a);
      }
    }]), i;
  }(e);
  return t;
}
function jl(e) {
  "@babel/helpers - typeof";
  return jl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, jl(e);
}
function RR(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ef(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function IR(e, t, n) {
  return t && ef(e.prototype, t), n && ef(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Ns() {
  return typeof Reflect < "u" && Reflect.get ? Ns = Reflect.get : Ns = function(e, t, n) {
    var r = NR(e, t);
    if (r) {
      var i = Object.getOwnPropertyDescriptor(r, t);
      return i.get ? i.get.call(arguments.length < 3 ? e : n) : i.value;
    }
  }, Ns.apply(this, arguments);
}
function NR(e, t) {
  for (; !Object.prototype.hasOwnProperty.call(e, t) && (e = jr(e), e !== null); )
    ;
  return e;
}
function PR(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Wl(e, t);
}
function Wl(e, t) {
  return Wl = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, Wl(e, t);
}
function UR(e) {
  var t = HR();
  return function() {
    var n = jr(e), r;
    if (t) {
      var i = jr(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return BR(this, r);
  };
}
function BR(e, t) {
  if (t && (jl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return VR(e);
}
function VR(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function HR() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function jr(e) {
  return jr = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, jr(e);
}
function FR(e) {
  var t = /* @__PURE__ */ function(n) {
    PR(i, n);
    var r = UR(i);
    function i() {
      var s;
      RR(this, i);
      for (var a = arguments.length, o = new Array(a), l = 0; l < a; l++)
        o[l] = arguments[l];
      return s = r.call.apply(r, [this].concat(o)), s.handles = /* @__PURE__ */ new Set(), s;
    }
    return IR(i, [{
      key: "manage",
      value: (
        /**
         * Manages the given handle.
         * @param {Handle} handle The handle to manage.
         * @returns {Handle} The given handle.
         */
        function(s) {
          return this.handles.add(s), s;
        }
      )
      /**
       * Stop managing the given handle.
       * @param {Handle} handle The handle to stop managing.
       * @returns {Handle} The given handle.
       */
    }, {
      key: "unmanage",
      value: function(s) {
        return this.handles.delete(s), s;
      }
    }, {
      key: "release",
      value: function() {
        var s = this;
        return this.handles.forEach(function(a) {
          a.release(), s.handles.delete(a);
        }), Ns(jr(i.prototype), "release", this).call(this);
      }
    }]), i;
  }(e);
  return t;
}
function bi(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return e.addEventListener.apply(e, n), {
    release: function() {
      return e.removeEventListener.apply(e, n), null;
    }
  };
}
function ql(e) {
  "@babel/helpers - typeof";
  return ql = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ql(e);
}
function GR(e) {
  return qR(e) || WR(e) || jR(e) || zR();
}
function zR() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function jR(e, t) {
  if (e) {
    if (typeof e == "string")
      return Yl(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Yl(e, t);
  }
}
function WR(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function qR(e) {
  if (Array.isArray(e))
    return Yl(e);
}
function Yl(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function YR(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function nf(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function XR(e, t, n) {
  return t && nf(e.prototype, t), n && nf(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function ZR(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Xl(e, t);
}
function Xl(e, t) {
  return Xl = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, Xl(e, t);
}
function KR(e) {
  var t = tI();
  return function() {
    var n = Oa(e), r;
    if (t) {
      var i = Oa(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return QR(this, r);
  };
}
function QR(e, t) {
  if (t && (ql(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return JR(e);
}
function JR(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function tI() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Oa(e) {
  return Oa = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Oa(e);
}
function eI(e) {
  var t = /* @__PURE__ */ function(n) {
    ZR(i, n);
    var r = KR(i);
    function i() {
      return YR(this, i), r.apply(this, arguments);
    }
    return XR(i, [{
      key: "_changeState",
      value: (
        /* eslint-disable jsdoc/check-param-names */
        /**
         * The internal implementation for {@link EventedState#changeState `.changeState()`}, performing actual change in state.
         * @param {string} [state] The new state. Can be an omitted, which means toggling.
         * @param {object} [detail]
         *   The object that should be put to event details that is fired before/after changing state.
         *   Can have a `group` property, which specifies what state to be changed.
         * @param {EventedState~changeStateCallback} callback The callback called once changing state is finished or is canceled.
         * @private
         */
        function() {
          throw new Error("_changeState() should be overridden to perform actual change in state.");
        }
      )
      /**
       * Changes the state of this component.
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @param {EventedState~changeStateCallback} [callback] The callback called once changing state is finished or is canceled.
       */
    }, {
      key: "changeState",
      value: function() {
        for (var s = this, a = arguments.length, o = new Array(a), l = 0; l < a; l++)
          o[l] = arguments[l];
        var c = typeof o[0] == "string" ? o.shift() : void 0, u = Object(o[0]) === o[0] && typeof o[0] != "function" ? o.shift() : void 0, h = typeof o[0] == "function" ? o.shift() : void 0;
        if (typeof this.shouldStateBeChanged == "function" && !this.shouldStateBeChanged(c, u)) {
          h && h(null, !0);
          return;
        }
        var d = {
          group: u && u.group,
          state: c
        }, f = [d.group, c].filter(Boolean).join("-").split("-").map(function(x) {
          return x[0].toUpperCase() + x.substr(1);
        }).join(""), p = new CustomEvent(this.options["eventBefore".concat(f)], {
          bubbles: !0,
          cancelable: !0,
          detail: u
        }), m = u && u.delegatorNode || this.element, g = !m.dispatchEvent(p);
        if (g) {
          if (h) {
            var v = new Error("Changing state (".concat(JSON.stringify(d), ") has been canceled."));
            v.canceled = !0, h(v);
          }
        } else {
          var y = [c, u].filter(Boolean);
          this._changeState.apply(this, GR(y).concat([function() {
            m.dispatchEvent(new CustomEvent(s.options["eventAfter".concat(f)], {
              bubbles: !0,
              cancelable: !0,
              detail: u
            })), h && h();
          }]));
        }
      }
      /* eslint-enable jsdoc/check-param-names */
      /**
       * Tests if change in state should happen or not.
       * Classes inheriting {@link EventedState `EventedState`} should override this function.
       * @function EventedState#shouldStateBeChanged
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @returns {boolean}
       *   `false` if change in state shouldn't happen, e.g. when the given new state is the same as the current one.
       */
    }]), i;
  }(e);
  return t;
}
function Zl(e, t) {
  var n = e.target, r = e.currentTarget;
  if (typeof n.matches == "function") {
    if (n.matches(t))
      return n;
    if (n.matches("".concat(t, " *"))) {
      var i = n.closest(t);
      if ((r.nodeType === Node.DOCUMENT_NODE ? r.documentElement : r).contains(i))
        return i;
    }
  }
}
function rf(e) {
  if (!e || typeof e == "function")
    return {
      launchingElement: null,
      launchingEvent: null
    };
  var t = e.delegateTarget || e.currentTarget || e, n = e.currentTarget && e;
  if (t && !t.nodeType)
    throw new TypeError("DOM Node should be given for launching element.");
  if (n && !n.type)
    throw new TypeError("DOM event should be given for launching event.");
  return {
    launchingElement: t,
    launchingEvent: n
  };
}
function Kl(e) {
  "@babel/helpers - typeof";
  return Kl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Kl(e);
}
function nI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function sf(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function rI(e, t, n) {
  return t && sf(e.prototype, t), n && sf(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function iI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Ql(e, t);
}
function Ql(e, t) {
  return Ql = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, Ql(e, t);
}
function sI(e) {
  var t = lI();
  return function() {
    var n = Ta(e), r;
    if (t) {
      var i = Ta(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return aI(this, r);
  };
}
function aI(e, t) {
  if (t && (Kl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return oI(e);
}
function oI(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function lI() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ta(e) {
  return Ta = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Ta(e);
}
function cI(e) {
  var t = /* @__PURE__ */ function(n) {
    iI(i, n);
    var r = sI(i);
    function i() {
      return nI(this, i), r.apply(this, arguments);
    }
    return rI(i, [{
      key: "show",
      value: (
        /**
         */
        /**
         * Switch to 'shown' state.
         * @param [evtOrElem] The launching event or element.
         * @param {EventedState~changeStateCallback} [callback] The callback.
         */
        function(s, a) {
          (!s || typeof s == "function") && (a = s), this.changeState("shown", rf(s), a);
        }
      )
      /**
       * Switch to 'hidden' state.
       * @param [evtOrElem] The launching event or element.
       * @param {EventedState~changeStateCallback} [callback] The callback.
       */
    }, {
      key: "hide",
      value: function(s, a) {
        (!s || typeof s == "function") && (a = s), this.changeState("hidden", rf(s), a);
      }
    }]), i;
  }(e);
  return t;
}
var uI = [eI, cI];
const hI = uI;
function dI(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var pv = function() {
};
process.env.NODE_ENV !== "production" && (pv = function(e, t, n) {
  var r = arguments.length;
  n = new Array(r > 2 ? r - 2 : 0);
  for (var i = 2; i < r; i++)
    n[i - 2] = arguments[i];
  if (t === void 0)
    throw new Error(
      "`warning(condition, format, ...args)` requires a warning message argument"
    );
  if (t.length < 10 || /^[s\W]*$/.test(t))
    throw new Error(
      "The warning format should be able to uniquely identify this warning. Please, use a more descriptive format than: " + t
    );
  if (!e) {
    var s = 0, a = "Warning: " + t.replace(/%s/g, function() {
      return n[s++];
    });
    typeof console < "u" && console.error(a);
    try {
      throw new Error(a);
    } catch {
    }
  }
});
var fI = pv;
const pI = /* @__PURE__ */ dI(fI);
function Jl(e) {
  "@babel/helpers - typeof";
  return Jl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Jl(e);
}
function gI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function af(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function mI(e, t, n) {
  return t && af(e.prototype, t), n && af(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function vI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && tc(e, t);
}
function tc(e, t) {
  return tc = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, tc(e, t);
}
function yI(e) {
  var t = wI();
  return function() {
    var n = Ma(e), r;
    if (t) {
      var i = Ma(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return xI(this, r);
  };
}
function xI(e, t) {
  if (t && (Jl(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return bI(e);
}
function bI(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function wI() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ma(e) {
  return Ma = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Ma(e);
}
function _I(e) {
  var t = /* @__PURE__ */ function(n) {
    vI(i, n);
    var r = yI(i);
    function i() {
      return gI(this, i), r.apply(this, arguments);
    }
    return mI(i, null, [{
      key: "init",
      value: (
        /**
         * `true` suggests that this component is lazily initialized upon an action/event, etc.
         * @type {boolean}
         */
        /**
         * Instantiates this component in the given element.
         * If the given element indicates that it's an component of this class, instantiates it.
         * Otherwise, instantiates this component by clicking on launcher buttons
         * (buttons with attribute that `options.attribInitTarget` points to) of this component in the given node.
         * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.
         * @param {object} [options] The component options.
         * @param {string} [options.selectorInit] The CSS selector to find this component.
         * @param {string} [options.attribInitTarget] The attribute name in the launcher buttons to find target component.
         * @returns {Handle} The handle to remove the event listener to handle clicking.
         */
        function() {
          var s = this, a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = Object.assign(Object.create(this.options), o);
          if (!a || a.nodeType !== Node.ELEMENT_NODE && a.nodeType !== Node.DOCUMENT_NODE)
            throw new TypeError("DOM document or DOM element should be given to search for and initialize this widget.");
          if (a.nodeType === Node.ELEMENT_NODE && a.matches(l.selectorInit))
            this.create(a, o);
          else {
            var c = l.initEventNames.map(function(u) {
              return bi(a, u, function(h) {
                var d = Zl(h, "[".concat(l.attribInitTarget, "]"));
                if (d) {
                  h.delegateTarget = d;
                  var f = d.ownerDocument.querySelectorAll(d.getAttribute(l.attribInitTarget));
                  if (f.length > 1)
                    throw new Error("Target widget must be unique.");
                  if (f.length === 1) {
                    d.tagName === "A" && h.preventDefault();
                    var p = s.create(f[0], o);
                    typeof p.createdByLauncher == "function" && p.createdByLauncher(h);
                  }
                }
              });
            });
            return {
              release: function() {
                for (var u = c.pop(); u; u = c.pop())
                  u.release();
              }
            };
          }
          return "";
        }
      )
    }]), i.forLazyInit = !0, i;
  }(e);
  return t;
}
function ec(e) {
  "@babel/helpers - typeof";
  return ec = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ec(e);
}
function EI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function of(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function SI(e, t, n) {
  return t && of(e.prototype, t), n && of(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function OI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && nc(e, t);
}
function nc(e, t) {
  return nc = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n;
  }, nc(e, t);
}
function TI(e) {
  var t = $I();
  return function() {
    var n = Ca(e), r;
    if (t) {
      var i = Ca(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else
      r = n.apply(this, arguments);
    return MI(this, r);
  };
}
function MI(e, t) {
  if (t && (ec(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return CI(e);
}
function CI(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function $I() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ca(e) {
  return Ca = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Ca(e);
}
var AI = /* @__PURE__ */ function(e) {
  OI(n, e);
  var t = TI(n);
  function n(r, i) {
    var s;
    return EI(this, n), s = t.call(this, r, i), s._handleFocusinListener = void 0, s._handleKeydownListener = void 0, s._handleFocusin = function(a) {
      var o = s.element.querySelector(s.options.selectorModalContainer) || s.element;
      s.element.classList.contains(s.options.classVisible) && !o.contains(a.target) && s.options.selectorsFloatingMenus.every(function(l) {
        return !Zl(a, l);
      }) && s.element.querySelector(Yo.selectorTabbable).focus();
    }, s._hookCloseActions(), s;
  }
  return SI(n, [{
    key: "createdByLauncher",
    value: (
      /**
       * A method that runs when `.init()` is called from `initComponentByLauncher`.
       * @param {Event} evt The event fired on the launcher button.
       */
      function(r) {
        this.show(r);
      }
    )
    /**
     * Determines whether or not to emit events and callback function when `.changeState()` is called from `eventedState`.
     * @param {string} state The new state.
     * @returns {boolean} `true` if the given `state` is different from current state.
     */
  }, {
    key: "shouldStateBeChanged",
    value: function(r) {
      return r === "shown" ? !this.element.classList.contains(this.options.classVisible) : this.element.classList.contains(this.options.classVisible);
    }
    /**
     * Changes the shown/hidden state.
     * @private
     * @param {string} state The new state.
     * @param {object} detail The detail data to be included in the event that will be fired.
     * @param {Function} callback Callback called when change in state completes.
     */
  }, {
    key: "_changeState",
    value: function(r, i, s) {
      var a = this, o, l = function() {
        if (o && (o = a.unmanage(o).release()), r === "shown" && a.element.offsetWidth > 0 && a.element.offsetHeight > 0) {
          a.previouslyFocusedNode = a.element.ownerDocument.activeElement;
          var h = a.element.querySelector(a.options.selectorPrimaryFocus) || a.element.querySelector(Yo.selectorTabbable);
          h.focus(), process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && pI(h, "Modals need to contain a focusable element by either using " + "`".concat(a.options.selectorPrimaryFocus, "` or settings.selectorTabbable."));
        }
        s();
      };
      if (this._handleFocusinListener && (this._handleFocusinListener = this.unmanage(this._handleFocusinListener).release()), r === "shown") {
        var c = "onfocusin" in this.element.ownerDocument.defaultView, u = c ? "focusin" : "focus";
        this._handleFocusinListener = this.manage(bi(this.element.ownerDocument, u, this._handleFocusin, !c));
      }
      r === "hidden" ? (this.element.classList.toggle(this.options.classVisible, !1), this.element.ownerDocument.body.classList.toggle(this.options.classBody, !1), (this.options.selectorFocusOnClose || this.previouslyFocusedNode) && (this.element.ownerDocument.querySelector(this.options.selectorFocusOnClose) || this.previouslyFocusedNode).focus()) : r === "shown" && (this.element.classList.toggle(this.options.classVisible, !0), this.element.ownerDocument.body.classList.toggle(this.options.classBody, !0)), o = this.manage(bi(this.element, "transitionend", l));
    }
  }, {
    key: "_hookCloseActions",
    value: function() {
      var r = this;
      this.manage(bi(this.element, "click", function(i) {
        var s = Zl(i, r.options.selectorModalClose);
        s && (i.delegateTarget = s), (s || i.target === r.element) && r.hide(i);
      })), this._handleKeydownListener && (this._handleKeydownListener = this.unmanage(this._handleKeydownListener).release()), this._handleKeydownListener = this.manage(bi(this.element.ownerDocument.body, "keydown", function(i) {
        i.which === 27 && r.shouldStateBeChanged("hidden") && (i.stopPropagation(), r.hide(i));
      }));
    }
    /**
     * Handles `focusin` (or `focus` depending on browser support of `focusin`) event to do wrap-focus behavior.
     * @param {Event} evt The event.
     * @private
     */
  }], [{
    key: "options",
    get: (
      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode Modal.create .create()}, or {@linkcode Modal.init .init()},
       * properties in this object are overridden for the instance being create and how {@linkcode Modal.init .init()} works.
       * @member Modal.options
       * @type {object}
       * @property {string} selectorInit The CSS class to find modal dialogs.
       * @property {string} [selectorModalClose] The selector to find elements that close the modal.
       * @property {string} [selectorPrimaryFocus] The CSS selector to determine the element to put focus when modal gets open.
       * @property {string} [selectorFocusOnClose] The CSS selector to determine the element to put focus when modal closes.
       *   If undefined, focus returns to the previously focused element prior to the modal opening.
       * @property {string} [selectorModalContainer] The CSS selector for the content container of the modal for focus wrap feature.
       * @property {string} attribInitTarget The attribute name in the launcher buttons to find target modal dialogs.
       * @property {string[]} [selectorsFloatingMenu]
       *   The CSS selectors of floating menus.
       *   Used for detecting if focus-wrap behavior should be disabled temporarily.
       * @property {string} [classVisible] The CSS class for the visible state.
       * @property {string} [classBody] The CSS class for `<body>` with open modal.
       * @property {string} [classNoScroll] The CSS class for hiding scroll bar in body element while modal is shown.
       * @property {string} [eventBeforeShown]
       *   The name of the custom event fired before this modal is shown.
       *   Cancellation of this event stops showing the modal.
       * @property {string} [eventAfterShown]
       *   The name of the custom event telling that modal is sure shown
       *   without being canceled by the event handler named by `eventBeforeShown` option (`modal-beingshown`).
       * @property {string} [eventBeforeHidden]
       *   The name of the custom event fired before this modal is hidden.
       *   Cancellation of this event stops hiding the modal.
       * @property {string} [eventAfterHidden]
       *   The name of the custom event telling that modal is sure hidden
       *   without being canceled by the event handler named by `eventBeforeHidden` option (`modal-beinghidden`).
       */
      function() {
        var r = Yo.prefix;
        return {
          selectorInit: "[data-modal]",
          selectorModalClose: "[data-modal-close]",
          selectorPrimaryFocus: "[data-modal-primary-focus]",
          selectorsFloatingMenus: [".".concat(r, "--overflow-menu-options"), ".".concat(r, "--tooltip"), ".flatpickr-calendar"],
          selectorModalContainer: ".".concat(r, "--modal-container"),
          classVisible: "is-visible",
          classBody: "".concat(r, "--body--with-modal-open"),
          attribInitTarget: "data-modal-target",
          initEventNames: ["click"],
          eventBeforeShown: "modal-beingshown",
          eventAfterShown: "modal-shown",
          eventBeforeHidden: "modal-beinghidden",
          eventAfterHidden: "modal-hidden"
        };
      }
    )
  }]), n.components = /* @__PURE__ */ new WeakMap(), n;
}(TR(kR, _I, hI, FR));
const LI = AI;
class io extends dt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "modal", this.isEventListenerAdded = !1, this.handleShowModal = () => {
      this.modal.html(this.getModalHTML()), this.modal.select("div.cds--modal-footer button.cds--btn").on("click", () => this.model.exportToCSV()), LI.create(this.modal.node()).show();
    }, this.init();
  }
  addEventListeners() {
    this.services.events.addEventListener(O.Modal.SHOW, this.handleShowModal);
  }
  removeEventListeners() {
    this.services.events.removeEventListener(O.Modal.SHOW, this.handleShowModal);
  }
  getModalHTML() {
    const t = this.model.getOptions(), n = b(t, "style", "prefix"), r = this.model.getTabularDataArray();
    return `
		<div class="cds--modal-container cds--modal-container">
			<div class="cds--modal-header cds--modal-header">
				<p class="cds--modal-header__label cds--type-delta cds--modal-header__label cds--type-delta" id="modal-title">Tabular representation</p>

				<p class="cds--modal-header__heading cds--type-beta cds--modal-header__heading cds--type-beta" id="modal-description">${t.title}</p>

				<button class="cds--modal-close cds--modal-close" type="button" data-modal-close aria-label="close modal"  data-modal-primary-focus>
					<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" fill="currentColor" aria-label="Close" width="20" height="20" viewBox="0 0 32 32" role="img" class="cds--modal-close__icon cds--modal-close__icon">
						<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path>
					</svg>
				</button>
			</div>

			<div class="cds--modal-content cds--modal-content">
				<table class="cds--data-table cds--data-table--no-border cds--data-table cds--data-table--no-border">
					<thead>
						<tr>
							${At(r, 0).map(
      (i) => `<th scope="col">
								<div class="cds--table-header-label cds--table-header-label">${i}</div>
							</th>`
    ).join("")}
						</tr>
					</thead>

					<tbody>${r.slice(1).map(
      (i) => `
							<tr>
								${i.map((s) => `<td>${s}</td>`).join("")}
							</tr>`
    ).join("")}
					</tbody>
				</table>
			</div>

			<div class="cds--modal-footer cds--modal-footer">
			  <div class="${he}--${n}-modal-footer-spacer"></div>
			  <button class="cds--btn cds--btn--primary cds--btn cds--btn--primary" type="button" data-modal-primary-focus>Download as CSV</button>
			</div>
		</div>`;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.model.getOptions();
    if (!this.isEventListenerAdded) {
      const r = R(this.services.domUtils.getHolder()), i = b(n, "style", "prefix");
      this.modal = D.appendOrSelect(r, `div.${he}--${i}--modal`), this.addEventListeners(), this.isEventListenerAdded = !0, this.modal.attr("data-modal", !0).attr("class", "cds--modal cds--modal").attr("role", "dialog").attr("aria-modal", !0).attr("aria-labelledby", "modal-title").attr("aria-describedby", "modal-description").attr("tabindex", -1);
    }
  }
  destroy() {
    this.removeEventListeners(), this.isEventListenerAdded = !1;
  }
}
class is extends dt {
  constructor() {
    super(...arguments), this.type = "title", this.renderType = K.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getComponentContainer(), r = b(this.getOptions(), "title"), i = n.selectAll("p.title").data([r]);
    if (i.enter().append("p").classed("title", !0).attr("role", "heading").attr("aria-level", 2).merge(i).html((s) => s), i.node() && i.node().offsetWidth < i.node().scrollWidth) {
      const s = this;
      i.on("mouseover", function(a) {
        s.services.events.dispatchEvent(O.Tooltip.SHOW, {
          event: a,
          hoveredElement: i,
          content: i.text()
        });
      }).on("mousemove", function(a) {
        s.services.events.dispatchEvent(O.Tooltip.MOVE, {
          event: a
        });
      }).on("mouseout", function() {
        s.services.events.dispatchEvent(O.Tooltip.HIDE);
      });
    }
    i.exit().remove();
  }
  /**
   * Truncates title creating ellipses and attaching tooltip for exposing full title.
   */
  truncateTitle(t, n) {
    if (n <= 0)
      return;
    const r = t.text();
    if (t.node().getComputedTextLength() > n) {
      t.append("tspan").text("...");
      const i = D.appendOrSelect(t, "tspan").node().getComputedTextLength(), s = t.text(), a = this.getSubstringIndex(
        t.node(),
        0,
        s.length - 1,
        n - i
      );
      t.html(s.substring(0, a - 1)).append("tspan").text("...");
      const o = this;
      t.on("mouseover", function(l) {
        o.services.events.dispatchEvent(O.Tooltip.SHOW, {
          event: l,
          hoveredElement: t,
          content: r
        });
      }).on("mousemove", function(l) {
        o.services.events.dispatchEvent(O.Tooltip.MOVE, {
          event: l
        });
      }).on("mouseout", function() {
        o.services.events.dispatchEvent(O.Tooltip.HIDE);
      });
    }
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    return D.getSVGElementSize(this.parent.node(), {
      useAttrs: !0
    }).width;
  }
  /**
   * Returns the index for a maximum length substring that is less than the width parameter.
   * @param title the title node used for getting the text lengths of substrings
   * @param start the start index for the binary search
   * @param end the end index for the binary search
   * @param width the width of the svg container that holds the title
   */
  getSubstringIndex(t, n, r, i) {
    const s = Math.floor((r + n) / 2);
    return t.getSubStringLength(0, s) > i ? this.getSubstringIndex(t, n, s, i) : t.getSubStringLength(0, s) < i ? t.getSubStringLength(0, s + 1) > i ? s : this.getSubstringIndex(t, s, r, i) : s;
  }
}
class iu extends dt {
  constructor() {
    super(...arguments), this.type = "legend", this.renderType = K.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getOptions(), r = b(n, "legend"), i = b(r, "alignment"), s = b(n, "legend", "orientation");
    let a = this.model.getDataGroups();
    const { DISABLED: o } = Bt.items.status, l = a.some((y) => y.status === o), c = b(r, "order"), u = this.getComponentContainer().classed("center-aligned", i === Yt.CENTER).classed("right-aligned", i === Yt.RIGHT).classed(s, !0).classed("has-deactivated-items", l).attr("role", at.GROUP).attr("aria-label", "Data groups").attr("data-name", "legend-items");
    c && (a = this.sortDataGroups(a, c));
    const h = u.selectAll("div.legend-item").data(a, (y) => y.name), d = h.enter().append("div").attr("class", "legend-item");
    d.merge(u.selectAll("div.legend-item")).classed("active", function(y) {
      return y.status === Bt.items.status.ACTIVE;
    });
    const f = b(this.getOptions(), "legend", "clickable");
    u.classed("clickable", f && a.length > 1);
    const p = Bt.checkbox.radius, m = d.append("div").classed("checkbox", !0), g = m.merge(h.select("div.checkbox")).attr("role", at.CHECKBOX).attr("tabindex", f ? 0 : -1).attr(
      "aria-labelledby",
      (y, x) => this.services.domUtils.generateElementIDString(`legend-datagroup-${x}-title`)
    ).attr("aria-checked", ({ status: y }) => y === Bt.items.status.ACTIVE).attr("width", p * 2).attr("height", p * 2).attr(
      "class",
      (y) => this.model.getColorClassName({
        classNameTypes: [et.BACKGROUND],
        dataGroupName: y.name,
        originalClassName: "checkbox"
      })
    ).style(
      "background",
      (y) => y.status === Bt.items.status.ACTIVE ? this.model.getFillColor(y.name) || this.model.getStrokeColor(y.name) : null
    ).classed("active", function(y) {
      return y.status === Bt.items.status.ACTIVE;
    });
    m.append("svg").attr("focusable", !1).attr("preserveAspectRatio", "xMidYMid meet").attr("xmlns", "http://www.w3.org/2000/svg").attr("width", "11").attr("height", "11").attr("viewBox", "0 0 31 28").attr("aria-hidden", !0).style("will-change", "transform").append("path").attr("d", "M13 21.2l-7.1-7.1-1.4 1.4 7.1 7.1L13 24 27.1 9.9l-1.4-1.5z"), d.append("p").merge(h.select("p"));
    const v = b(n, "legend", "additionalItems");
    if (v && a.length) {
      const y = this, x = u.selectAll("div.additional-item").data(v);
      x.exit().remove();
      const S = x.enter().append("div").merge(x).classed("legend-item", !0).classed("additional", !0).attr(
        "aria-labelledby",
        (T, k) => this.services.domUtils.generateElementIDString(
          `legend-datagroup-${g.size() + k}-title`
        )
      );
      S.selectAll("*").remove();
      let _, E = 1;
      S.append("svg").classed("icon", !0).each(function(T) {
        const k = R(this);
        !_ || _ != T.type ? (_ = T.type, E = 1) : E++, y.addAdditionalItem(k, T, E);
      }), S.append("p").merge(S.select("p")), this.truncateLegendText();
    }
    h.exit().on("mouseover", null).on("click", null).on("mouseout", null).remove(), f && d.size() > 1 && this.addEventListeners();
  }
  sortDataGroups(t, n) {
    if (t.sort(
      (r, i) => n.indexOf(r.name) - n.indexOf(i.name)
    ), n.length < t.length) {
      const r = t.length - n.length;
      return t.slice(r).concat(t.slice(0, r));
    }
    return t;
  }
  addAdditionalItem(t, n, r) {
    const { width: i, height: s } = Bt.area;
    if (n.type === Wt.RADIUS ? t.style("width", `${s}px`).style("height", `${s}px`) : t.style("width", `${i}px`).style("height", `${s}px`), n.type === Wt.RADIUS) {
      const { iconData: a, fill: o, stroke: l } = Bt.radius;
      t.attr("fill", "none").selectAll("circle").data(a).enter().append("circle").classed("radius", !0).attr("role", at.IMG).attr("aria-label", "radius").attr("cx", (c) => c.cx).attr("cy", (c) => c.cy).attr("r", (c) => c.r).style("fill", n.fill ? n.fill : o).style("stroke", n.stroke ? n.stroke : l);
    } else if (n.type === Wt.LINE) {
      const a = Bt.line;
      t.select("line.line").empty() && t.append("line").classed(`line-${r}`, !0).attr("role", at.IMG).attr("aria-label", "line").attr("x1", 0).attr("y1", a.yPosition).attr("x2", i).attr("y2", a.yPosition).style("stroke", n.stroke ? n.stroke : a.stroke).style("stroke-width", a.strokeWidth);
    } else if (n.type === Wt.AREA)
      t.select("rect.area").empty() && t.append("rect").classed(`area-${r}`, !0).attr("role", at.IMG).attr("aria-label", "area").attr("width", i).attr("height", s).style(
        "fill",
        r > 3 && !n.fill ? Bt.area.fill : n.fill
      ).style("stroke", n.stroke);
    else if (n.type === Wt.SIZE) {
      const { iconData: a, fill: o, stroke: l } = Bt.size;
      t.attr("fill", "none").attr("role", at.IMG).attr("aria-label", "size").selectAll("rect").data(a).enter().append("rect").classed("size", !0).attr("width", (c) => c.width).attr("height", (c) => c.height).attr("y", () => 0).style("fill", n.fill ? n.fill : o).style("stroke", n.stroke ? n.stroke : l).style("stroke-width", 1);
    } else if (n.type === Wt.QUARTILE) {
      const { iconData: a } = Bt.quartile;
      t.selectAll("rect").attr("role", at.IMG).attr("aria-label", "quartile").data(a).enter().append("rect").attr("class", (o, l) => `quartile-${l === 0 ? "wrapper" : "line"}`).attr("x", (o) => o.x).attr("y", (o) => o.y).attr("width", (o) => o.width).attr("height", (o) => o.height);
    } else if (n.type === Wt.ZOOM) {
      const { iconData: a, color: o } = b(Bt, "zoom"), l = t.attr("role", at.IMG).attr("aria-label", "zoom").selectAll("g.icon").data(a).enter();
      l.append("g").attr("x", (c) => c.x).attr("y", (c) => c.y).attr("width", (c) => c.width).attr("height", (c) => c.height).append("polygon").attr(
        "points",
        "7.7 4.82 5.78 4.82 5.78 2.89 4.82 2.89 4.82 4.82 2.89 4.82 2.89 5.78 4.82 5.78 4.82 7.7 5.78 7.7 5.78 5.78 7.7 5.78 7.7 4.82"
      ).attr("fill", () => n.color ? n.color : o), l.append("path").attr(
        "d",
        "M9.36,8.67A5.22,5.22,0,0,0,10.59,5.3,5.3,5.3,0,1,0,5.3,10.59,5.22,5.22,0,0,0,8.67,9.36L12.32,13l.68-.68Zm-4.06,1A4.34,4.34,0,1,1,9.63,5.3,4.33,4.33,0,0,1,5.3,9.63Z"
      ).attr("fill", () => n.color ? n.color : o);
    }
  }
  truncateLegendText() {
    const t = this.getComponentContainer(), n = b(this.getOptions(), "legend", "truncation"), r = b(n, "type"), i = b(n, "threshold"), s = b(n, "numCharacter"), a = t.selectAll("div.legend-item p");
    a.attr("id", function() {
      return (this.parentNode.querySelector("div.checkbox") || this.parentNode).getAttribute("aria-labelledby");
    }), r !== Ie.NONE ? a.html(function(o) {
      return o.name.length > i ? zi(o.name, r, s) : o.name;
    }) : a.html((o) => o.name);
  }
  addEventListeners() {
    const t = this, n = this.getComponentContainer(), r = this.getOptions(), i = b(r, "legend"), s = b(i, "truncation");
    n.selectAll("div.legend-item").on("mouseover", function(a) {
      t.services.events.dispatchEvent(O.Legend.ITEM_HOVER, {
        hoveredElement: R(this)
      });
      const o = R(this);
      o.select("div.checkbox").classed("hovered", !0);
      const l = o.datum();
      l.name.length > s.threshold && s.type !== Ie.NONE && t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        content: l.name
      });
    }).on("mousemove", function(a) {
      R(this).datum().name.length > s.threshold && s.type !== Ie.NONE && t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function() {
      t.services.events.dispatchEvent(O.Legend.ITEM_CLICK, {
        clickedElement: R(this)
      });
      const a = R(this).datum();
      t.model.toggleDataLabel(a.name);
    }).on("mouseout", function() {
      const a = R(this);
      a.select("div.checkbox").classed("hovered", !1), a.datum().name.length > s.threshold && s.type !== Ie.NONE && t.services.events.dispatchEvent(O.Tooltip.HIDE), t.services.events.dispatchEvent(O.Legend.ITEM_MOUSEOUT, {
        hoveredElement: a
      });
    }), n.selectAll("div.legend-item div.checkbox").on("keyup", function(a) {
      a.key && a.key === "Tab" && t.services.events.dispatchEvent(O.Legend.ITEM_HOVER, {
        hoveredElement: R(this)
      });
    }), n.selectAll("div.legend-item div.checkbox").on("keydown", function(a, o) {
      a.key && a.key === " " ? (a.preventDefault(), t.model.toggleDataLabel(o.name)) : a.key && a.key === "Tab" && t.services.events.dispatchEvent(O.Legend.ITEM_MOUSEOUT, {
        hoveredElement: R(this)
      });
    }), n.selectAll("g.additional-item").on("mouseover", function(a) {
      const o = R(this), l = o.datum();
      l.name.length > s.threshold && t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        content: l.name
      });
    });
  }
}
class gv extends dt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "chart-clip", this.renderType = K.SVG, this.chartClipId = "chart-clip-id-" + Math.floor(Math.random() * 99999999999), this.init();
  }
  init() {
    this.model.set({ chartClipId: this.chartClipId }, { skipUpdate: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    this.createClipPath();
  }
  createClipPath() {
    const t = this.parent, { cartesianScales: n } = this.services;
    if (!n)
      throw new Error("Service cartesianScales was undefined");
    const r = n.getMainXScale(), i = n.getMainYScale(), [s, a] = r.range(), [o, l] = i.range();
    if (!t)
      throw new Error("svg is undefined");
    this.chartClipPath = D.appendOrSelect(t, `clipPath.${this.type}`).attr(
      "id",
      this.chartClipId
    );
    const c = D.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    a - s > 0 && c.attr("x", s).attr("y", l).attr("width", a - s).attr("height", o - l), this.chartClipPath.merge(c).lower();
  }
}
class DI extends gv {
  constructor() {
    super(...arguments), this.type = "canvas-chart-clip", this.chartClipId = "canvas-chart-clip-id-" + Math.floor(Math.random() * 99999999999);
  }
  createClipPath() {
    const t = this.parent, { width: n, height: r } = D.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    this.chartClipPath = D.appendOrSelect(t, `clipPath.${this.type}`).attr(
      "id",
      this.chartClipId
    );
    const i = D.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    i.attr("x", 0).attr("y", 0).attr("width", n).attr("height", r), this.chartClipPath.merge(i).lower();
  }
}
var gr, te;
(function(e) {
  e.LEFT = "left", e.RIGHT = "right", e.TOP = "top", e.BOTTOM = "bottom";
})(te || (te = {}));
var lf = (gr = {}, gr[te.LEFT] = function(e, t, n) {
  return {
    top: e.top - Math.round(t.offsetHeight / 2) + Math.round(n.height / 2),
    left: Math.round(e.left - t.offsetWidth)
  };
}, gr[te.RIGHT] = function(e, t, n) {
  return {
    top: e.top - Math.round(t.offsetHeight / 2) + Math.round(n.height / 2),
    left: Math.round(e.left + n.width)
  };
}, gr[te.TOP] = function(e, t, n) {
  return {
    top: Math.round(e.top - t.offsetHeight),
    left: e.left - Math.round(t.offsetWidth / 2) + Math.round(n.width / 2)
  };
}, gr[te.BOTTOM] = function(e, t, n) {
  return {
    top: Math.round(e.top + n.height),
    left: e.left - Math.round(t.offsetWidth / 2) + Math.round(n.width / 2)
  };
}, gr), cf = typeof window < "u" ? window : {
  innerHeight: 0,
  scrollY: 0,
  innerWidth: 0,
  scrollX: 0
}, so = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.positions = lf, this.positions = Object.assign({}, lf, t);
    }
    return e.prototype.getRelativeOffset = function(t) {
      for (var n = {
        left: t.offsetLeft,
        top: t.offsetTop
      }; t.offsetParent && getComputedStyle(t.offsetParent).position === "static"; )
        n.left += t.offsetLeft, n.top += t.offsetTop, t = t.offsetParent;
      return n;
    }, e.prototype.getAbsoluteOffset = function(t) {
      for (var n = t, r = {
        top: 0,
        left: 0
      }; n.offsetParent; ) {
        var i = getComputedStyle(n.offsetParent);
        i.position === "static" && i.marginLeft && i.marginTop && (parseInt(i.marginTop, 10) && (r.top += parseInt(i.marginTop, 10)), parseInt(i.marginLeft, 10) && (r.left += parseInt(i.marginLeft, 10))), n = n.offsetParent;
      }
      var s = t.getBoundingClientRect(), a = document.body.getBoundingClientRect();
      return {
        top: s.top - a.top + r.top,
        left: s.left - a.left + r.left
      };
    }, e.prototype.findRelative = function(t, n, r) {
      var i = this.getRelativeOffset(t), s = t.getBoundingClientRect();
      return this.calculatePosition(i, s, n, r);
    }, e.prototype.findAbsolute = function(t, n, r) {
      var i = this.getAbsoluteOffset(t), s = t.getBoundingClientRect();
      return this.calculatePosition(i, s, n, r);
    }, e.prototype.findPosition = function(t, n, r, i) {
      i === void 0 && (i = this.getAbsoluteOffset.bind(this));
      var s = i(t), a = t.getBoundingClientRect();
      return this.calculatePosition(s, a, n, r);
    }, e.prototype.findPositionAt = function(t, n, r) {
      return this.calculatePosition(t, { top: 0, left: 0, height: 0, width: 0 }, n, r);
    }, e.prototype.getPlacementBox = function(t, n) {
      var r = t.offsetHeight + n.top, i = t.offsetWidth + n.left;
      return {
        top: n.top,
        bottom: r,
        left: n.left,
        right: i
      };
    }, e.prototype.addOffset = function(t, n, r) {
      return n === void 0 && (n = 0), r === void 0 && (r = 0), Object.assign({}, t, {
        top: t.top + n,
        left: t.left + r
      });
    }, e.prototype.setElement = function(t, n) {
      t.style.top = n.top + "px", t.style.left = n.left + "px";
    }, e.prototype.findBestPlacement = function(t, n, r, i, s) {
      var a = this;
      i === void 0 && (i = this.defaultContainerFunction.bind(this)), s === void 0 && (s = this.findPosition.bind(this));
      var o = r.map(function(l) {
        var c = s(t, n, l), u = a.getPlacementBox(n, c), h = 0, d = 0, f = i();
        u.top < f.top ? h = f.top - u.top : u.bottom > f.height && (h = u.bottom - f.height), u.left < f.left ? d = f.left - u.left : u.right > f.width && (d = u.right - f.width), h && !d ? d = 1 : d && !h && (h = 1);
        var p = n.offsetHeight * n.offsetWidth, m = h * d, g = p - m, v = g / p;
        return {
          placement: l,
          weight: v
        };
      });
      return o.sort(function(l, c) {
        return c.weight - l.weight;
      }), o[0].placement;
    }, e.prototype.findBestPlacementAt = function(t, n, r, i) {
      var s = this;
      i === void 0 && (i = this.defaultContainerFunction.bind(this));
      var a = function(o, l, c) {
        return s.findPositionAt(t, l, c);
      };
      return this.findBestPlacement(null, n, r, i, a);
    }, e.prototype.defaultContainerFunction = function() {
      return {
        // we go with window here, because that's going to be the simple/common case
        top: 0,
        left: 0,
        height: cf.innerHeight,
        width: cf.innerWidth
      };
    }, e.prototype.calculatePosition = function(t, n, r, i) {
      return this.positions[i] ? this.positions[i](t, r, n) : (console.error("No function found for placement, defaulting to 0,0"), { left: 0, top: 0 });
    }, e;
  }()
);
new so();
class su extends dt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "tooltip", this.renderType = K.HTML, this.isEventListenerAdded = !1, this.positionService = new so(), this.handleShowTooltip = (i) => {
      const s = i.detail.data || i.detail.items;
      let a;
      const o = this.formatItems(this.getItems(i));
      i.detail.content ? a = `<div class="title-tooltip"><p>${i.detail.content}</p></div>` : a = this.getTooltipHTML(o);
      const l = D.appendOrSelect(this.tooltip, "div.content-box");
      if (b(this.getOptions(), "tooltip", "customHTML"))
        if (i.detail.content) {
          const c = `<div class="title-tooltip"><p>${i.detail.content}</p></div>`;
          l.html(c);
        } else
          l.html(this.model.getOptions().tooltip.customHTML(s, a));
      else
        l.html(a);
      l.selectAll(".datapoint-tooltip").each(function(c, u) {
        const h = o[u];
        o[u] && o[u].color && R(this).select(".tooltip-color").attr("class", "tooltip-color").style("background-color", h.color);
      }), this.positionTooltip(i), this.tooltip.classed("hidden", !1).attr("aria-hidden", !1);
    }, this.handleHideTooltip = () => {
      this.tooltip.classed("hidden", !0).attr("aria-hidden", !0);
    }, this.init();
  }
  addTooltipEventListener() {
    this.services.events.addEventListener(O.Tooltip.MOVE, (t) => {
      this.tooltip.classed("hidden") === !1 && this.positionTooltip(t);
    }), this.services.events.addEventListener(O.Tooltip.SHOW, this.handleShowTooltip), this.services.events.addEventListener(O.Tooltip.HIDE, this.handleHideTooltip), this.services.events.addEventListener(O.Chart.MOUSEOUT, this.handleHideTooltip);
  }
  removeTooltipEventListener() {
    this.services.events.removeEventListener(O.Tooltip.MOVE, null), this.services.events.removeEventListener(O.Tooltip.SHOW, this.handleShowTooltip), this.services.events.removeEventListener(O.Tooltip.HIDE, this.handleHideTooltip), this.services.events.removeEventListener(O.Chart.MOUSEOUT, this.handleHideTooltip);
  }
  getItems(t) {
    return t.detail.items ? t.detail.items : [];
  }
  formatItems(t) {
    const n = this.getOptions(), r = b(n, "tooltip", "truncation", "type"), i = b(n, "tooltip", "truncation", "threshold"), s = b(n, "tooltip", "truncation", "numCharacter");
    return r !== Ie.NONE ? t.map((a) => {
      const o = a.labelIcon ? 12 : 0;
      return a.value = a.value ? this.valueFormatter(a.value, a.label) : a.value, a.label && a.label.length + o > i && (a.label = zi(a.label, r, s)), a.value && a.value.length > i && (a.value = zi(a.value, r, s)), a;
    }) : t;
  }
  getTooltipHTML(t) {
    return '<ul class="multi-tooltip">' + t.map(
      (n) => `<li>
					<div class="datapoint-tooltip${n.bold ? " bold" : ""}">
						${n.class || n.color ? `<div class="tooltip-color ${n.class}"></div>` : ""}
						<div class="label">
						<p>${n.label || ""}</p>
						${n.labelIcon ? `<span class="label-icon"/>${n.labelIcon}</span>` : ""}
						</div>
						${n.value === void 0 || n.value === null ? "" : `<p class="value"/>${n.value}</p>`}
					</div>
				</li>`
    ).join("") + "</ul>";
  }
  valueFormatter(t, n) {
    const r = this.getOptions(), i = b(r, "tooltip", "valueFormatter");
    if (i)
      return i(t, n);
    if (typeof t.getTime == "function")
      return Vr(t, "MMM d, yyyy");
    try {
      if (typeof t == "string" && /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/.test(t))
        return Vr(Date.parse(t), "MMM d, yyyy");
    } catch {
    }
    return t.toLocaleString();
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getOptions(), r = b(n, "tooltip", "enabled");
    if (r) {
      const i = R(this.services.domUtils.getHolder()), s = b(n, "style", "prefix");
      this.tooltip = D.appendOrSelect(i, `div.${he}--${s}--tooltip`), this.tooltip.style("max-width", null).attr("role", "tooltip"), this.isEventListenerAdded || (this.addTooltipEventListener(), this.isEventListenerAdded = !0), this.tooltip.classed("hidden", !0);
    } else
      !r && this.isEventListenerAdded && (this.removeTooltipEventListener(), this.isEventListenerAdded = !1);
  }
  positionTooltip(t) {
    const n = this.services.domUtils.getHolder(), r = this.tooltip.node(), i = this.getOptions(), s = b(i, "zoomBar", "top", "enabled");
    let a = b(t, "detail", "mousePosition");
    if (!a)
      a = Yn(b(t, "detail", "event"), n);
    else {
      const d = b(i, "zoomBar", "top", "type"), f = ye.height[d];
      s && (a[1] += f + ye.spacerHeight);
    }
    const o = n.offsetWidth, l = n.offsetHeight;
    let c;
    a[0] / o > 0.9 ? c = te.LEFT : a[0] / o < 0.1 ? c = te.RIGHT : c = this.positionService.findBestPlacementAt(
      {
        left: a[0],
        top: a[1]
      },
      r,
      [te.RIGHT, te.LEFT, te.TOP, te.BOTTOM],
      () => ({
        top: void 0,
        // properties were never set to optional (probably should)
        left: void 0,
        // ditto
        width: o,
        height: l
      })
    );
    let { horizontalOffset: u } = MA;
    c === te.LEFT && (u *= -1);
    const h = this.positionService.findPositionAt(
      {
        left: a[0] + u,
        top: a[1]
      },
      r,
      c
    );
    this.positionService.setElement(r, h);
  }
}
const mv = class Ps extends dt {
  constructor() {
    super(...arguments), this.type = "grid-brush", this.renderType = K.SVG, this.selectionSelector = "rect.selection", this.frontSelectionSelector = "rect.frontSelection";
  }
  // needs to match the class name in _grid-brush.scss
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.parent, r = this.getComponentContainer();
    if (!n)
      throw new Error("SVG was not defined");
    const i = D.appendOrSelect(n, "svg.chart-grid-backdrop"), s = D.appendOrSelect(i, `g.${this.type}`), a = D.appendOrSelect(s, this.selectionSelector), { width: o, height: l } = D.getSVGElementSize(i, {
      useAttrs: !0
    }), { cartesianScales: c } = this.services, u = c.getMainXScaleType(), h = c.getMainXScale(), [d] = h.range();
    r.attr("transform", `translate(${d},0)`);
    const f = D.appendOrSelect(r, this.frontSelectionSelector);
    if (h && u === X.TIME) {
      let p = this.model.get("zoomDomain");
      p === void 0 && (p = this.services.zoom.getDefaultZoomBarDomain(), p && this.model.set({ zoomDomain: p }, { animate: !1 }));
      const m = (_) => {
        const E = _[1] - _[0];
        let T = "0," + E.toString();
        const k = Math.floor(l / Ps.DASH_LENGTH), N = k * Ps.DASH_LENGTH;
        for (let L = 0; L < k; L++)
          T += "," + Ps.DASH_LENGTH;
        T += "," + (l - N), k % 2 === 1 && (T += ",0"), T += "," + E.toString(), T += "," + l.toString(), f.attr("stroke-dasharray", T);
      }, g = (_) => {
        const E = _.selection;
        E === null || E[0] === E[1] || (f.attr("x", parseFloat(a.attr("x")) + parseFloat(i.attr("x"))).attr("y", a.attr("y")).attr("width", a.attr("width")).attr("height", a.attr("height")).style("cursor", "pointer").style("display", null), m(E));
      }, v = (_, E) => {
        const T = yg().range([0, o]).domain(p);
        let k = [T.invert(_), T.invert(E)];
        k[0].valueOf() === k[1].valueOf() && (k = this.services.zoom.getDefaultZoomBarDomain()), (p[0].valueOf() !== k[0].valueOf() || p[1].valueOf() !== k[1].valueOf()) && this.services.zoom.handleDomainChange(k);
      };
      let y;
      const x = (_) => {
        const E = _.selection;
        E !== null && (v(E[0], E[1]), s.call(y.move, null), f.style("display", "none"));
      };
      l != 0 && o != 0 && (y = $p().extent([
        [0, 0],
        [o - 1, l]
      ]).on("start brush end", g).on("end.brushed", x), s.call(y));
      const S = this.services.zoom.getZoomRatio();
      i.on("click", function(_) {
        if (_.shiftKey) {
          const E = this.services.domUtils.getHolder(), T = Yn(s.node(), E)[0];
          let k = T - o * S / 2;
          k < 0 && (k = 0);
          let N = T + o * S / 2;
          N > o && (N = o), v(k, N);
        }
      });
    }
  }
};
mv.DASH_LENGTH = 4;
let kI = mv;
class RI extends dt {
  constructor() {
    super(...arguments), this.type = "zoom-bar", this.renderType = K.SVG, this.MIN_SELECTION_DIFF = 9e-10, this.brushSelector = "g.zoom-bar-brush", this.clipId = "zoomBarClip-" + Math.floor(Math.random() * 99999999999), this.brush = $p(), this.highlightStrokeWidth = 1;
  }
  init() {
    this.services.events.addEventListener(O.ZoomBar.UPDATE, this.render.bind(this));
    const t = b(this.getOptions(), "zoomBar", H.TOP, "data");
    this.model.setZoomBarData(t);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer(), r = this.services.zoom.isZoomBarLoading(H.TOP), i = this.services.zoom.isZoomBarLocked(H.TOP), s = b(this.getOptions(), "zoomBar", H.TOP, "type"), a = b(this.getOptions(), "axes", H.BOTTOM, "highlights"), o = ye.height[s], { width: l } = D.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (l === 0)
      return;
    let c = 0;
    const u = this.model.get("axesMargins");
    u && u.left && (c = u.left);
    const h = D.appendOrSelect(n, "svg.zoom-container").attr("width", "100%").attr("height", o).attr("opacity", 1);
    if (D.appendOrSelect(n, "rect.zoom-spacer").attr("x", 0).attr("y", o).attr("width", "100%").attr("height", ye.spacerHeight).attr("opacity", 1).attr("fill", "none"), s === We.GRAPH_VIEW ? D.appendOrSelect(h, "rect.zoom-bg").attr("x", c).attr("y", 0).attr("width", l - c).attr("height", "100%").classed("zoom-bg-skeleton", r).style(
      "stroke",
      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ) : s === We.SLIDER_VIEW && D.appendOrSelect(h, "rect.zoom-slider-bg").attr("x", c).attr("y", o / 2 - 1).attr("width", l - c).attr("height", 2).classed("zoom-slider-bg-skeleton", r).style(
      "stroke",
      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ), r) {
      this.renderSkeleton(h, c, l);
      return;
    }
    const { cartesianScales: d } = this.services, f = d.getMainXScale(), p = d.getMainYScale(), m = d.getMainXScaleType();
    if (f && m === X.TIME) {
      let g = this.services.zoom.getZoomBarData();
      if (Re(g) || g.length === 1)
        return;
      this.xScale = f.copy(), this.yScale = p.copy();
      const v = this.services.zoom.getDefaultZoomBarDomain(g);
      g = this.compensateDataForDefaultDomain(g, v);
      const y = this.model.get("initialZoomDomain"), x = b(
        this.getOptions(),
        "zoomBar",
        H.TOP,
        "initialZoomDomain"
      );
      x && x[0] && x[1] && (x[0] = new Date(x[0]), x[1] = new Date(x[1])), x && !(y && y[0].valueOf() === x[0].valueOf() && y[1].valueOf() === x[1].valueOf()) ? this.model.set(
        {
          // use a new object instead of newInitialZoomDomain
          initialZoomDomain: rt([], x),
          zoomDomain: x ? rt([], x) : v
        },
        { skipUpdate: !0 }
      ) : x === null && y !== null && this.model.set(
        {
          initialZoomDomain: null,
          zoomDomain: rt([], v)
        },
        { skipUpdate: !0 }
      ), this.xScale.range([c, l]).domain(v), this.maxSelectionRange = this.xScale.range(), this.yScale.range([0, o - 6]).domain(Ne(g, (E) => E.value));
      const S = this.model.get("zoomDomain");
      if (s === We.GRAPH_VIEW && (this.renderZoomBarArea(h, "path.zoom-graph-area-unselected", g, null), this.updateClipPath(n, this.clipId, 0, 0, 0, 0), this.renderZoomBarArea(h, "path.zoom-graph-area", g, this.clipId), this.renderZoomBarBaseline(h, c, l), a)) {
        const E = a.highlightStartMapsTo, T = a.highlightEndMapsTo, k = a.color, N = a.labelMapsTo;
        a.data.forEach((L, C) => {
          D.appendOrSelect(h, `rect.highlight-${C}`).attr("height", o - 2 * this.highlightStrokeWidth).attr("y", this.highlightStrokeWidth).attr("x", this.xScale(L[E])).attr(
            "width",
            this.xScale(L[T]) - this.xScale(L[E])
          ).style(
            "fill",
            k && k.scale[L[N]] ? k.scale[L[N]] : null
          ).style("fill-opacity", 0.1).style(
            "stroke",
            k && k.scale[L[N]] ? k.scale[L[N]] : null
          ).style("stroke-dasharray", "2, 2").attr("stroke-width", "1px");
        });
      }
      this.addBrushEventListener(S, c, l);
      const _ = D.appendOrSelect(n, this.brushSelector).call(this.brush);
      if (S !== void 0)
        if (S[0].valueOf() === S[1].valueOf())
          _.call(this.brush.move, this.xScale.range()), this.updateBrushHandle(this.getComponentContainer(), this.xScale.range());
        else {
          const E = S.map((T) => this.xScale(T));
          E[1] - E[0] < this.MIN_SELECTION_DIFF || (_.call(this.brush.move, E), this.updateBrushHandle(this.getComponentContainer(), E));
        }
      i && (this.brush.filter(() => !1), _.selectAll("rect").attr("cursor", "auto"));
    }
  }
  addBrushEventListener(t, n, r) {
    const i = (o) => {
      const l = o.selection;
      l === null ? this.handleBrushedEvent(o, t, this.xScale, this.xScale.range()) : l[0] === l[1] || this.handleBrushedEvent(o, t, this.xScale, l);
    }, s = b(this.getOptions(), "zoomBar", H.TOP, "type"), a = ye.height[s];
    this.brush.extent([
      [n, 0],
      [r, a]
    ]).on("start brush end", null).on("start brush end", i);
  }
  // brush event listener
  handleBrushedEvent(t, n, r, i) {
    const s = [r.invert(i[0]), r.invert(i[1])];
    if (this.updateBrushHandle(this.getComponentContainer(), i), t.sourceEvent != null && (t.sourceEvent.type === "mousemove" || t.sourceEvent.type === "mouseup" || t.sourceEvent.type === "mousedown" || t.sourceEvent.type === "touchstart" || t.sourceEvent.type === "touchmove" || t.sourceEvent.type === "touchend")) {
      (n === void 0 || n[0] !== s[0] || n[1] !== s[1]) && this.services.zoom.handleDomainChange(s, {
        dispatchEvent: !1
      });
      let a;
      t.type === "start" ? a = O.ZoomBar.SELECTION_START : t.type === "brush" ? a = O.ZoomBar.SELECTION_IN_PROGRESS : t.type === "end" && (a = O.ZoomBar.SELECTION_END, this.services.events.dispatchEvent(O.ZoomDomain.CHANGE, {
        newDomain: s
      })), this.services.events.dispatchEvent(a, {
        selection: i,
        newDomain: s
      });
    }
  }
  updateBrushHandle(t, n) {
    const r = this, i = ye.handleWidth, s = b(this.getOptions(), "zoomBar", H.TOP, "type"), a = ye.height[s], o = -i / 2, l = ye.handleBarWidth, c = s === We.GRAPH_VIEW ? ye.handleBarHeight : 6, u = -l / 2, h = (a - c) / 2;
    t.select(this.brushSelector).selectAll("rect.handle").data([{ type: "w" }, { type: "e" }]).attr("x", function(f) {
      if (f.type === "w")
        return Math.max(n[0] + o, r.maxSelectionRange[0]);
      if (f.type === "e")
        return Math.min(n[1] + o, r.maxSelectionRange[1] - i);
    }).attr("y", 0).attr("width", i).attr("height", a).attr("cursor", "ew-resize").style("display", null);
    const d = t.select(this.brushSelector).selectAll("rect.handle-bar").data([{ type: "w" }, { type: "e" }]);
    d.enter().append("rect").attr("class", function(f) {
      return "handle-bar handle-bar--" + f.type;
    }), d.attr("x", function(f) {
      if (f.type === "w")
        return Math.max(
          n[0] + u,
          r.maxSelectionRange[0] - o + u
        );
      if (f.type === "e")
        return Math.min(
          n[1] + u,
          r.maxSelectionRange[1] + o + u
        );
    }).attr("y", h).attr("width", l).attr("height", c).attr("cursor", "ew-resize"), s === We.SLIDER_VIEW && this.updateSliderSelectedArea(n), this.updateClipPath(
      t,
      this.clipId,
      n[0],
      0,
      n[1] - n[0],
      a
    );
  }
  updateSliderSelectedArea(t) {
    const n = b(this.getOptions(), "zoomBar", H.TOP, "type"), r = ye.height[n], i = this.getComponentContainer().select("svg.zoom-container");
    D.appendOrSelect(i, "rect.zoom-slider-selected-area").attr("x", t[0]).attr("y", r / 2 - 1).attr("width", t[1] - t[0]).attr("height", 2);
  }
  renderZoomBarArea(t, n, r, i) {
    const { cartesianScales: s } = this.services, a = s.getMainXAxisPosition(), o = s.getMainYAxisPosition(), l = s.getMainXScaleType(), c = s.getMainYScaleType(), u = (v, y, x) => (S) => s.getValueFromScale(v, y, x, S), h = u(this.xScale, l, a), d = u(this.yScale, c, o), f = b(this.getOptions(), "zoomBar", H.TOP, "type"), p = ye.height[f], m = Nc().x((v) => h(v)).y0(p).y1((v) => p - d(v)), g = D.appendOrSelect(t, n).datum(r).attr("d", m);
    i && g.attr("clip-path", `url(#${i})`);
  }
  updateClipPath(t, n, r, i, s, a) {
    const o = D.appendOrSelect(t, "clipPath").attr("id", n);
    D.appendOrSelect(o, "rect").attr("x", r).attr("y", i).attr("width", s).attr("height", a);
  }
  // assume the domains in data are already sorted
  compensateDataForDefaultDomain(t, n) {
    if (!t || t.length < 2)
      return;
    const r = xn(t), i = this.services.cartesianScales.getDomainIdentifier(), s = this.services.cartesianScales.getRangeIdentifier();
    if (Number(n[0]) < Number(r[0][i])) {
      const a = {};
      a[i] = n[0], a[s] = 0, r.unshift(a);
    }
    if (Number(n[1]) > Number(r[r.length - 1][i])) {
      const a = {};
      a[i] = n[1], a[s] = 0, r.push(a);
    }
    return r;
  }
  renderZoomBarBaseline(t, n, r, i = !1) {
    const s = b(
      this.model.getOptions(),
      "zoomBar",
      H.TOP,
      "type"
    ), a = ye.height[s], o = Ki()([
      [n, a],
      [r, a]
    ]);
    D.appendOrSelect(t, "path.zoom-bg-baseline").attr("d", o).classed("zoom-bg-baseline-skeleton", i).style(
      "stroke",
      i ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  renderSkeleton(t, n, r) {
    this.renderZoomBarArea(t, "path.zoom-graph-area-unselected", [], null), this.renderZoomBarArea(t, "path.zoom-graph-area", [], this.clipId), this.brush.on("start brush end", null), D.appendOrSelect(this.getComponentContainer(), this.brushSelector).html(null), b(this.getOptions(), "zoomBar", H.TOP, "type") === We.GRAPH_VIEW && this.renderZoomBarBaseline(t, n, r, !0);
  }
  destroy() {
    this.brush.on("start brush end", null), this.services.events.removeEventListener(O.ZoomBar.UPDATE, this.render.bind(this));
  }
}
class II extends dt {
  constructor(t, n) {
    super(t, n), this.type = "threshold", this.renderType = K.SVG, this.positionService = new so();
  }
  render(t = !1) {
    const n = b(this.getOptions(), "axes"), r = [];
    Object.keys(n).forEach((c) => {
      if (Object.values(H).includes(c)) {
        const u = n[c];
        u.thresholds && u.thresholds.length > 0 && r.push({
          axisPosition: c,
          thresholds: u.thresholds,
          correspondingDatasets: u == null ? void 0 : u.correspondingDatasets,
          mapsTo: u == null ? void 0 : u.mapsTo
        });
      }
    });
    const i = this.getComponentContainer({ withinChartClip: !0 }).selectAll("g.axis-thresholds").data(r, (c) => c.axisPosition);
    i.exit().attr("opacity", 0).remove();
    const s = i.enter().append("g").merge(i);
    s.attr("class", (c) => `axis-thresholds ${c.axisPosition}`);
    const a = s.selectAll("g.threshold-group").data(
      (c) => c.thresholds.map((u) => (u.axisPosition = c.axisPosition, u.datum = this.constructDatumObj(c, u), u))
    );
    a.exit().attr("opacity", 0).remove();
    const o = a.enter().append("g");
    o.append("line").attr("class", "threshold-line"), o.append("rect").attr("class", "threshold-hoverable-area"), o.merge(a).attr("class", "threshold-group");
    const l = this;
    s.each(function({ axisPosition: c }) {
      const u = l.services.cartesianScales.getScaleByPosition(
        c
      ), h = l.services.cartesianScales.getScaleTypeByPosition(c);
      let d = null, f = null;
      c === H.LEFT || c === H.RIGHT ? (f = u, d = l.services.cartesianScales.getMainXScale()) : (d = u, f = l.services.cartesianScales.getMainYScale());
      const p = h === X.LABELS, [m, g] = d.range(), [v, y] = f.range(), { cartesianScales: x } = l.services, S = x.getOrientation(), _ = (L) => x.getDomainValue(L), E = (L) => x.getRangeValue(L), [T, k] = dn(
        _,
        E,
        S
      ), N = R(this);
      c === H.TOP || c === H.BOTTOM ? (N.selectAll("line.threshold-line").transition().call(
        (L) => l.services.transitions.setupTransition({
          transition: L,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("y1", y).attr("y2", v).attr(
        "x1",
        ({ datum: L }) => T(L) + (p ? u.step() / 2 : 0)
      ).attr(
        "x2",
        ({ datum: L }) => T(L) + (p ? u.step() / 2 : 0)
      ).style("stroke", ({ fillColor: L }) => L), N.selectAll("rect.threshold-hoverable-area").attr("x", 0).attr("y", ({ datum: L }) => -T(L)).attr("width", Math.abs(v - y)).classed("rotate", !0)) : (N.selectAll("line.threshold-line").transition().call(
        (L) => l.services.transitions.setupTransition({
          transition: L,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("x1", m).attr("x2", g).attr(
        "y1",
        ({ datum: L }) => k(L) + (p ? u.step() / 2 : 0)
      ).attr(
        "y2",
        ({ datum: L }) => k(L) + (p ? u.step() / 2 : 0)
      ).style("stroke", ({ fillColor: L }) => L), N.selectAll("rect.threshold-hoverable-area").attr("x", m).attr("y", ({ datum: L }) => k(L)).attr("width", Math.abs(g - m)).classed("rotate", !1));
    }), this.services.events.addEventListener(O.Threshold.SHOW, (c) => {
      this.setThresholdLabelPosition(c.detail), this.label.classed("hidden", !1);
    }), this.services.events.addEventListener(O.Threshold.HIDE, () => {
      this.label.classed("hidden", !0);
    }), this.appendThresholdLabel(), this.addEventListeners();
  }
  getFormattedValue(t) {
    const { value: n, axisPosition: r } = t, i = this.getOptions();
    if (this.services.cartesianScales.getScaleTypeByPosition(r) === X.TIME) {
      const s = [H.LEFT, H.RIGHT].includes(r), a = this.services.cartesianScales.getMainXScale(), o = this.services.cartesianScales.getMainYScale(), l = s ? o : a, c = b(i, "timeScale"), u = Nl(
        l.ticks(),
        b(c, "timeInterval")
      );
      return Il(n, 0, l.ticks(), u, c);
    }
    return n.toLocaleString("en");
  }
  appendThresholdLabel() {
    const t = R(this.services.domUtils.getHolder()), n = b(this.getOptions(), "style", "prefix");
    this.label = D.appendOrSelect(
      t,
      `div.${he}--${n}--threshold--label`
    ).classed("hidden", !0);
  }
  setThresholdLabelPosition({ event: t, datum: n }) {
    const r = this.services.domUtils.getHolder(), i = Yn(t, r), s = n.valueFormatter ? n.valueFormatter(n.value) : this.getFormattedValue(n);
    this.label.html(`${n.label || "Threshold"}: ${s}`).style("background-color", n.fillColor);
    const a = this.label.node(), o = this.positionService.findBestPlacementAt(
      {
        left: i[0],
        top: i[1]
      },
      a,
      [te.RIGHT, te.LEFT, te.TOP, te.BOTTOM],
      () => ({
        top: void 0,
        // other package lists this as non-optional
        left: void 0,
        // ditto
        width: r.offsetWidth,
        height: r.offsetHeight
      })
    ), l = this.positionService.findPositionAt(
      {
        left: i[0],
        top: i[1]
      },
      a,
      o
    );
    this.positionService.setElement(a, l);
  }
  // Constructs object to pass in scale functions
  constructDatumObj(t, n) {
    const r = {};
    return t.correspondingDatasets && (r.group = b(t, "correspondingDatasets", 0)), r[t.mapsTo] = n.value, r;
  }
  addEventListeners() {
    const t = this;
    this.getComponentContainer({ withinChartClip: !0 }).selectAll("rect.threshold-hoverable-area").on("mouseover mousemove", function(n) {
      R(this.parentNode).select("line.threshold-line").classed("active", !0), t.services.events.dispatchEvent(O.Threshold.SHOW, {
        event: n,
        hoveredElement: R(this),
        datum: R(this).datum()
      });
    }).on("mouseout", function(n) {
      R(this.parentNode).select("line.threshold-line").classed("active", !1), t.services.events.dispatchEvent(O.Threshold.HIDE, {
        event: n,
        hoveredElement: R(this),
        datum: R(this).datum()
      });
    });
  }
}
class NI extends dt {
  constructor(t, n) {
    super(t, n), this.type = "highlight", this.renderType = K.SVG, this.positionService = new so(), this.highlightStrokeWidth = 1;
  }
  render(t = !1) {
    const n = b(this.getOptions(), "axes"), r = [];
    Object.keys(n).forEach((c) => {
      if (Object.values(H).includes(c)) {
        const u = n[c];
        u.highlights && u.highlights.data.length > 0 && r.push({
          axisPosition: c,
          highlightStartMapsTo: u.highlights.highlightStartMapsTo,
          highlightEndMapsTo: u.highlights.highlightEndMapsTo,
          labelMapsTo: u.highlights.labelMapsTo,
          highlight: u.highlights.data,
          color: u.highlights.color
        });
      }
    });
    const i = this.getComponentContainer({ withinChartClip: !0 }).selectAll("g.axis-highlight").data(r, (c) => c.axisPosition);
    i.exit().attr("opacity", 0).remove();
    const s = i.enter().append("g").merge(i);
    s.attr("class", (c) => `axis-highlight ${c.axisPosition}`);
    const a = s.selectAll("g.highlight-group").data(
      (c) => c.highlight.map((u) => (u.axisPosition = c.axisPosition, u.highlightStartMapsTo = c.highlightStartMapsTo, u.labelMapsTo = c.labelMapsTo, u.color = c.color, u.highlightEndMapsTo = c.highlightEndMapsTo, u))
    );
    a.exit().attr("opacity", 0).remove();
    const o = a.enter().append("g");
    o.append("rect").attr("class", "highlight-bar"), o.append("line").attr("class", "highlight-line"), o.merge(a).attr("class", "highlight-group");
    const l = this;
    s.each(function({ axisPosition: c }) {
      const u = l.services.cartesianScales.getMainXScale(), h = l.services.cartesianScales.getMainYScale(), [d, f] = u.range(), [p, m] = h.range(), { cartesianScales: g } = l.services, v = g.getOrientation(), y = (T) => g.getDomainValue(T), x = (T) => g.getRangeValue(T), [S, _] = dn(
        y,
        x,
        v
      ), E = R(this);
      c === H.TOP || c === H.BOTTOM ? E.selectAll("rect.highlight-bar").transition().call(
        (T) => l.services.transitions.setupTransition({
          transition: T,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("y", Math.max(m + l.highlightStrokeWidth, 0)).attr("height", Math.max(p - 2 * l.highlightStrokeWidth, 0)).attr("x", ({ highlightStartMapsTo: T, ...k }) => S(k[T])).attr(
        "width",
        ({ highlightStartMapsTo: T, highlightEndMapsTo: k, ...N }) => Math.max(S(N[k]) - S(N[T]), 0)
      ).style("stroke", ({ color: T, labelMapsTo: k, ...N }) => T && T.scale[N[k]] ? T.scale[N[k]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", l.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: T, labelMapsTo: k, ...N }) => T && T.scale[N[k]] ? T.scale[N[k]] : null) : E.selectAll("rect.highlight-bar").transition().call(
        (T) => l.services.transitions.setupTransition({
          transition: T,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("x", d).attr("width", Math.max(f - d, 0)).attr("y", ({ highlightEndMapsTo: T, ...k }) => _(k[T])).attr(
        "height",
        ({ highlightStartMapsTo: T, highlightEndMapsTo: k, ...N }) => Math.max(_(N[T]) - _(N[k]), 0)
      ).style("stroke", ({ color: T, labelMapsTo: k, ...N }) => T && T.scale[N[k]] ? T.scale[N[k]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", l.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: T, labelMapsTo: k, ...N }) => T && T.scale[N[k]] ? T.scale[N[k]] : null);
    });
  }
}
class vv extends su {
  getItems(t) {
    if (t.detail.items)
      return t.detail.items;
    const { data: n } = t.detail;
    if (!n || !n.length || !n[0])
      return [];
    const r = this.getOptions(), { cartesianScales: i } = this.services, s = i.getDomainIdentifier(), a = i.isDualAxes(), { groupMapsTo: o } = r.data, l = i.getDomainLabel();
    let c = i.getRangeLabel();
    const u = n[0][s];
    let h;
    if (n.length === 1) {
      const d = n[0], f = i.getRangeIdentifier(d);
      if (a) {
        const m = i.getRangeAxisPosition({
          datum: d,
          groups: [d[o]]
        });
        c = i.getScaleLabel(m);
      }
      const p = d[f];
      h = [
        {
          label: l,
          value: u
        },
        ...Array.isArray(p) && p.length === 2 ? [
          {
            label: "Start",
            value: p[0]
          },
          {
            label: "End",
            value: p[1]
          }
        ] : [
          {
            label: c,
            value: d[f]
          }
        ]
      ], t.detail.additionalItems && t.detail.additionalItems.forEach(
        (m) => h.push({
          label: m.label,
          value: m.value
        })
      ), h.push({
        label: r.tooltip.groupLabel,
        value: d[o],
        color: this.model.getFillColor(d[o]),
        class: this.model.getColorClassName({
          classNameTypes: [et.TOOLTIP],
          dataGroupName: d[o]
        })
      });
    } else if (n.length > 1 && (h = [
      {
        label: l,
        value: u
      }
    ], h = h.concat(
      n.map((d) => {
        const f = d[i.getRangeIdentifier(d)];
        return {
          label: d[o],
          value: Array.isArray(f) && f.length === 2 ? `${f[0]} - ${f[1]}` : f,
          color: this.model.getFillColor(d[o]),
          class: this.model.getColorClassName({
            classNameTypes: [et.TOOLTIP],
            dataGroupName: d[o]
          })
        };
      }).sort((d, f) => f.value - d.value)
    ), !a && b(r, "tooltip", "showTotal") === !0)) {
      const d = i.getRangeIdentifier();
      h.push({
        label: At(r, "tooltip.totalLabel") || "Total",
        value: n.reduce(
          (f, p) => f + p[d],
          0
        ),
        bold: !0
      });
    }
    return h;
  }
}
class PI extends dt {
  constructor() {
    super(...arguments), this.type = "alluvial", this.renderType = K.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 });
    n.html("");
    const { width: r, height: i } = D.getSVGElementSize(n, {
      useAttrs: !0
    });
    if (r < 1 || i < 1)
      return;
    const s = this.model.getOptions(), a = this.model.getDisplayData(), o = b(
      this.getOptions(),
      "color",
      "gradient",
      "enabled"
    );
    let l = Le.minNodePadding;
    s.alluvial.nodePadding > Le.minNodePadding && (l = s.alluvial.nodePadding);
    const c = b(s, "alluvial", "nodeAlignment");
    let u = Hm;
    c === Yt.LEFT ? u = ID : c === Yt.RIGHT && (u = ND);
    const h = VD().nodeId((g) => g.name).nodeWidth(Le.nodeWidth).nodePadding(l).nodeAlign(u).extent([
      [2, 30],
      [r - 2, i]
    ]);
    this.graph = h({
      nodes: s.alluvial.nodes.map((g) => Object.assign({}, g)),
      links: a.map((g) => Object.assign({}, g))
    }), this.graph.nodes = this.graph.nodes.filter((g) => g.value !== 0);
    const d = {};
    this.graph.nodes.forEach((g) => {
      const v = g.x0;
      g.category && (d[v] = g == null ? void 0 : g.category);
    }), n.append("g").classed("header-arrows", !0).selectAll("g").data(Object.keys(d)).join("g").attr("transform", (g) => `translate(${g}, 0)`).append("text").attr(
      "id",
      (g, v) => this.services.domUtils.generateElementIDString(`alluvial-category-${v}`)
    ).style("font-size", "14px").text((g) => d[g] ? d[g] : "").attr("y", 20).attr("x", (g, v) => {
      const y = this.services.domUtils.generateElementIDString(
        `alluvial-category-${v}`
      ), { width: x } = D.getSVGElementSize(R(`text#${y}`), { useBBox: !0 });
      let S = 0;
      return g + S >= x && (S = -x + 4), S;
    });
    const f = n.append("g").attr("fill", "none").selectAll("g").data(this.graph.links);
    if (f.exit().remove(), o) {
      const g = b(this.getOptions(), "color", "scale");
      g && f.enter().append("linearGradient").attr("id", (v) => `${this.gradient_id}-link-${v.index}`).attr("gradientUnits", "userSpaceOnUse").call(
        (v) => v.append("stop").attr("offset", "0%").attr("stop-color", (y) => g[y.source.name])
      ).call(
        (v) => v.append("stop").attr("offset", "100%").attr("stop-color", (y) => g[y.target.name])
      ), f.exit().remove();
    }
    f.enter().append("path").classed("link", !0).attr("d", QD()).attr(
      "id",
      (g) => this.services.domUtils.generateElementIDString(`alluvial-line-${g.index}`)
    ).attr("class", (g) => s.alluvial.monochrome ? this.model.getColorClassName({
      classNameTypes: [et.STROKE],
      dataGroupName: 0,
      originalClassName: "link"
    }) : this.model.getColorClassName({
      classNameTypes: [et.STROKE],
      dataGroupName: g.source.index,
      originalClassName: "link"
    })).style("stroke", (g) => o ? `url(#${this.gradient_id}-link-${g.index})` : this.model.getFillColor(g.source.name)).attr("stroke-width", (g) => Math.max(1, g.width)).style("stroke-opacity", Le.opacity.default).attr(
      "aria-label",
      (g) => `${g.source.name}  ${g.target.name} (${g.value}${s.alluvial.units ? " " + s.alluvial.units : ""})`
    );
    const p = n.append("g").selectAll("g").data(this.graph.nodes).enter().append("g").attr(
      "id",
      (g) => this.services.domUtils.generateElementIDString(`alluvial-node-${g.index}`)
    ).classed("node-group", !0).attr("transform", (g) => `translate(${g.x0}, ${g.y0})`);
    p.append("rect").classed("node", !0).attr("height", (g) => g.y1 - g.y0).attr("width", (g) => g.x1 - g.x0).attr("fill", "black");
    const m = p.append("g").attr(
      "id",
      (g) => this.services.domUtils.generateElementIDString(`alluvial-node-title-${g.index}`)
    );
    m.append("text").attr(
      "id",
      (g) => this.services.domUtils.generateElementIDString(`alluvial-node-text-${g.index}`)
    ).attr("class", "node-text").style("font-size", "12px").attr("text-anchor", "start").attr("fill", "white").attr("x", 4).attr("dy", 13).text((g) => `${g.name} (${g.value})`).attr("aria-label", (g) => `${g.name} (${g.value})`), m.append("rect").classed("node-text-bg", !0).attr("width", (g, v) => {
      const y = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${v}`
      ), { width: x } = D.getSVGElementSize(R(`text#${y}`), { useBBox: !0 });
      return x + 8;
    }).attr("height", 18).attr("stroke-width", 2).lower(), m.attr("transform", (g, v) => {
      const y = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${v}`
      ), { width: x } = D.getSVGElementSize(R(`text#${y}`), { useBBox: !0 }), S = (g.y1 - g.y0) / 2 - 9;
      let _ = g.x1 - g.x0;
      return g.x1 >= x ? _ = _ - (x + 16) : _ += 4, `translate(${_}, ${S})`;
    }), this.addLineEventListener(), this.addNodeEventListener();
  }
  addLineEventListener() {
    const t = this.getOptions(), n = this, r = ba((i, s = "mouseover") => {
      const a = n.parent.selectAll("path.link").transition().call(
        (o) => n.services.transitions.setupTransition({
          transition: o,
          name: "alluvial-links-mouse-highlight"
        })
      );
      s === "mouseout" ? (R(i).lower(), a.style("stroke-opacity", Le.opacity.default)) : a.style("stroke-opacity", function() {
        return i === this ? (R(this).raise(), Le.opacity.selected) : Le.opacity.unfocus;
      });
    }, 33);
    this.parent.selectAll("path.link").on("mouseover", function(i, s) {
      const a = R(this);
      r(this, "mouseover"), a.classed("link-hovered", !0);
      const o = getComputedStyle(this).getPropertyValue("stroke");
      n.services.events.dispatchEvent(O.Alluvial.LINE_MOUSEOVER, {
        event: i,
        element: a,
        datum: s
      }), n.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: i,
        hoveredElement: a,
        items: [
          {
            label: s.target.name,
            value: s.value + (t.alluvial.units ? ` ${t.alluvial.units}` : ""),
            color: o,
            labelIcon: n.getRightArrowIcon()
          }
        ]
      });
    }).on("mousemove", function(i, s) {
      n.services.events.dispatchEvent(O.Alluvial.LINE_MOUSEMOVE, {
        event: i,
        element: R(this),
        datum: s
      }), n.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function(i, s) {
      n.services.events.dispatchEvent(O.Alluvial.LINE_CLICK, {
        event: i,
        element: R(this),
        datum: s
      });
    }).on("mouseout", function(i, s) {
      const a = R(this);
      r(this, "mouseout"), a.classed("link-hovered", !1), n.services.events.dispatchEvent(O.Alluvial.LINE_MOUSEOUT, {
        event: i,
        element: a,
        datum: s
      }), n.services.events.dispatchEvent(O.Tooltip.HIDE, {
        event: i,
        hoveredElement: a
      });
    });
  }
  addNodeEventListener() {
    const t = this, n = ba((r = [], i = "mouseover") => {
      if (i === "mouseout" || r.length === 0) {
        t.parent.selectAll("path.link").classed("link-hovered", !1).data(this.graph.links, (s) => s.index).order().style("stroke-opacity", Le.opacity.default);
        return;
      }
      t.parent.selectAll("path.link").transition().call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "alluvial-link-mouse-highlight"
        })
      ).style("stroke-opacity", function(s) {
        return r.some((a) => a === s.index) ? (R(this).classed("link-hovered", !0).raise(), Le.opacity.selected) : Le.opacity.unfocus;
      });
    }, 66);
    t.parent.selectAll(".node-group").on("mouseover", function(r, i) {
      const s = R(this), a = [];
      if (t.traverse({ link: "sourceLinks", node: "target" }, i, a), t.traverse({ link: "targetLinks", node: "source" }, i, a), a.length) {
        const o = yi(s.attr("transform"));
        if (s.attr("transform", `translate(${o.x - 2}, ${o.y})`), s.classed("node-hovered", !0).selectAll("rect.node").attr("width", 8), i.x0 - 2 === 0) {
          const c = t.services.domUtils.generateElementIDString(
            `alluvial-node-title-${i.index}`
          ), u = t.parent.select(`g#${c}`), h = yi(u.attr("transform"));
          u.attr("transform", `translate(${h.x + 4},${h.y})`);
        }
        const l = t.services.domUtils.generateElementIDString(
          `alluvial-node-text-${i.index}`
        );
        t.parent.select(`text#${l}`).style("font-weight", "bold"), n(a, "mouseover"), t.services.events.dispatchEvent(O.Alluvial.NODE_MOUSEOVER, {
          event: r,
          element: s,
          datum: i
        });
      }
    }).on("mousemove", function(r, i) {
      t.services.events.dispatchEvent(O.Alluvial.NODE_MOUSEMOVE, {
        event: r,
        element: R(this),
        datum: i
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, i) {
      t.services.events.dispatchEvent(O.Alluvial.NODE_CLICK, {
        event: r,
        element: R(this),
        datum: i
      });
    }).on("mouseout", function(r, i) {
      const s = R(this), a = yi(s.attr("transform"));
      if (s.classed("node-hovered", !1).attr("transform", `translate(${a.x + 2}, ${a.y})`).select("rect.node").attr("width", Le.nodeWidth), i.x0 - 2 === 0) {
        const l = t.services.domUtils.generateElementIDString(
          `alluvial-node-title-${i.index}`
        ), c = t.parent.select(`g#${l}`), u = yi(c.attr("transform"));
        c.attr("transform", `translate(${u.x - 4},${u.y})`);
      }
      const o = t.services.domUtils.generateElementIDString(
        `alluvial-node-text-${i.index}`
      );
      t.parent.select(`text#${o}`).style("font-weight", "normal"), n([], "mouseout"), t.services.events.dispatchEvent(O.Alluvial.NODE_MOUSEOUT, {
        event: r,
        element: s,
        datum: i
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: s
      });
    });
  }
  // Traverse graph and get all connected links to node
  traverse(t, n, r = []) {
    n[t.link].map((i) => (r.push(i.index), i[t.node])).forEach((i) => this.traverse(t, i, r));
  }
  getRightArrowIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" class="arrow-right" width="32" height="32" viewBox="0 0 32 32">
			<polygon points="18 6 16.57 7.393 24.15 15 4 15 4 17 24.15 17 16.57 24.573 18 26 28 16 18 6"/>
			<rect width="32" height="32"/>
		</svg>`;
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("path.line,.node-group").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
  }
}
class Ee extends dt {
  constructor() {
    super(...arguments), this.type = "grid", this.renderType = K.SVG;
  }
  render(t = !0) {
    const n = b(this.getOptions(), "grid", "x", "enabled"), r = b(this.getOptions(), "grid", "y", "enabled");
    this.drawBackdrop(n, r), !(!n && !r) && (n && (D.appendOrSelect(this.backdrop, "g.x.grid"), this.drawXGrid(t)), r && (D.appendOrSelect(this.backdrop, "g.y.grid"), this.drawYGrid(t)));
  }
  drawXGrid(t) {
    const n = this.parent, r = this.backdrop.attr("height"), i = this.services.cartesianScales.getMainXScale(), s = hc(i).tickSizeInner(-r).tickSizeOuter(0);
    if (b(this.getOptions(), "grid", "x", "alignWithAxisTicks")) {
      const o = this.services.cartesianScales.getDomainAxisPosition(), l = b(this.getOptions(), "axes", o, "ticks", "values");
      l && s.tickValues(l);
    } else {
      const o = b(this.getOptions(), "grid", "x", "numberOfTicks");
      s.ticks(o);
    }
    const a = n.select(".x.grid").attr("transform", `translate(${-this.backdrop.attr("x")}, ${r})`);
    t ? a.transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "grid-update",
        animate: t
      })
    ).call(s) : a.call(s), this.cleanGrid(a);
  }
  drawYGrid(t) {
    const n = this.parent, r = this.backdrop.attr("width"), i = this.services.cartesianScales.getMainYScale(), s = ep(i).tickSizeInner(-r).tickSizeOuter(0);
    if (b(this.getOptions(), "grid", "y", "alignWithAxisTicks")) {
      const o = this.services.cartesianScales.getRangeAxisPosition(), l = b(this.getOptions(), "axes", o, "ticks", "values");
      l && s.tickValues(l);
    } else {
      const o = b(this.getOptions(), "grid", "y", "numberOfTicks");
      s.ticks(o);
    }
    const a = n.select(".y.grid").attr("transform", `translate(0, ${-this.backdrop.attr("y")})`);
    t ? a.transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "grid-update",
        animate: t
      })
    ).call(s) : a.call(s), this.cleanGrid(a);
  }
  /**
   * Returns the threshold for the gridline tooltips based on the mouse location.
   * Calculated based on the mouse position between the two closest gridlines or edges of chart.
   */
  getGridlineThreshold(t) {
    const n = this.parent, r = n.selectAll(".x.grid .tick").nodes().sort((u, h) => Number(an(u).tx) - Number(an(h).tx));
    let i = -1;
    if (!r.length)
      return;
    r.forEach((u) => {
      t[0] >= +an(u).tx && i++;
    });
    const s = i + 1 < r.length ? i + 1 : r.length, a = r[i], o = r[s];
    let l;
    if (!a)
      l = +an(o).tx;
    else if (o)
      l = +an(o).tx - +an(a).tx;
    else {
      const u = n.select("rect.chart-grid-backdrop").node();
      l = D.getSVGElementSize(u).width - +an(a).tx;
    }
    const { threshold: c } = this.getOptions().tooltip.gridline;
    return l * c;
  }
  /**
   * Returns the active gridlines based on the gridline threshold and mouse position.
   * @param position mouse positon
   */
  getActiveGridline(t) {
    const n = b(this.getOptions, "tooltip", "gridline", "threshold"), r = n || this.getGridlineThreshold(t);
    return this.parent.selectAll(".x.grid .tick").filter(function() {
      const i = an(this), s = {
        min: Number(i.tx) - r,
        max: Number(i.tx) + r
      };
      return s.min <= t[0] && t[0] <= s.max;
    });
  }
  drawBackdrop(t, n) {
    const r = this.parent, i = this.services.cartesianScales.getMainXScale(), s = this.services.cartesianScales.getMainYScale(), [a, o] = i.range(), [l, c] = s.range();
    this.backdrop = D.appendOrSelect(r, "svg.chart-grid-backdrop");
    const u = D.appendOrSelect(
      this.backdrop,
      t || n ? "rect.chart-grid-backdrop.stroked" : "rect.chart-grid-backdrop"
    );
    this.backdrop.merge(u).attr("x", a).attr("y", c).attr("width", Math.abs(o - a)).attr("height", Math.abs(l - c)).lower(), u.attr("width", "100%").attr("height", "100%");
  }
  cleanGrid(t) {
    t.selectAll("text").remove(), t.select(".domain").remove();
  }
}
class yv extends dt {
  constructor() {
    super(...arguments), this.type = "area", this.renderType = K.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999), this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-area"
        })
      ).attr("opacity", (r) => r.name !== n.datum().name ? cn.opacity.unselected : cn.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", cn.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.getOptions();
    let i = [0, 0];
    const { cartesianScales: s } = this.services, a = s.getOrientation(), o = Nc().curve(this.services.curves.getD3Curve()).defined((_) => {
      const E = s.getRangeIdentifier();
      return _[E] != null;
    }), l = this.model.getGroupedData(this.configs.groups), c = b(r, "bounds"), u = c && l && l.length === 1;
    !u && c && console.warn(
      `Bounds can only be shown when having 1 single datagroup, you've supplied ${l.length}`
    );
    let h = 0;
    const d = (_, E) => {
      b(r, "axes", _, "includeZero") === !1 && E[0] > 0 && E[1] > 0 && (h = E[0]);
    }, f = (_) => u ? s.getBoundedScaledValues(_)[0] : s.getRangeValue(h), p = (_) => u ? s.getBoundedScaledValues(_)[1] : s.getRangeValue(_);
    a === Kt.VERTICAL ? (i = s.getMainYScale().domain(), d(s.getMainYAxisPosition(), i), o.x((_) => s.getDomainValue(_)).y0((_) => f(_)).y1((_) => p(_))) : (i = s.getMainXScale().domain(), d(s.getMainXAxisPosition(), i), o.x0((_) => f(_)).x1((_) => p(_)).y((_) => s.getDomainValue(_)));
    const m = b(r, "color", "gradient", "enabled"), g = l && l.length === 1 && m;
    l.length > 1 && m && console.error("Gradients can only be enabled when having 1 single dataset");
    const v = n.selectAll("path.area").data(l, (_) => _.name), y = R(this.services.domUtils.getMainContainer());
    if (v.exit().attr("opacity", 0).remove(), !l.length)
      return;
    if (g) {
      const _ = y.select(
        `path.${this.model.getColorClassName({
          classNameTypes: [et.STROKE],
          dataGroupName: l[0].name
        })}`
      ).node();
      let E;
      if (_)
        E = getComputedStyle(_, null).getPropertyValue(
          "stroke"
        );
      else {
        const T = b(this.model.getOptions(), "color", "scale");
        if (T !== null) {
          const k = Object.keys(T);
          E = T[k[0]];
        }
      }
      Ul.appendOrUpdateLinearGradient({
        svg: this.parent,
        id: this.services.domUtils.generateElementIDString(
          `${l[0].name.replace(" ", "")}_${this.gradient_id}`
        ),
        x1: "0%",
        x2: "0%",
        y1: "0%",
        y2: "100%",
        stops: Ul.getStops(i, E)
      });
    } else
      this.parent.selectAll("defs linearGradient").empty() || this.parent.selectAll("defs linearGradient").each(function() {
        this.parentNode.remove();
      });
    const x = this, S = v.enter().append("path");
    g ? S.merge(v).style(
      "fill",
      (_) => `url(#${this.services.domUtils.generateElementIDString(
        `${_.name.replace(" ", "")}_${this.gradient_id}`
      )})`
    ).attr("class", "area").attr(
      "class",
      (_) => this.model.getColorClassName({
        classNameTypes: [et.FILL],
        dataGroupName: _.name,
        originalClassName: "area"
      })
    ).attr("d", (_) => {
      const { data: E } = _;
      return o(E);
    }) : (S.attr("opacity", 0).merge(v).attr("class", "area").attr(
      "class",
      (_) => this.model.getColorClassName({
        classNameTypes: [et.FILL, et.STROKE],
        dataGroupName: _.name,
        originalClassName: "area"
      })
    ).style("fill", (_) => x.model.getFillColor(_.name)).transition().call(
      (_) => this.services.transitions.setupTransition({
        transition: _,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", u ? 1 : cn.opacity.selected).attr("d", (_) => {
      const { data: E } = _;
      return o(E);
    }), u && S.attr("fill-opacity", cn.opacity.selected).style("stroke", (_) => x.model.getStrokeColor(_.name)).style("stroke-dasharray", "2, 2").attr("stroke-width", 0.7 + "px"));
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Lr extends dt {
  constructor() {
    super(...arguments), this.type = "line", this.renderType = K.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("path.line").transition("legend-hover-line").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-line"
        })
      ).attr("opacity", (r) => r.name !== n.datum().name ? ln.opacity.unselected : ln.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", ln.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), { cartesianScales: r, curves: i } = this.services, s = (f) => r.getDomainValue(f), a = (f) => r.getRangeValue(f), [o, l] = dn(
      s,
      a,
      r.getOrientation()
    ), c = this.getOptions(), u = Ki().x(o).y(l).curve(i.getD3Curve()).defined((f) => {
      const p = r.getRangeIdentifier(f);
      return f[p] != null;
    });
    let h = [];
    if (this.configs.stacked) {
      const f = Object.keys(c.axes).some((m) => c.axes[m].percentage), { groupMapsTo: p } = c.data;
      h = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: f
      }).map((m) => {
        const g = this.services.cartesianScales.getDomainIdentifier(m), v = this.services.cartesianScales.getRangeIdentifier(m);
        return {
          name: b(m, 0, p),
          data: m.map((y) => ({
            [g]: y.data.sharedStackKey,
            [p]: y[p],
            [v]: y[1]
          })),
          hidden: !vR(m, (y) => y[0] !== y[1])
        };
      });
    } else
      h = this.model.getGroupedData(this.configs.groups);
    const d = n.selectAll("path.line").data(h, (f) => f.name);
    d.exit().attr("opacity", 0).remove(), d.enter().append("path").classed("line", !0).attr("opacity", 0).merge(d).data(h, (f) => f.name).attr(
      "class",
      (f) => this.model.getColorClassName({
        classNameTypes: [et.STROKE],
        dataGroupName: f.name,
        originalClassName: "line"
      })
    ).style("stroke", (f) => this.model.getStrokeColor(f.name)).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "line").attr("aria-label", (f) => {
      const { data: p } = f;
      return p.map((m) => {
        const g = this.services.cartesianScales.getRangeIdentifier(m);
        return m[g];
      }).join(",");
    }).transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "line-update-enter",
        animate: t
      })
    ).attr("opacity", (f) => f.hidden ? 0 : 1).attr("d", (f) => {
      const { data: p } = f;
      return u(p);
    });
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
const uf = 5;
function UI(e, t) {
  return e > t - uf && e < t + uf;
}
let kn = class extends dt {
  constructor() {
    super(...arguments), this.type = "ruler", this.renderType = K.SVG, this.isXGridEnabled = b(this.getOptions(), "grid", "x", "enabled"), this.isYGridEnabled = b(this.getOptions(), "grid", "y", "enabled"), this.isEventListenerAdded = !1;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = b(this.getOptions(), "ruler", "enabled");
    this.drawBackdrop(), n && !this.isEventListenerAdded ? this.addBackdropEventListeners() : !n && this.isEventListenerAdded && this.removeBackdropEventListeners();
  }
  removeBackdropEventListeners() {
    this.isEventListenerAdded = !1, this.backdrop.on("mousemove mouseover mouseout", null);
  }
  formatTooltipData(t) {
    return t;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  showRuler(t, [n, r]) {
    const i = this.parent, s = this.services.cartesianScales.getOrientation(), a = this.model.getDisplayData(), o = this.services.cartesianScales.getRangeScale(), [l, c] = o.range(), u = s === Kt.HORIZONTAL ? r : n, h = D.appendOrSelect(i, "g.ruler").attr("aria-label", "ruler"), d = D.appendOrSelect(h, "line.ruler-line"), f = i.selectAll("[role=graphics-symbol]"), p = a.map((g) => ({
      domainValue: this.services.cartesianScales.getDomainValue(g),
      originalData: g
    })).filter((g) => UI(g.domainValue, u));
    if (this.pointsWithinLine && p.length === this.pointsWithinLine.length && p.map((g) => g.domainValue).join() === this.pointsWithinLine.map((g) => g.domainValue).join())
      return this.pointsWithinLine = p, this.services.events.dispatchEvent(O.Tooltip.MOVE, {
        mousePosition: [n, r]
      });
    this.pointsWithinLine = p;
    const m = this.pointsWithinLine.reduce((g, v) => {
      if (g.length === 0)
        return g.push(v), g;
      const y = g[0].domainValue, x = Math.abs(u - v.domainValue), S = Math.abs(u - y);
      return x > S || (x < S ? g = [v] : g.push(v)), g;
    }, []);
    if (m.length > 0) {
      const g = m.map((S) => S.originalData).filter((S) => {
        const _ = this.services.cartesianScales.getRangeIdentifier(S);
        return S[_] != null;
      }), v = m.map(
        (S) => S.domainValue
      ), y = f.filter((S) => {
        const _ = this.services.cartesianScales.getDomainValue(S);
        return v.includes(_);
      });
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !ov(this.elementsToHighlight, y) && this.hideRuler(), y.dispatch("mouseover"), this.elementsToHighlight = y, this.services.events.dispatchEvent(O.Tooltip.SHOW, {
        mousePosition: [n, r],
        hoveredElement: d,
        data: this.formatTooltipData(g)
      }), h.attr("opacity", 1);
      const x = m[0];
      s === "horizontal" ? d.attr("x1", c).attr("x2", l).attr("y1", x.domainValue).attr("y2", x.domainValue) : d.attr("y1", c).attr("y2", l).attr("x1", x.domainValue).attr("x2", x.domainValue);
    } else
      this.hideRuler();
  }
  hideRuler() {
    const t = this.parent, n = D.appendOrSelect(t, "g.ruler");
    t.selectAll("[role=graphics-symbol]").dispatch("mouseout"), this.services.events.dispatchEvent(O.Tooltip.HIDE), n.attr("opacity", 0);
  }
  /**
   * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.
   */
  addBackdropEventListeners() {
    this.isEventListenerAdded = !0;
    const t = this, n = this.services.domUtils.getHolder(), r = this.model.getDisplayData();
    let i = function(s) {
      const a = Yn(s, t.parent.node());
      t.showRuler(s, a);
    };
    if (r.length > 100) {
      const s = r.length % 50 * 12.5;
      i = tL(
        function(a) {
          const { mousePosition: o } = this;
          t.showRuler(a, o);
        },
        s,
        n
      );
    }
    this.backdrop.on("mousemove mouseover", i).on("mouseout", this.hideRuler.bind(this));
  }
  drawBackdrop() {
    const t = this.parent;
    this.backdrop = D.appendOrSelect(t, "svg.chart-grid-backdrop");
  }
};
class Ze extends dt {
  constructor() {
    super(...arguments), this.type = "scatter", this.renderType = K.SVG, this.handleChartHolderOnHover = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-hover-scatter").call(
        (t) => {
          var n;
          return (n = this.services.transitions) == null ? void 0 : n.setupTransition({
            transition: t,
            name: "chart-holder-hover-scatter"
          });
        }
      ).attr("opacity", 1);
    }, this.handleChartHolderOnMouseOut = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-mouseout-scatter").call(
        (t) => {
          var n;
          return (n = this.services.transitions) == null ? void 0 : n.setupTransition({
            transition: t,
            name: "chart-holder-mouseout-scatter"
          });
        }
      ).attr("opacity", 0);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-hover-scatter").call(
        (i) => {
          var s;
          return (s = this.services.transitions) == null ? void 0 : s.setupTransition({
            transition: i,
            name: "legend-hover-scatter"
          });
        }
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      if (!this.parent)
        throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-mouseout-scatter").call(
        (t) => {
          var n;
          return (n = this.services.transitions) == null ? void 0 : n.setupTransition({
            transition: t,
            name: "legend-mouseout-scatter"
          });
        }
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    if (!t)
      throw new Error("Services events are undefined.");
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    const { fadeInOnChartHolderMouseover: n } = this.configs;
    n && (t.addEventListener(O.Chart.MOUSEOVER, this.handleChartHolderOnHover), t.addEventListener(O.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut));
  }
  filterBasedOnZoomDomain(t) {
    const { cartesianScales: n } = this.services;
    if (!n)
      throw new Error("Services cartesianScales are undefined.");
    const r = n.getDomainIdentifier(t), i = this.model.get("zoomDomain");
    return i !== void 0 ? t.filter(
      (s) => s[r].getTime() >= i[0].getTime() && s[r].getTime() <= i[1].getTime()
    ) : t;
  }
  getScatterData() {
    const t = this.getOptions(), { stacked: n } = this.configs;
    let r;
    if (n) {
      const i = Object.keys(t.axes).some((s) => t.axes[s].percentage);
      r = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: i
      });
    } else {
      const { cartesianScales: i } = this.services;
      if (!i)
        throw new Error("Services cartesianScales are undefined.");
      r = this.model.getDisplayData(this.configs.groups).filter((s) => {
        const a = i.getRangeIdentifier(s);
        return s[a] !== void 0 && s[a] !== null;
      });
    }
    return this.filterBasedOnZoomDomain(r);
  }
  render(t) {
    if (!(b(this.getOptions(), "points", "enabled") || b(this.getOptions(), "bubble", "enabled")))
      return;
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, { cartesianScales: s } = this.services;
    if (!s)
      throw new Error("Services cartesianScales are undefined.");
    const a = s.getDomainIdentifier(), o = n.selectAll("circle.dot").data(
      this.getScatterData(),
      (c) => `${c[i]}-${c[a]}`
    );
    o.exit().attr("opacity", 0).remove();
    const l = o.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(o);
    this.styleCircles(l, t), this.addEventListeners();
  }
  // A value is an anomaly if is above all defined domain and range thresholds
  isDatapointThresholdAnomaly(t) {
    const { handleThresholds: n } = this.configs;
    if (!n)
      return !1;
    const { cartesianScales: r } = this.services;
    if (!r)
      throw new Error("Cartesian scales service is undefined");
    const i = r.getOrientation(), [s, a] = dn(
      r.getHighestDomainThreshold(),
      r.getHighestRangeThreshold(),
      i
    ), [o, l] = dn(
      (h) => r.getDomainValue(h),
      (h) => r.getRangeValue(h),
      i
    ), c = o(t), u = l(t);
    return a && s ? u <= a.scaleValue && c >= s.scaleValue : a ? u <= a.scaleValue : s ? c >= s.scaleValue : !1;
  }
  styleCircles(t, n) {
    const r = this.getOptions(), { filled: i, fillOpacity: s } = r.points, { cartesianScales: a } = this.services;
    if (!a)
      throw new Error("Cartesian scales service is undefined");
    const { groupMapsTo: o } = r.data, l = (f) => a.getDomainValue(f), c = (f) => a.getRangeValue(f), [u, h] = dn(
      l,
      c,
      a.getOrientation()
    ), { fadeInOnChartHolderMouseover: d } = this.configs;
    t.raise().classed("dot", !0).attr("class", (f) => {
      const p = a.getDomainIdentifier(f), m = this.model.getIsFilled(f[o], f[p], f, i) ? [et.FILL, et.STROKE] : [et.STROKE];
      return this.model.getColorClassName({
        classNameTypes: m,
        dataGroupName: f[o],
        originalClassName: "dot"
      }) || "";
    }).classed("threshold-anomaly", (f) => this.isDatapointThresholdAnomaly(f)).classed("filled", (f) => {
      const p = a.getDomainIdentifier(f);
      return this.model.getIsFilled(f[o], f[p], f, i);
    }).classed("unfilled", (f) => {
      const p = a.getDomainIdentifier(f);
      return !this.model.getIsFilled(f[o], f[p], f, i);
    }).transition().call(
      (f) => {
        var p;
        return (p = this.services.transitions) == null ? void 0 : p.setupTransition({
          transition: f,
          name: "scatter-update-enter",
          animate: n
        });
      }
    ).attr("cx", u).attr("cy", h).attr("r", r.points.radius).style("fill", (f) => {
      const p = a.getDomainIdentifier(f);
      if (this.model.getIsFilled(f[o], f[p], f, i))
        return this.model.getFillColor(f[o], f[p], f);
    }).style("stroke", (f) => {
      const p = a.getDomainIdentifier(f);
      return this.model.getStrokeColor(f[o], f[p], f);
    }).attr("fill-opacity", i ? s : 1).attr("opacity", d ? 0 : 1).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "point").attr("aria-label", (f) => {
      const p = a.getRangeIdentifier(f);
      return f[p];
    }), this.addEventListeners();
  }
  // Extended in bubble graphs
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getTooltipAdditionalItems(t) {
    return null;
  }
  addEventListeners() {
    const t = this, { groupMapsTo: n } = t.getOptions().data;
    if (!this.parent)
      throw new Error("Parent not defined");
    this.parent.selectAll("circle").on("mouseover", function(r, i) {
      var s, a;
      const o = R(this);
      o.classed("hovered", !0).attr(
        "class",
        (l) => t.model.getColorClassName({
          classNameTypes: [et.FILL],
          dataGroupName: l[n],
          originalClassName: o.attr("class")
        })
      ).style("fill", (l) => {
        var c;
        const u = (c = t.services.cartesianScales) == null ? void 0 : c.getDomainIdentifier(l);
        return t.model.getFillColor(l[n], l[u], l);
      }).classed("unfilled", !1), (s = t.services.events) == null || s.dispatchEvent(O.Tooltip.SHOW, {
        event: r,
        hoveredElement: o,
        data: [i],
        additionalItems: t.getTooltipAdditionalItems(i)
      }), (a = t.services.events) == null || a.dispatchEvent(O.Scatter.SCATTER_MOUSEOVER, {
        event: r,
        element: o,
        datum: i
      });
    }).on("mousemove", function(r, i) {
      var s, a;
      const o = R(this);
      (s = t.services.events) == null || s.dispatchEvent(O.Scatter.SCATTER_MOUSEMOVE, {
        event: r,
        element: o,
        datum: i
      }), (a = t.services.events) == null || a.dispatchEvent(O.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, i) {
      var s;
      (s = t.services.events) == null || s.dispatchEvent(O.Scatter.SCATTER_CLICK, {
        event: r,
        element: R(this),
        datum: i
      });
    }).on("mouseout", function(r, i) {
      var s, a, o;
      const l = R(this);
      if (l.classed("hovered", !1), !t.configs.filled) {
        const { filled: c } = t.getOptions().points, u = (s = t.services.cartesianScales) == null ? void 0 : s.getDomainIdentifier(i), h = t.model.getIsFilled(
          i[n],
          i[u],
          i,
          c
        );
        l.classed("unfilled", !h).style("fill", (d) => h || c ? t.model.getFillColor(d[n], d[u], d) : null);
      }
      (a = t.services.events) == null || a.dispatchEvent(O.Scatter.SCATTER_MOUSEOUT, {
        event: r,
        element: l,
        datum: i
      }), (o = t.services.events) == null || o.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: l
      });
    });
  }
  destroy() {
    var t;
    (t = this.parent) == null || t.selectAll("circle").on("mousemove", null).on("mouseout", null);
    const { events: n } = this.services;
    if (!n)
      throw new Error("Services events undefined");
    n.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), n.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), n.removeEventListener(O.Chart.MOUSEOVER, this.handleChartHolderOnHover), n.removeEventListener(O.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
  }
}
class xv extends dt {
  constructor(t, n, r) {
    super(t, n, r), this.type = "axes", this.renderType = K.SVG, this.truncation = {
      [H.LEFT]: !1,
      [H.RIGHT]: !1,
      [H.TOP]: !1,
      [H.BOTTOM]: !1
    }, r && (this.configs = r), this.margins = this.configs.margins;
  }
  render(t = !0) {
    const { position: n } = this.configs, r = this.getOptions(), i = b(r, "axes", n, "visible"), s = this.getComponentContainer(), { width: a, height: o } = D.getSVGElementSize(s, {
      useAttrs: !0
    }), l = D.appendOrSelect(s, `g.axis.${n}`);
    let c, u;
    if (n === H.BOTTOM || n === H.TOP ? (c = this.configs.axes[H.LEFT] ? this.margins.left : 0, u = this.configs.axes[H.RIGHT] ? a - this.margins.right : a) : (c = o - this.margins.bottom, u = this.margins.top), !this.services.cartesianScales)
      throw new Error("Services cartesianScales undefined");
    const h = this.services.cartesianScales.getScaleByPosition(n);
    this.scaleType === X.LABELS || this.scaleType === X.LABELS_RATIO ? h.rangeRound([c, u]) : h.range([c, u]);
    let d;
    switch (n) {
      case H.LEFT:
        d = ep;
        break;
      case H.BOTTOM:
        d = hc;
        break;
      case H.RIGHT:
        d = P0;
        break;
      case H.TOP:
        d = N0;
        break;
    }
    l.attr("aria-label", `${n} axis`);
    const f = !l.select("g.ticks").empty();
    let p = D.appendOrSelect(l, "g.ticks");
    f || (p.attr("role", `${at.GRAPHICS_OBJECT} ${at.GROUP}`), p.attr("aria-label", `${n} ticks`));
    const m = D.appendOrSelect(l, "g.ticks.invisible").style("opacity", "0").style("pointer-events", "none").attr("aria-hidden", !0).attr("aria-label", `invisible ${n} ticks`), g = b(r, "axes", n), v = this.scaleType === X.TIME || g.scaleType === X.TIME, y = n === H.LEFT || n === H.RIGHT, x = this.model.get("zoomDomain");
    if (x && v && !y && h.domain(x), !i) {
      p.attr("aria-hidden", !0);
      return;
    }
    const S = b(g, "scaleType"), _ = b(r, "data", "loading"), E = b(g, "ticks", "number"), T = b(g, "ticks", "values"), k = b(g, "truncation", "type"), N = b(g, "truncation", "threshold"), L = b(g, "truncation", "numCharacter"), C = E !== null, V = b(r, "timeScale"), M = D.appendOrSelect(m, "g.tick"), A = D.appendOrSelect(M, "text").text("0"), w = D.getSVGElementSize(A.node(), {
      useBBox: !0
    }).height;
    M.remove();
    const P = this.scaleType || g.scaleType || X.LINEAR, U = d(h).tickSizeOuter(0);
    if (h.ticks) {
      let z;
      if (C ? z = E : (z = An.ticks.number, y && (z = this.getNumberOfFittingTicks(
        o,
        w,
        An.ticks.verticalSpaceRatio
      ))), h.ticks().length === 1 && h.ticks()[0] === 0 && (z = 0), U.ticks(z), v)
        if (!h.ticks(z).length)
          U.tickValues([]);
        else {
          const Z = b(r, "timeScale", "addSpaceOnEdges"), ut = b(r, "axes", n, "domain"), nt = h.copy();
          Z && !ut && nt.nice(z);
          const Ot = nt.ticks(z);
          Z && Ot.length > 2 && !ut && (Ot.splice(Ot.length - 1, 1), Ot.splice(0, 1)), U.tickValues(Ot);
        }
    }
    let I;
    const B = b(g, "ticks", "formatter");
    if (v) {
      const z = Nl(
        U.tickValues(),
        b(r, "timeScale", "timeInterval")
      );
      B === null ? I = (Z, ut) => Il(Z, ut, U.tickValues(), z, V) : I = (Z, ut) => {
        const nt = Il(
          Z,
          ut,
          U.tickValues(),
          z,
          V
        );
        return B(Z, ut, nt);
      };
    } else
      B === null ? P === X.LINEAR && (I = (z) => z.toLocaleString()) : I = B;
    U.tickFormat(I);
    const [j, Y] = this.services.cartesianScales.getScaleByPosition(n).domain();
    let J;
    if (T) {
      if (v)
        T.forEach((z, Z) => {
          z.getTime === void 0 && (T[Z] = new Date(z));
        }), J = T.filter((z) => {
          const Z = z.getTime();
          return Z >= new Date(j).getTime() && Z <= new Date(Y).getTime();
        });
      else if (S === X.LABELS) {
        const z = this.services.cartesianScales.getScaleByPosition(n).domain();
        J = T.filter((Z) => z.includes(Z));
      } else
        J = T.filter(
          (z) => z >= j && z <= Y
        );
      U.tickValues(J);
    }
    switch (n) {
      case H.LEFT:
        p.attr("transform", `translate(${this.margins.left}, 0)`);
        break;
      case H.BOTTOM:
        p.attr("transform", `translate(0, ${o - this.margins.bottom})`);
        break;
      case H.RIGHT:
        p.attr("transform", `translate(${a - this.margins.right}, 0)`);
        break;
      case H.TOP:
        p.attr("transform", `translate(0, ${this.margins.top})`);
        break;
    }
    const ft = this.model.isDataEmpty();
    if (g.title) {
      const z = D.appendOrSelect(l, "text.axis-title").html(
        ft || _ ? "" : g.title
      ), Z = b(g, "titleOrientation");
      let ut;
      switch (n) {
        case H.LEFT:
          Z === Zo.RIGHT ? z.attr("transform", "rotate(90)").attr("y", 0).attr("x", h.range()[0] / 2).attr("dy", "-0.5em").style("text-anchor", "middle") : z.attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(h.range()[0] / 2)).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case H.BOTTOM:
          z.attr(
            "transform",
            `translate(${this.margins.left / 2 + h.range()[1] / 2}, ${o + 4})`
          ).style("text-anchor", "middle");
          break;
        case H.RIGHT:
          Z === Zo.LEFT ? z.attr("transform", "rotate(-90)").attr("y", a).attr("x", -(h.range()[0] / 2)).style("text-anchor", "middle") : z.attr("transform", "rotate(90)").attr("y", -a).attr("x", h.range()[0] / 2).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case H.TOP:
          ut = D.getSVGElementSize(z, {
            useBBox: !0
          }).height, z.attr(
            "transform",
            `translate(${this.margins.left / 2 + h.range()[1] / 2}, ${ut / 2})`
          ).style("text-anchor", "middle");
          break;
      }
    }
    if (v) {
      const z = Nl(
        U.tickValues(),
        b(r, "timeScale", "timeInterval")
      ), Z = V.showDayName, ut = p;
      t && (p = p.transition().call(
        (nt) => this.services.transitions.setupTransition({
          transition: nt,
          name: "axis-update",
          animate: t
        })
      )), p = p.call(U), ut.selectAll(".tick").data(U.tickValues(), h).order().select("text").style("font-weight", (nt, Ot) => Cm(nt, Ot, U.tickValues(), z, Z) ? "bold" : "normal");
    } else
      !t || !f ? p = p.call(U) : p = p.transition().call(
        (z) => this.services.transitions.setupTransition({
          transition: z,
          name: "axis-update",
          animate: t
        })
      ).call(U);
    if (m.call(U), n === H.BOTTOM || n === H.TOP) {
      let z = !1;
      const Z = b(g, "ticks", "rotation");
      if (Z === _s.ALWAYS)
        z = !0;
      else if (Z === _s.NEVER)
        z = !1;
      else if (!Z || Z === _s.AUTO)
        if (h.step)
          z = m.selectAll("g.tick text").nodes().some(
            (ut) => D.getSVGElementSize(ut, {
              useBBox: !0
            }).width >= h.step()
          );
        else {
          z = !1;
          const ut = m.append("text").text("A"), nt = D.getSVGElementSize(ut.node(), {
            useBBox: !0
          }).width;
          let Ot;
          m.selectAll("g.tick").each(function() {
            const W = R(this), Q = parseFloat(b(an(this), "tx"));
            Q !== null && Ot + W.text().length * nt * 0.8 >= Q && (z = !0), Ot = Q;
          }), ut.remove();
        }
      z ? (C || (U.ticks(
        this.getNumberOfFittingTicks(a, w, An.ticks.horizontalSpaceRatio)
      ), m.call(U), p.call(U)), l.selectAll("g.ticks g.tick text").attr("transform", "rotate(-45)").attr("text-anchor", n === H.TOP ? "start" : "end")) : l.selectAll("g.ticks g.tick text").attr("transform", null).attr("text-anchor", null);
    }
    if (_ ? l.attr("opacity", 0) : l.attr("opacity", 1), p.selectAll("g.tick").attr("aria-label", (z) => z), m.selectAll("g.tick").attr("aria-label", (z) => z), k !== Ie.NONE && S === X.LABELS && !T) {
      const z = this.services.cartesianScales.getScaleDomain(n);
      if (z.length > 0) {
        const Z = s.select(`g.axis.${n} g.ticks g.tick`).html();
        l.selectAll("g.ticks g.tick").html(Z);
        const ut = this;
        l.selectAll("g.tick text").data(z).text(function(nt) {
          return nt.length > N ? (ut.truncation[n] = !0, zi(nt, k, L)) : nt;
        }), this.getInvisibleAxisRef().selectAll("g.tick text").data(z).text(function(nt) {
          return nt.length > N ? zi(nt, k, L) : nt;
        }), l.selectAll("g.ticks").html(this.getInvisibleAxisRef().html()), l.selectAll("g.tick text").data(z);
      }
    }
    this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: n } = this.configs, r = D.appendOrSelect(t, `g.axis.${n}`), i = this.getOptions(), s = b(i, "axes", n), a = b(s, "scaleType"), o = b(s, "truncation", "threshold"), l = this;
    r.selectAll("g.tick text").on("mouseover", function(c, u) {
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEOVER, {
        event: c,
        element: R(this),
        datum: u
      }), a === X.LABELS && u.length > o && l.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: c,
        hoveredElement: R(this),
        content: u
      });
    }).on("mousemove", function(c, u) {
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEMOVE, {
        event: c,
        element: R(this),
        datum: u
      }), a === X.LABELS && u.length > o && l.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c, u) {
      l.services.events.dispatchEvent(O.Axis.LABEL_CLICK, {
        event: c,
        element: R(this),
        datum: u
      });
    }).on("mouseout", function(c, u) {
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEOUT, {
        event: c,
        element: R(this),
        datum: u
      }), a === X.LABELS && l.services.events.dispatchEvent(O.Tooltip.HIDE);
    });
  }
  getInvisibleAxisRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} g.ticks.invisible`);
  }
  getTitleRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} text.axis-title`);
  }
  getNumberOfFittingTicks(t, n, r) {
    const i = Math.floor(t / (n * r));
    return av(i, 2, An.ticks.number);
  }
  destroy() {
    const t = this.getComponentContainer(), { position: n } = this.configs;
    D.appendOrSelect(t, `g.axis.${n}`).selectAll("g.tick text").on("mouseover", null).on("mousemove", null).on("mouseout", null);
  }
}
class BI extends xv {
  constructor(t, n, r) {
    super(t, n, r);
  }
  render(t = !0) {
    super.render(t), super.destroy();
    const n = this.configs.position, r = this.getComponentContainer(), i = D.appendOrSelect(r, `g.axis.${n}`), s = this;
    i.selectAll("g.tick").each(function(a, o) {
      const l = R(this);
      l.classed("tick-hover", !0).attr("tabindex", o === 0 ? 0 : -1);
      const c = l.select("text"), { width: u, height: h } = D.getSVGElementSize(c, {
        useBBox: !0
      }), d = D.appendOrSelect(l, "rect.axis-holder");
      let f = 0, p = 0;
      switch (n) {
        case H.LEFT:
          f = -u + Number(c.attr("x")), p = -(h / 2);
          break;
        case H.RIGHT:
          f = Math.abs(Number(c.attr("x"))), p = -(h / 2);
          break;
        case H.TOP:
          f = -(u / 2), p = -h + Number(c.attr("y")) / 2, s.truncation[n] && (f = 0, d.attr("transform", "rotate(-45)"));
          break;
        case H.BOTTOM:
          f = -(u / 2), p = h / 2 - 2, s.truncation[n] && (f = -u, d.attr("transform", "rotate(-45)"));
          break;
      }
      d.attr("x", f - An.hover.rectanglePadding).attr("y", p).attr("width", u + An.hover.rectanglePadding * 2).attr("height", h).lower();
    }), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: n } = this.configs, r = D.appendOrSelect(t, `g.axis.${n}`), i = this.getOptions(), s = b(i, "axes", n), a = b(s, "scaleType"), o = b(s, "truncation", "threshold"), l = this;
    r.selectAll("g.tick.tick-hover").on("mouseover", function(c) {
      const u = R(this).select("text"), h = u.datum();
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEOVER, {
        event: c,
        element: u,
        datum: h
      }), a === X.LABELS && h.length > o && l.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: c,
        element: u,
        datum: h
      });
    }).on("mousemove", function(c) {
      const u = R(this).select("text"), h = u.datum();
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEMOVE, {
        event: c,
        element: u,
        datum: h
      }), l.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c) {
      l.services.events.dispatchEvent(O.Axis.LABEL_CLICK, {
        event: c,
        element: R(this).select("text"),
        datum: R(this).select("text").datum()
      });
    }).on("mouseout", function(c) {
      l.services.events.dispatchEvent(O.Axis.LABEL_MOUSEOUT, {
        event: c,
        element: R(this).select("text"),
        datum: R(this).select("text").datum()
      }), a === X.LABELS && l.services.events.dispatchEvent(O.Tooltip.HIDE);
    }).on("focus", function(c) {
      const u = { clientX: 0, clientY: 0 };
      if (c.target) {
        c.target.focus();
        const h = c.target.getBoundingClientRect();
        u.clientX = h.x, u.clientY = h.y;
      }
      l.services.events.dispatchEvent(O.Axis.LABEL_FOCUS, {
        event: { ...c, ...u },
        element: R(this),
        datum: R(this).select("text").datum()
      });
    }).on("blur", function(c) {
      l.services.events.dispatchEvent(O.Axis.LABEL_BLUR, {
        event: c,
        element: R(this),
        datum: R(this).select("text").datum()
      });
    }).on("keydown", function(c) {
      c.key && c.key === "Escape" && (l.services.events.dispatchEvent(O.Tooltip.HIDE), l.services.events.dispatchEvent(O.Axis.LABEL_BLUR, {
        event: c,
        element: R(this),
        datum: R(this).select("text").datum()
      })), n === H.LEFT || n === H.RIGHT ? c.key && c.key === "ArrowUp" ? l.goNext(this, c) : c.key && c.key === "ArrowDown" && l.goPrevious(this, c) : c.key && c.key === "ArrowLeft" ? l.goPrevious(this, c) : c.key && c.key === "ArrowRight" && l.goNext(this, c);
    });
  }
  // Focus on the next HTML element sibling
  goNext(t, n) {
    t.nextElementSibling && t.nextElementSibling.tagName !== "path" && t.nextElementSibling.dispatchEvent(new Event("focus")), n.preventDefault();
  }
  // Focus on the previous HTML element sibling
  goPrevious(t, n) {
    t.previousElementSibling && t.previousElementSibling.tagName !== "path" && t.previousElementSibling.dispatchEvent(new Event("focus")), n.preventDefault();
  }
  destroy() {
    const t = this.getComponentContainer(), { position: n } = this.configs;
    D.appendOrSelect(t, `g.axis.${n}`).selectAll("g.tick.tick-hover").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("focus", null).on("blur", null);
  }
}
class ge extends dt {
  constructor() {
    super(...arguments), this.type = "2D-axes", this.renderType = K.SVG, this.children = {}, this.thresholds = [], this.margins = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  render(t = !1) {
    const n = {}, r = Object.keys(H), i = b(this.getOptions(), "axes");
    r.forEach((a) => {
      i[H[a]] && (n[H[a]] = !0);
    }), this.configs.axes = n, r.forEach((a) => {
      const o = H[a];
      if (this.configs.axes[o] && !this.children[o]) {
        const l = {
          position: o,
          axes: this.configs.axes,
          margins: this.margins
        }, c = this.model.axisFlavor === Aa.DEFAULT ? new xv(this.model, this.services, l) : new BI(this.model, this.services, l);
        c.setModel(this.model), c.setServices(this.services), c.setParent(this.parent), this.children[o] = c;
      }
    }), Object.keys(this.children).forEach((a) => {
      this.children[a].render(t);
    });
    const s = {};
    Object.keys(this.children).forEach((a) => {
      const o = this.children[a], l = o.configs.position, c = o.getInvisibleAxisRef(), { width: u, height: h } = D.getSVGElementSize(c, { useBBox: !0 });
      let d;
      switch (o.getTitleRef().empty() ? d = 0 : (d = D.getSVGElementSize(o.getTitleRef(), {
        useBBox: !0
      }).height, (l === H.LEFT || l === H.RIGHT) && (d += 5)), l) {
        case H.TOP:
          s.top = h + d;
          break;
        case H.BOTTOM:
          s.bottom = h + d;
          break;
        case H.LEFT:
          s.left = u + d;
          break;
        case H.RIGHT:
          s.right = u + d;
          break;
      }
    }), this.services.events.dispatchEvent(O.Axis.RENDER_COMPLETE), Object.keys(s).some((a) => this.margins[a] !== s[a]) && (this.margins = Object.assign(this.margins, s), this.model.set({ axesMargins: this.margins }, { skipUpdate: !0 }), this.services.events.dispatchEvent(O.ZoomBar.UPDATE), Object.keys(this.children).forEach((a) => {
      const o = this.children[a];
      o.margins = this.margins;
    }), this.render(!0));
  }
}
class ue extends dt {
  constructor() {
    super(...arguments), this.type = "skeleton";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = b(this.getOptions(), "data", "loading");
    n ? this.renderSkeleton(n) : this.removeSkeleton();
  }
  renderSkeleton(t) {
    if (this.configs.skeleton === qt.GRID)
      this.renderGridSkeleton(t);
    else if (this.configs.skeleton === qt.VERT_OR_HORIZ)
      this.renderVertOrHorizSkeleton(t);
    else if (this.configs.skeleton === qt.PIE)
      this.renderPieSkeleton(t);
    else if (this.configs.skeleton === qt.DONUT)
      this.renderDonutSkeleton(t);
    else
      throw new Error(`"${this.configs.skeleton}" is not a valid Skeleton type.`);
  }
  renderGridSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawXGrid(t), this.drawYGrid(t), t && this.setShimmerEffect("shimmer-lines");
  }
  renderVertOrHorizSkeleton(t) {
    const n = this.services.cartesianScales.getOrientation();
    this.setScales(), this.drawBackdrop(t), n === Kt.VERTICAL && this.drawYGrid(t), n === Kt.HORIZONTAL && this.drawXGrid(t), this.setShimmerEffect("shimmer-lines");
  }
  renderPieSkeleton(t) {
    const n = this.computeOuterRadius(), r = 0;
    this.drawRing(n, r, t), t && this.setShimmerEffect("shimmer-areas");
  }
  renderDonutSkeleton(t) {
    const n = this.computeOuterRadius(), r = this.computeInnerRadius();
    this.drawRing(n, r, t), t && this.setShimmerEffect("shimmer-areas");
  }
  setScales() {
    const t = this.services.cartesianScales.getMainXScale().range(), n = this.services.cartesianScales.getMainYScale().range();
    this.xScale = Be().domain([0, 1]).range(t), this.yScale = Be().domain([0, 1]).range(n);
  }
  drawBackdrop(t) {
    const n = this.parent, { width: r, height: i } = D.getSVGElementSize(n, {
      useAttrs: !0
    });
    this.backdrop = D.appendOrSelect(n, "svg.chart-skeleton.DAII").attr("width", r).attr("height", i);
    const s = D.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
    s.attr("width", "100%").attr("height", "100%");
    const [a] = this.xScale.range(), [, o] = this.yScale.range();
    this.backdrop.merge(s).attr("x", a).attr("y", o), s.classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawXGrid(t) {
    const n = +this.backdrop.attr("width"), r = b(this.getOptions(), "grid", "x", "numberOfTicks"), i = this.xScale.ticks(r).map((o) => o * n), s = D.appendOrSelect(this.backdrop, "g.x.skeleton"), a = s.selectAll("line").data(i);
    a.enter().append("line").merge(a).attr("x1", (o) => o).attr("x2", (o) => o).attr("y1", 0).attr("y2", "100%"), s.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawYGrid(t) {
    const n = +this.backdrop.attr("height"), r = this.backdrop.attr("width"), i = b(this.getOptions(), "grid", "y", "numberOfTicks"), s = this.xScale.ticks(i).map((l) => l * n), a = D.appendOrSelect(this.backdrop, "g.y.skeleton"), o = a.selectAll("line").data(s);
    o.enter().append("line").merge(o).attr("x1", 0).attr("x2", r).attr("y1", (l) => l).attr("y2", (l) => l), a.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawRing(t, n, r = !0) {
    const i = this.parent, { width: s, height: a } = D.getSVGElementSize(i, {
      useAttrs: !0
    }), o = D.appendOrSelect(i, "svg.chart-skeleton").attr("width", s).attr("height", a), l = n === 0 ? "pie" : "donut", c = b(this.getOptions(), l, "alignment");
    D.appendOrSelect(o, "rect.chart-skeleton-area-container").attr("width", s).attr("height", a).attr("fill", "none");
    const u = Bi().innerRadius(n).outerRadius(t).startAngle(0).endAngle(Math.PI * 2), h = t + Math.abs($t.radiusOffset), d = t + (Math.min(s, a) - t * 2) / 2, f = D.appendOrSelect(o, "path").attr("class", "skeleton-area-shape").attr("transform", `translate(${h}, ${d})`).attr("d", u).classed("shimmer-effect-areas", r).classed("empty-state-areas", !r).style(
      "fill",
      r ? `url(#${this.services.domUtils.generateElementIDString("shimmer-areas")})` : null
    );
    let p = t + $t.xOffset;
    c === Yt.CENTER ? p = s / 2 : c === Yt.RIGHT && (p = s - t - $t.xOffset);
    const m = t + $t.yOffset;
    f.attr("transform", `translate(${p}, ${m})`);
  }
  // same logic in pie
  computeOuterRadius() {
    const { width: t, height: n } = D.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return Math.min(t, n) / 2 + $t.radiusOffset;
  }
  // same logic in donut
  computeInnerRadius() {
    return this.computeOuterRadius() * (3 / 4);
  }
  setShimmerEffect(t) {
    const n = "stop-bg-shimmer", r = "stop-shimmer", i = this.parent.select(".chart-skeleton"), { width: s } = D.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), a = 0, o = s, l = D.appendOrSelect(i, "defs").lower(), c = D.appendOrSelect(l, "linearGradient").attr("id", this.services.domUtils.generateElementIDString(t)).attr("class", t).attr("x1", a - 3 * 0.2 * s).attr("x2", o).attr("y1", 0).attr("y2", 0).attr("gradientUnits", "userSpaceOnUse").attr("gradientTransform", "translate(0, 0)"), u = `
			<stop class="${n}" offset="${a}"></stop>
			<stop class="${r}" offset="${a + 0.2}"></stop>
			<stop class="${n}" offset="${a + 2 * 0.2}"></stop>
		`;
    c.html(u), h();
    function h() {
      c.attr("gradientTransform", `translate(${a - 3 * 0.2 * s}, 0)`).transition().duration(2e3).delay(1e3).ease(eb).attr("gradientTransform", `translate(${o + 3 * 0.2 * s}, 0)`).on("end", h);
    }
  }
  removeSkeleton() {
    this.parent.select(".chart-skeleton").remove();
  }
}
class VI extends dt {
  constructor() {
    super(...arguments), this.type = "boxplot", this.renderType = K.SVG;
  }
  render(t) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.model.getDataGroupNames(), a = this.services.cartesianScales.getMainXScale(), o = this.services.cartesianScales.getMainYScale(), [l, c] = a.range(), [u, h] = o.range(), d = c - l, f = u - h;
    if (d === 0)
      return;
    const { cartesianScales: p } = this.services, m = p.getOrientation(), g = m === Kt.VERTICAL, [v, y] = dn(
      (C) => this.services.cartesianScales.getDomainValue(C),
      (C) => this.services.cartesianScales.getRangeValue(C),
      m
    ), x = Math.floor((g ? d : f) / s.length), S = Math.min(x / 2, 16), _ = this.model.getBoxplotData(), E = n.selectAll(".box-group").data(_);
    E.exit().remove();
    const T = E.enter().append("g").attr("class", "box-group"), k = E.merge(T);
    T.append("path").merge(E.select("path.vertical-line.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [et.STROKE],
        originalClassName: "vertical-line start"
      })
    ).attr("stroke-width", Oe.strokeWidth.default).attr("fill", "none").transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-verticalstartline",
        animate: t
      })
    ).attr("d", (C) => {
      const V = p.getDomainValue(C[i]), M = V, A = p.getRangeValue(C.whiskers.min), w = p.getRangeValue(C.quartiles.q_25);
      return ce({ x0: V, x1: M, y0: A, y1: w }, m);
    }), T.append("path").merge(E.select("path.vertical-line.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [et.STROKE],
        originalClassName: "vertical-line end"
      })
    ).attr("stroke-width", Oe.strokeWidth.default).attr("fill", "none").transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-verticalendline",
        animate: t
      })
    ).attr("d", (C) => {
      const V = p.getDomainValue(C[i]), M = V, A = p.getRangeValue(C.whiskers.max), w = p.getRangeValue(C.quartiles.q_75);
      return ce({ x0: V, x1: M, y0: A, y1: w }, m);
    }), T.append("path").merge(E.select("path.box")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [et.FILL, et.STROKE],
        originalClassName: "box"
      })
    ).attr("fill-opacity", Oe.box.opacity.default).attr("stroke-width", Oe.strokeWidth.default).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "box").attr("aria-label", (C) => C[i]).transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-quartiles",
        animate: t
      })
    ).attr("d", (C) => {
      const V = p.getDomainValue(C[i]) - S / 2, M = V + S, A = p.getRangeValue(
        Math[g ? "max" : "min"](C.quartiles.q_75, C.quartiles.q_25)
      ), w = A + Math.abs(
        p.getRangeValue(C.quartiles.q_75) - p.getRangeValue(C.quartiles.q_25)
      );
      return ce({ x0: V, x1: M, y0: A, y1: w }, m);
    }), T.append("path").merge(E.select("path.highlight-area")).attr("class", "highlight-area").attr("opacity", 0).attr("d", (C) => {
      const V = p.getDomainValue(C[i]) - S / 2, M = V + S, A = p.getRangeValue(C.whiskers.min), w = p.getRangeValue(C.whiskers.max);
      return ce({ x0: V, x1: M, y0: A, y1: w }, m);
    }), T.append("path").merge(E.select("path.whisker.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [et.STROKE],
        originalClassName: "whisker start"
      })
    ).attr("stroke-width", Oe.strokeWidth.thicker).attr("fill", "none").transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-startingwhisker",
        animate: t
      })
    ).attr("d", (C) => {
      const V = p.getDomainValue(C[i]) - S / 4, M = V + S / 2, A = p.getRangeValue(C.whiskers.min), w = p.getRangeValue(C.whiskers.min);
      return ce({ x0: V, x1: M, y0: A, y1: w }, m);
    }), T.append("path").merge(E.select("path.median")).attr("fill", "none").attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [et.STROKE],
        originalClassName: "median"
      })
    ).attr("stroke-width", 2).transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-median",
        animate: t
      })
    ).attr("d", (C) => {
      const V = p.getDomainValue(C[i]) - S / 2, M = V + S, A = p.getRangeValue(C.quartiles.q_50);
      return ce({ x0: V, x1: M, y0: A, y1: A }, m);
    }), T.append("path").merge(E.select("path.whisker.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [et.STROKE],
        originalClassName: "whisker end"
      })
    ).attr("stroke-width", Oe.strokeWidth.thicker).attr("fill", "none").transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-endingwhisker",
        animate: t
      })
    ).attr("d", (C) => {
      const V = p.getDomainValue(C[i]) - S / 4, M = V + S / 2, A = p.getRangeValue(C.whiskers.max), w = p.getRangeValue(C.whiskers.max);
      return ce({ x0: V, x1: M, y0: A, y1: w }, m);
    });
    const N = k.selectAll("circle.outlier").data(
      (C) => C.outliers.map((V) => ({
        min: C.whiskers.min,
        max: C.whiskers.max,
        [i]: C[i],
        value: V
      }))
    );
    N.exit().remove();
    const L = N.enter().append("circle");
    N.merge(L).attr("r", Oe.circle.radius).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [et.FILL, et.STROKE],
        originalClassName: "outlier"
      })
    ).attr("fill-opacity", Oe.circle.opacity.default).attr("cx", v).transition().call(
      (C) => this.services.transitions.setupTransition({
        transition: C,
        name: "boxplot-update-circles",
        animate: t
      })
    ).attr("cy", y), this.addBoxEventListeners(), this.addCircleEventListeners();
  }
  addBoxEventListeners() {
    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data;
    this.parent.selectAll("path.highlight-area").on("mouseover", function(i, s) {
      const a = R(this);
      R(this.parentNode).select("path.box").classed("hovered", !0).attr("fill-opacity", Oe.box.opacity.hovered), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: i,
        hoveredElement: a,
        items: [
          {
            label: n.tooltip.groupLabel,
            value: s[r],
            class: t.model.getColorClassName({
              classNameTypes: [et.TOOLTIP]
            })
          },
          {
            label: "Minimum",
            value: s.whiskers.min
          },
          {
            label: "Q1",
            value: s.quartiles.q_25
          },
          {
            label: "Median",
            value: s.quartiles.q_50
          },
          {
            label: "Q3",
            value: s.quartiles.q_75
          },
          {
            label: "Maximum",
            value: s.whiskers.max
          },
          {
            label: "IQR",
            value: s.quartiles.q_75 - s.quartiles.q_25
          }
        ]
      }), t.services.events.dispatchEvent(O.Boxplot.BOX_MOUSEOVER, {
        event: i,
        element: a,
        datum: s
      });
    }).on("mousemove", function(i, s) {
      const a = R(this);
      t.services.events.dispatchEvent(O.Boxplot.BOX_MOUSEMOVE, {
        event: i,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function(i, s) {
      t.services.events.dispatchEvent(O.Boxplot.BOX_CLICK, {
        event: i,
        element: R(this),
        datum: s
      });
    }).on("mouseout", function(i, s) {
      const a = R(this);
      R(this.parentNode).select("path.box").classed("hovered", !1).attr("fill-opacity", Oe.box.opacity.default), t.services.events.dispatchEvent(O.Boxplot.BOX_MOUSEOUT, {
        event: i,
        element: a,
        datum: s
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  addCircleEventListeners() {
    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("circle").on("mouseover", function(s, a) {
      const o = R(this);
      o.classed("hovered", !0).attr("fill-opacity", Oe.circle.opacity.hovered).classed("unfilled", !1), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: s,
        hoveredElement: o,
        items: [
          {
            label: n.tooltip.groupLabel,
            value: a[r],
            class: t.model.getColorClassName({
              classNameTypes: [et.TOOLTIP]
            })
          },
          {
            label: "Outlier",
            value: a[i]
          }
        ]
      }), t.services.events.dispatchEvent(O.Boxplot.OUTLIER_MOUSEOVER, {
        event: s,
        element: o,
        datum: a
      });
    }).on("mousemove", function(s, a) {
      const o = R(this);
      t.services.events.dispatchEvent(O.Boxplot.OUTLIER_MOUSEMOVE, {
        event: s,
        element: o,
        datum: a
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      t.services.events.dispatchEvent(O.Boxplot.OUTLIER_CLICK, {
        event: s,
        element: R(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const o = R(this);
      o.classed("hovered", !1).attr("fill-opacity", Oe.circle.opacity.default), t.services.events.dispatchEvent(O.Boxplot.OUTLIER_MOUSEOUT, {
        event: s,
        element: o,
        datum: a
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class Yr extends dt {
  constructor() {
    super(...arguments), this.type = "zero-line", this.renderType = K.SVG;
  }
  render(t) {
    const n = this.services.cartesianScales.getRangeAxisPosition({
      groups: this.configs.groups
    }), r = this.services.cartesianScales.getScaleByPosition(n), [i, s] = r.domain(), a = i > 0 && s < 0 || i < 0 && s > 0, o = this.getComponentContainer();
    if (!a) {
      o.selectAll("line.domain").remove();
      return;
    }
    const [l, c] = this.services.cartesianScales.getDomainScale().range();
    let u = +r(0) + 0.5;
    u || (u = r.range()[0]);
    const h = Tm(
      {
        x0: l,
        x1: c,
        y0: u,
        y1: u
      },
      this.services.cartesianScales.getOrientation()
    );
    D.appendOrSelect(o, "line.domain").transition().call(
      (d) => this.services.transitions.setupTransition({
        transition: d,
        name: "zero-line-update",
        animate: t
      })
    ).attr("y1", h.y0).attr("y2", h.y1).attr("x1", h.x0).attr("x2", h.x1);
  }
}
class HI extends Ze {
  constructor() {
    super(...arguments), this.type = "bubble", this.renderType = K.SVG;
  }
  getRadiusScale(t) {
    const n = this.getOptions(), { radiusMapsTo: r } = n.bubble, i = t.data(), s = i.map((c) => c[r]).filter((c) => c), a = D.getHTMLElementSize(this.services.domUtils.getMainContainer()), o = s.length > 0, l = o ? Ne(s) : [1, 1];
    return Be().domain(l).range(o ? n.bubble.radiusRange(a, i) : [4, 4]);
  }
  styleCircles(t, n) {
    const r = this.getOptions(), { radiusMapsTo: i } = r.bubble, s = this.getRadiusScale(t), { groupMapsTo: a } = r.data, { cartesianScales: o } = this.services, l = (d) => o.getDomainValue(d), c = (d) => o.getRangeValue(d), [u, h] = dn(
      l,
      c,
      o.getOrientation()
    );
    t.raise().classed("dot", !0).attr("role", at.GRAPHICS_SYMBOL).attr("aria-label", (d) => {
      const f = o.getRangeIdentifier(d);
      return d[f];
    }).transition().call(
      (d) => this.services.transitions.setupTransition({
        transition: d,
        name: "bubble-update-enter",
        animate: n
      })
    ).attr("cx", u).attr("cy", h).attr("r", (d) => s(d[i] || 1)).attr(
      "class",
      (d) => this.model.getColorClassName({
        classNameTypes: [et.FILL, et.STROKE],
        dataGroupName: d[a],
        originalClassName: "dot"
      })
    ).style("fill", (d) => {
      const f = this.services.cartesianScales.getDomainIdentifier(d);
      return this.model.getFillColor(d[a], d[f], d);
    }).style("stroke", (d) => {
      const f = this.services.cartesianScales.getDomainIdentifier(d);
      return this.model.getStrokeColor(d[a], d[f], d);
    }).attr("fill-opacity", r.bubble.fillOpacity).attr("opacity", 1);
  }
  getTooltipAdditionalItems(t) {
    const n = b(this.getOptions(), "bubble");
    return [
      {
        label: b(n, "radiusLabel"),
        value: t[b(n, "radiusMapsTo")]
      }
    ];
  }
}
class FI extends dt {
  constructor() {
    super(...arguments), this.type = "bullet", this.renderType = K.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getComponentContainer({ withinChartClip: !0 }), s = this.model.getDisplayData(this.configs.groups), a = this.services.cartesianScales.getRangeScale(), o = this.services.cartesianScales.getRangeIdentifier(), [l, c] = a.range(), [, u] = a.domain(), h = () => {
      const m = [];
      s.forEach((v) => {
        v.ranges ? v.ranges.forEach((y, x) => {
          y != null && y < u && m.push({
            datum: v,
            value: y,
            order: x + 1
          });
        }) : m.push({
          datum: v,
          order: 1
        });
      });
      const g = D.appendOrSelect(i, "g.range-boxes").selectAll("path.range-box").data(m, (v) => `${v[r]}-${v.order}`);
      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).attr("class", (v) => `range-box order-${v.order}`).transition().call(
        (v) => this.services.transitions.setupTransition({
          transition: v,
          name: "bullet-range-box-update-enter",
          animate: t
        })
      ).attr("d", (v) => {
        let y, x, S, _;
        return v.order === 1 ? (y = this.services.cartesianScales.getDomainValue(v.datum) - 16 / 2, x = y + 16, S = c - 2, _ = l + 1) : (y = this.services.cartesianScales.getDomainValue(v.datum) - 16 / 2, x = y + 16, S = this.services.cartesianScales.getRangeValue(v.value), _ = c), ce(
          { x0: y, x1: x, y0: S, y1: _ },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, d = () => {
      const m = D.appendOrSelect(i, "g.bars").selectAll("path.bar").data(s, (g) => g[r]);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).classed("bar", !0).transition().call(
        (g) => this.services.transitions.setupTransition({
          transition: g,
          name: "bullet-bar-update-enter",
          animate: t
        })
      ).attr(
        "class",
        (g) => this.model.getColorClassName({
          classNameTypes: [et.FILL],
          dataGroupName: g[r],
          originalClassName: "bar"
        })
      ).style("fill", (g) => this.model.getFillColor(g[r])).attr("d", (g) => {
        const v = this.services.cartesianScales.getDomainValue(g) - 4, y = v + 8, x = this.services.cartesianScales.getRangeValue(0) + 1, S = this.services.cartesianScales.getRangeValue(g);
        return ce(
          { x0: v, x1: y, y0: x, y1: S },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (g) => g.value);
    }, f = () => {
      const m = D.appendOrSelect(i, "g.markers").selectAll("path.marker").data(
        s.filter((g) => b(g, "marker") !== null),
        (g) => g[r]
      );
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).classed("marker", !0).transition().call(
        (g) => this.services.transitions.setupTransition({
          transition: g,
          name: "bullet-marker-update-enter",
          animate: t
        })
      ).attr("d", (g) => {
        const v = this.services.cartesianScales.getDomainValue(g) - 12, y = v + 24, x = this.services.cartesianScales.getRangeValue(g.marker);
        return ce(
          { x0: v, x1: y, y0: x, y1: x },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, p = () => {
      let m = [];
      s.filter((v) => b(v, "marker") !== null).forEach((v) => {
        const y = v.marker, x = v[o];
        m = m.concat([
          { datum: v, value: y * 0.25, barValue: x },
          { datum: v, value: y * 0.5, barValue: x },
          { datum: v, value: y * 0.75, barValue: x }
        ]);
      });
      const g = D.appendOrSelect(i, "g.quartiles").selectAll("path.quartile").data(m, (v) => v[r]);
      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).attr("class", (v) => `quartile ${v.value <= v.barValue ? "over-bar" : ""}`).transition().call(
        (v) => this.services.transitions.setupTransition({
          transition: v,
          name: "bullet-quartile-update-enter",
          animate: t
        })
      ).attr("d", ({ datum: v, value: y }) => {
        let x = 4;
        v.ranges && v.ranges.indexOf(y) !== -1 && (x = 8);
        const S = this.services.cartesianScales.getDomainValue(v) - x / 2, _ = S + x, E = this.services.cartesianScales.getRangeValue(y);
        return ce(
          { x0: S, x1: _, y0: E, y1: E },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    };
    h(), d(), f(), p(), this.addEventListeners();
  }
  addEventListeners() {
    const t = this, n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("path.bar").on("mouseover", function(s, a) {
      const o = R(this);
      o.classed("hovered", !0), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOVER, {
        event: s,
        element: o,
        datum: a
      });
      const l = b(n, "bullet", "performanceAreaTitles"), c = t.model.getMatchingRangeIndexForDatapoint(a);
      t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: s,
        hoveredElement: o,
        items: [
          {
            label: n.tooltip.groupLabel || "Group",
            value: a[r],
            class: t.model.getColorClassName({
              classNameTypes: [et.TOOLTIP],
              dataGroupName: a[r]
            })
          },
          {
            label: "Value",
            value: a[i]
          },
          {
            label: "Target",
            value: a.marker
          },
          {
            label: "Percentage",
            value: `${Math.floor(a[i] / a.marker * 100)}%`
          },
          {
            label: "Performance",
            value: l[c]
          }
        ]
      });
    }).on("mousemove", function(s, a) {
      t.services.events.dispatchEvent(O.Bar.BAR_MOUSEMOVE, {
        event: s,
        element: R(this),
        datum: a
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      t.services.events.dispatchEvent(O.Bar.BAR_CLICK, {
        event: s,
        element: R(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const o = R(this);
      o.classed("hovered", !1), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOUT, {
        event: s,
        element: o,
        datum: a
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
function GI(e) {
  return e;
}
function zI(e) {
  if (e == null)
    return GI;
  var t, n, r = e.scale[0], i = e.scale[1], s = e.translate[0], a = e.translate[1];
  return function(o, l) {
    l || (t = n = 0);
    var c = 2, u = o.length, h = new Array(u);
    for (h[0] = (t += o[0]) * r + s, h[1] = (n += o[1]) * i + a; c < u; )
      h[c] = o[c], ++c;
    return h;
  };
}
function jI(e, t) {
  for (var n, r = e.length, i = r - t; i < --r; )
    n = e[i], e[i++] = e[r], e[r] = n;
}
function WI(e, t) {
  return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(n) {
    return hf(e, n);
  }) } : hf(e, t);
}
function hf(e, t) {
  var n = t.id, r = t.bbox, i = t.properties == null ? {} : t.properties, s = au(e, t);
  return n == null && r == null ? { type: "Feature", properties: i, geometry: s } : r == null ? { type: "Feature", id: n, properties: i, geometry: s } : { type: "Feature", id: n, bbox: r, properties: i, geometry: s };
}
function au(e, t) {
  var n = zI(e.transform), r = e.arcs;
  function i(u, h) {
    h.length && h.pop();
    for (var d = r[u < 0 ? ~u : u], f = 0, p = d.length; f < p; ++f)
      h.push(n(d[f], f));
    u < 0 && jI(h, p);
  }
  function s(u) {
    return n(u);
  }
  function a(u) {
    for (var h = [], d = 0, f = u.length; d < f; ++d)
      i(u[d], h);
    return h.length < 2 && h.push(h[0]), h;
  }
  function o(u) {
    for (var h = a(u); h.length < 4; )
      h.push(h[0]);
    return h;
  }
  function l(u) {
    return u.map(o);
  }
  function c(u) {
    var h = u.type, d;
    switch (h) {
      case "GeometryCollection":
        return { type: h, geometries: u.geometries.map(c) };
      case "Point":
        d = s(u.coordinates);
        break;
      case "MultiPoint":
        d = u.coordinates.map(s);
        break;
      case "LineString":
        d = a(u.arcs);
        break;
      case "MultiLineString":
        d = u.arcs.map(a);
        break;
      case "Polygon":
        d = l(u.arcs);
        break;
      case "MultiPolygon":
        d = u.arcs.map(l);
        break;
      default:
        return null;
    }
    return { type: h, coordinates: d };
  }
  return c(t);
}
function qI(e, t) {
  var n = {}, r = {}, i = {}, s = [], a = -1;
  t.forEach(function(c, u) {
    var h = e.arcs[c < 0 ? ~c : c], d;
    h.length < 3 && !h[1][0] && !h[1][1] && (d = t[++a], t[a] = c, t[u] = d);
  }), t.forEach(function(c) {
    var u = o(c), h = u[0], d = u[1], f, p;
    if (f = i[h])
      if (delete i[f.end], f.push(c), f.end = d, p = r[d]) {
        delete r[p.start];
        var m = p === f ? f : f.concat(p);
        r[m.start = f.start] = i[m.end = p.end] = m;
      } else
        r[f.start] = i[f.end] = f;
    else if (f = r[d])
      if (delete r[f.start], f.unshift(c), f.start = h, p = i[h]) {
        delete i[p.end];
        var g = p === f ? f : p.concat(f);
        r[g.start = p.start] = i[g.end = f.end] = g;
      } else
        r[f.start] = i[f.end] = f;
    else
      f = [c], r[f.start = h] = i[f.end = d] = f;
  });
  function o(c) {
    var u = e.arcs[c < 0 ? ~c : c], h = u[0], d;
    return e.transform ? (d = [0, 0], u.forEach(function(f) {
      d[0] += f[0], d[1] += f[1];
    })) : d = u[u.length - 1], c < 0 ? [d, h] : [h, d];
  }
  function l(c, u) {
    for (var h in c) {
      var d = c[h];
      delete u[d.start], delete d.start, delete d.end, d.forEach(function(f) {
        n[f < 0 ? ~f : f] = 1;
      }), s.push(d);
    }
  }
  return l(i, r), l(r, i), t.forEach(function(c) {
    n[c < 0 ? ~c : c] || s.push([c]);
  }), s;
}
function YI(e) {
  for (var t = -1, n = e.length, r, i = e[n - 1], s = 0; ++t < n; )
    r = i, i = e[t], s += r[0] * i[1] - r[1] * i[0];
  return Math.abs(s);
}
function XI(e) {
  return au(e, ZI.apply(this, arguments));
}
function ZI(e, t) {
  var n = {}, r = [], i = [];
  t.forEach(s);
  function s(l) {
    switch (l.type) {
      case "GeometryCollection":
        l.geometries.forEach(s);
        break;
      case "Polygon":
        a(l.arcs);
        break;
      case "MultiPolygon":
        l.arcs.forEach(a);
        break;
    }
  }
  function a(l) {
    l.forEach(function(c) {
      c.forEach(function(u) {
        (n[u = u < 0 ? ~u : u] || (n[u] = [])).push(l);
      });
    }), r.push(l);
  }
  function o(l) {
    return YI(au(e, { type: "Polygon", arcs: [l] }).coordinates[0]);
  }
  return r.forEach(function(l) {
    if (!l._) {
      var c = [], u = [l];
      for (l._ = 1, i.push(c); l = u.pop(); )
        c.push(l), l.forEach(function(h) {
          h.forEach(function(d) {
            n[d < 0 ? ~d : d].forEach(function(f) {
              f._ || (f._ = 1, u.push(f));
            });
          });
        });
    }
  }), r.forEach(function(l) {
    delete l._;
  }), {
    type: "MultiPolygon",
    arcs: i.map(function(l) {
      var c = [], u;
      if (l.forEach(function(m) {
        m.forEach(function(g) {
          g.forEach(function(v) {
            n[v < 0 ? ~v : v].length < 2 && c.push(v);
          });
        });
      }), c = qI(e, c), (u = c.length) > 1)
        for (var h = 1, d = o(c[0]), f, p; h < u; ++h)
          (f = o(c[h])) > d && (p = c[0], c[0] = c[h], c[h] = p, d = f);
      return c;
    }).filter(function(l) {
      return l.length > 0;
    })
  };
}
class KI extends kn {
  constructor() {
    super(...arguments), this.type = "ruler-binned", this.renderType = K.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  showRuler(t, [n, r]) {
    const i = this.parent, s = this.model.getOptions(), { cartesianScales: a } = this.services, o = a.getOrientation(), l = a.getRangeScale(), [c, u] = l.range(), h = a.getDomainScale(), d = h.invert(
      o === Kt.VERTICAL ? n : r
    ), f = D.appendOrSelect(i, "g.ruler").attr("aria-label", "ruler"), p = D.appendOrSelect(f, "line.ruler-line"), m = i.selectAll("[role=graphics-symbol]").filter((g) => {
      if (parseFloat(At(g, "data.x0")) <= d && parseFloat(At(g, "data.x1")) >= d)
        return !0;
    });
    if (m.size() > 0) {
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !ov(this.elementsToHighlight, m) && this.hideRuler(), m.dispatch("mouseover"), this.elementsToHighlight = m;
      const g = R(m.nodes()[0]).datum(), v = parseFloat(At(g, "data.x0")), y = parseFloat(At(g, "data.x1")), x = this.model.getActiveDataGroupNames(), S = x.reverse().map((_) => ({
        label: _,
        value: At(g, `data.${_}`),
        class: this.model.getColorClassName({
          classNameTypes: [et.TOOLTIP],
          dataGroupName: _
        })
      })).filter((_) => _.value !== 0);
      if (S.length > 0) {
        this.services.events.dispatchEvent(O.Tooltip.SHOW, {
          mousePosition: [n, r],
          hoveredElement: p,
          items: [
            {
              label: At(s, "bins.rangeLabel") || "Range",
              value: `${v}  ${y}`
            },
            ...S,
            ...b(s, "tooltip", "showTotal") === !0 ? [
              {
                label: At(s, "tooltip.totalLabel") || "Total",
                value: x.reduce(
                  (E, T) => E + parseFloat(At(g, `data.${T}`)),
                  0
                )
              }
            ] : []
          ]
        }), f.attr("opacity", 1);
        const _ = h((v + y) / 2);
        o === "horizontal" ? p.attr("x1", u).attr("x2", c).attr("y1", _).attr("y2", _) : p.attr("y1", u).attr("y2", c).attr("x1", _).attr("x2", _);
      } else
        this.hideRuler();
    } else
      this.hideRuler();
  }
}
class $a extends kn {
  formatTooltipData(t) {
    return t.reverse();
  }
}
const QI = (e, t) => {
  const n = e.x, r = e.y, i = t.x, s = t.y, a = Lp();
  return a.moveTo(n, r), a.lineTo(i, s), a.toString();
}, JI = {
  d: "M7 0v8L0 4z",
  height: 8,
  width: 7.5,
  id: "arrowLeft"
}, tN = {
  d: "M0 0v8l7-4z",
  height: 8,
  width: 7.5,
  id: "arrowRight"
}, eN = {
  d: "M5.32 9.513a4.75 4.75 0 100-9.5 4.75 4.75 0 000 9.5z",
  height: 10,
  width: 10,
  id: "circle"
}, nN = {
  d: "M5.03517654-1e-7l4.99999996 5-4.99999996 5-5-5L2.4517844 2.58339204z",
  height: 10,
  width: 10,
  id: "diamond"
}, rN = {
  d: "M0 .44974747h8v8H0v-3.6830331z",
  height: 9,
  width: 8,
  id: "square"
}, iN = {
  d: "M0 0h1.5v8H0z",
  height: 8,
  width: 2,
  id: "tee"
};
class bv extends iu {
  constructor(t, n, r) {
    super(t, n, r), this.type = "color-legend", this.renderType = K.SVG, this.gradient_id = `gradient-id-${Math.floor(Math.random() * 99999999999)}`, this.handleAxisCompleteEvent = () => {
      const i = this.getComponentContainer(), { width: s } = D.getSVGElementSize(i, {
        useAttrs: !0
      }), a = b(this.getOptions(), "data", "loading");
      if (s > Bt.color.barWidth && !a) {
        const o = b(this.getOptions(), "heatmap", "colorLegend", "title"), { cartesianScales: l } = this.services, c = l.getMainXScale().range();
        if (c[0] > 1 && (i.select("g.legend").attr("transform", `translate(${c[0]}, 0)`), o)) {
          const { width: u } = D.getSVGElementSize(
            i.select("g.legend-title").select("text"),
            { useBBox: !0 }
          ), h = c[0] - u - 9;
          h > 1 ? i.select("g.legend-title").attr("transform", `translate(${h}, 0)`) : (i.select("g.legend").attr("transform", `translate(${c[0]}, 16)`), i.select("g.legend-title").attr("transform", `translate(${c[0]}, 0)`));
        }
      } else
        i.select("g.legend-title").attr("transform", "translate(0, 0)");
    }, this.chartType = r.chartType;
  }
  init() {
    this.chartType === "heatmap" && this.services.events.addEventListener(
      O.Axis.RENDER_COMPLETE,
      this.handleAxisCompleteEvent
    );
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = this.getOptions(), r = this.getComponentContainer(), { width: i } = D.getSVGElementSize(r, {
      useAttrs: !0
    }), s = b(n, "color", "gradient", "colors"), a = b(
      n,
      this.chartType,
      "colorLegend",
      "type"
    );
    let o = b(n, "color", "pairing", "option");
    const l = b(n, "heatmap", "colorLegend", "title");
    if (b(this.getOptions(), "data", "loading")) {
      r.html("");
      return;
    }
    const c = !Re(s), u = $m(this.model.getDisplayData()), h = !(i <= Bt.color.barWidth), d = h ? Bt.color.barWidth : i, f = D.appendOrSelect(r, "g.legend"), p = D.appendOrSelect(f, "g.legend-axis");
    if (l) {
      const T = D.appendOrSelect(r, "g.legend-title");
      D.appendOrSelect(T, "text").text(l).attr("dy", "0.7em"), f.attr("transform", "translate(0, 16)");
    }
    const m = u[0] < 0 && u[1] > 0 ? "diverge" : "mono";
    (o < 1 && o > 4 && m === "mono" || o < 1 && o > 2 && m === "diverge") && (o = 1);
    let g = [];
    const v = m === "diverge" ? 17 : 11;
    if (c)
      g = s;
    else
      for (let T = 1; T < v + 1; T++)
        g.push(
          a === Es.LINEAR ? `stop-color-${m}-${o}-${T}` : `fill-${m}-${o}-${T}`
        );
    const y = xe(u[0], u[1]), x = q1(y, 3), S = Be().domain(u).range([0, d]), _ = hc(S).tickSize(0).tickValues(x);
    let E;
    switch (a) {
      case Es.LINEAR:
        this.drawLinear(g, f, d);
        break;
      case Es.QUANTIZE:
        E = this.drawQuantize(
          g,
          m,
          c,
          f,
          d
        ), S.range([E, d]);
        break;
      default:
        throw Error("Entered color legend type is not supported.");
    }
    p.attr("transform", `translate(0,${Bt.color.axisYTranslation})`).call(_), p.select(".domain").remove(), p.select("g.tick:last-of-type text").style("text-anchor", h ? "middle" : "end"), p.select("g.tick:first-of-type text").style(
      "text-anchor",
      h && this.chartType !== "choropleth" ? "middle" : "start"
    );
  }
  // Renders gradient legend
  drawLinear(t, n, r) {
    const i = 100 / (t.length - 1);
    D.appendOrSelect(n, "linearGradient").attr("id", `${this.gradient_id}-legend`).selectAll("stop").data(t).enter().append("stop").attr("offset", (s, a) => `${a * i}%`).attr("class", (s, a) => t[a]).attr("stop-color", (s) => s), D.appendOrSelect(n, "rect").attr("width", r).attr("height", Bt.color.barHeight).style("fill", `url(#${this.gradient_id}-legend)`);
  }
  /**
   * Renders quantized legend
   * @returns number (range start)
   */
  drawQuantize(t, n, r, i, s) {
    !r && n === "diverge" && t.splice(t.length / 2, 1);
    const a = Xi().domain(t).range([0, s]);
    return D.appendOrSelect(i, "g.quantized-rect").selectAll("rect").data(a.domain()).join("rect").attr("x", (o) => a(o)).attr("y", 0).attr("width", Math.max(0, a.bandwidth() - 1)).attr("height", Bt.color.barHeight).attr("class", (o) => o).attr("fill", (o) => o), (!r && n) === "mono" ? a.bandwidth() - 1 : 0;
  }
  destroy() {
    this.chartType === "heatmap" && this.services.events.removeEventListener(
      O.Axis.RENDER_COMPLETE,
      this.handleAxisCompleteEvent
    );
  }
}
class sN extends is {
  constructor() {
    super(...arguments), this.type = "meter-title", this.renderType = K.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const n = b(this.model.getDisplayData(), 0), r = this.getOptions(), i = this.getComponentContainer(), { groupMapsTo: s } = r.data;
    if (b(r, "meter", "proportional"))
      this.displayTotal(), this.displayBreakdownTitle();
    else {
      const l = i.selectAll("text.meter-title").data([n[s]]);
      l.enter().append("text").classed("meter-title", !0).merge(l).attr("x", 0).attr("y", "1em").text((c) => c), l.exit().remove(), this.appendPercentage();
    }
    this.displayStatus();
    const a = this.getMaxTitleWidth(), o = D.appendOrSelect(i, "text.meter-title");
    a > 0 && o.node().getComputedTextLength() > a && this.truncateTitle(o, a);
  }
  displayBreakdownTitle() {
    const t = this.getComponentContainer(), n = this.getOptions(), r = this.model.getMaximumDomain(this.model.getDisplayData()), i = b(n, "meter", "proportional", "total"), s = b(n, "meter", "proportional", "unit") ? b(n, "meter", "proportional", "unit") : "";
    let a;
    if (r === i)
      a = null;
    else {
      const u = i !== null ? i - r : r, h = b(n, "meter", "proportional", "breakdownFormatter");
      a = h !== null ? h({
        datasetsTotal: r,
        total: i
      }) : `${r} ${s} used (${u} ${s} available)`;
    }
    const o = t.selectAll("text.proportional-meter-title").data([a]);
    o.enter().append("text").classed("proportional-meter-title", !0).merge(o).attr("x", 0).attr("y", "1em").text((u) => u), o.exit().remove();
    const l = this.getMaxTitleWidth(), c = D.appendOrSelect(t, "text.proportional-meter-title");
    l > 0 && c.node().getComputedTextLength() > l && this.truncateTitle(c, l);
  }
  // show the total for prop meter
  displayTotal() {
    const t = this.getComponentContainer(), n = this.getOptions(), r = b(n, "meter", "proportional", "total"), i = r ? b(n, "meter", "proportional", "total") : this.model.getMaximumDomain(this.model.getDisplayData()), s = b(n, "meter", "proportional", "unit") ? b(n, "meter", "proportional", "unit") : "", a = b(n, "meter", "proportional", "totalFormatter"), o = a !== null ? a(i) : `${r} ${s} total`, l = D.getHTMLElementSize(this.services.domUtils.getMainContainer()), c = l.width ? l.width : this.parent.node().getAttribute("width"), u = t.selectAll("text.proportional-meter-total").data([o]);
    u.enter().append("text").classed("proportional-meter-total", !0).merge(u).attr(
      "x",
      this.model.getStatus() && typeof c != "string" ? c - Jt.total.paddingRight : c
    ).attr("y", "1em").attr("text-anchor", "end").text((h) => h), u.exit().remove();
  }
  /**
   * Appends the corresponding status based on the value and the peak.
   */
  displayStatus() {
    const t = this, n = this.getComponentContainer(), r = D.getHTMLElementSize(this.services.domUtils.getMainContainer()), i = r.width ? r.width : 0, s = this.model.getStatus(), a = Jt.status.indicatorSize / 2, o = D.appendOrSelect(n, "g.status-indicator").attr("class", s !== null ? `status-indicator status--${s}` : "").attr("transform", `translate(${i - a}, 0)`), l = s ? [s] : [], c = o.selectAll("circle.status").data(l);
    c.enter().append("circle").merge(c).attr("class", "status").attr("r", a).attr("cx", 0).attr("cy", 8);
    const u = o.selectAll("path.innerFill").data(l);
    u.enter().append("path").merge(u).attr("d", t.getStatusIconPathString(s)).attr("transform", `translate(-${a}, 0)`).attr("class", "innerFill"), u.exit().remove(), c.exit().remove();
  }
  /**
   * Appends the associated percentage to the end of the title
   */
  appendPercentage() {
    const t = b(this.model.getDisplayData(), 0, "value"), n = this.getComponentContainer(), r = D.appendOrSelect(n, "text.meter-title"), i = b(this.getOptions(), "meter", "statusBar", "percentageIndicator", "enabled") === !0 ? [t] : [], s = n.selectAll("text.percent-value").data(i), a = Jt.statusBar.paddingRight;
    s.enter().append("text").classed("percent-value", !0).merge(s).text((o) => `${o}%`).attr("x", +r.attr("x") + r.node().getComputedTextLength() + a).attr("y", r.attr("y")), s.exit().remove();
  }
  /**
   * Uses the parent class truncate logic
   * @param title d3 selection of title element that will be truncated
   * @param titlestring the original string that needs truncation
   * @param maxWidth the max width the title can take
   */
  truncateTitle(t, n) {
    super.truncateTitle(t, n);
    const r = D.appendOrSelect(this.parent, "tspan"), i = Jt.statusBar.paddingRight, s = Math.ceil(r.node().getComputedTextLength());
    D.appendOrSelect(this.parent, "text.percent-value").attr(
      "x",
      +t.attr("x") + t.node().getComputedTextLength() + s + i
    );
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    const t = D.getHTMLElementSize(this.services.domUtils.getMainContainer()), n = b(this.getOptions(), "meter", "proportional"), r = t.width ? t.width : this.parent.node().getBoundingClientRect().width;
    if (n !== null) {
      const i = D.appendOrSelect(this.parent, "text.proportional-meter-total").node(), s = D.getSVGElementSize(i, {
        useBBox: !0
      }).width;
      return r - s - Jt.total.paddingLeft;
    } else {
      const i = D.appendOrSelect(this.parent, "text.percent-value"), s = Jt.statusBar.paddingRight, a = i.node().getComputedTextLength(), o = D.appendOrSelect(this.parent, "g.status-indicator").node(), l = D.getSVGElementSize(o, { useBBox: !0 }).width + Jt.status.paddingLeft;
      return r - a - s - l;
    }
  }
  /**
   * Get the associated status icon for the data
   * @param status the active status for the meter chart
   */
  getStatusIconPathString(t) {
    switch (t) {
      case ws.SUCCESS:
        return "M6.875 11.3125 3.75 8.1875 4.74375 7.25 6.875 9.34375 11.50625 4.75 12.5 5.7375 Z";
      case ws.DANGER:
        return "M10.7 11.5 4.5 5.3 5.3 4.5 11.5 10.7 Z";
      case ws.WARNING:
        return "M7.9375,11.125 C7.41973305,11.125 7,11.544733 7,12.0625 C7,12.580267 7.41973305,13 7.9375,13 C8.45526695,13 8.875,12.580267 8.875,12.0625 C8.875,11.544733 8.45526695,11.125 7.9375,11.125 M7.3125, 3 8.5625, 3 8.5625, 9.875 7.3125, 9.875, 7.3125, 3 Z";
    }
  }
}
class ou extends dt {
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions();
    if (t.bars.width)
      return t.bars.width;
    const n = this.model.getDisplayData().length, r = this.services.cartesianScales.getMainXScale(), i = D.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width;
    if (!r.step) {
      const s = b(t, "bars", "spacingFactor");
      return Math.min(t.bars.maxWidth, i * s / n);
    }
    return Math.min(t.bars.maxWidth, r.step() / 2);
  }
  isOutsideZoomedDomain(t, n) {
    if (this.model.getDisplayData().length <= 1)
      return !1;
    const r = this.model.get("zoomDomain");
    if (r !== void 0) {
      const i = this.services.cartesianScales.getDomainScale();
      return t < i(r[0]) || n > i(r[1]);
    }
    return !1;
  }
}
class aN extends dt {
  constructor() {
    super(...arguments), this.type = "circle-pack", this.renderType = K.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("circle.node").transition("legend-hover-circlepack").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-circlepack"
        })
      ).attr("opacity", (r) => r.data.dataGroupName === n.datum().name ? 1 : xr.circles.fillOpacity);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("circle.node").transition("legend-mouseout-circlepack").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-circlepack"
        })
      ).attr("opacity", 1);
    };
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), { width: r, height: i } = D.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (r < 1 || i < 1)
      return;
    let s = this.model.getDisplayData();
    const a = this.model.hasParentNode(), o = this.model.getHierarchyLevel(), l = this.getOptions(), c = b(l, "canvasZoom", "enabled");
    a && b(s, 0, "children") && (s = b(s, 0, "children"));
    const u = Yi({ children: s }).sum((p) => p.value).sort((p, m) => m.value - p.value), h = o_().size([r, i]).padding((p) => p.depth >= 1 ? xr.padding.children + 3 : xr.padding.mainGroup + 3)(u).descendants().splice(1).filter((p) => p.depth <= o), d = n.selectAll("circle.node").data(h);
    d.exit().attr("width", 0).attr("height", 0).remove();
    const f = d.enter().append("circle").classed("node", !0);
    f.merge(d).attr("class", (p) => {
      const m = c && o === 3 ? this.getZoomClass(p) : "";
      return this.model.getColorClassName({
        classNameTypes: [et.FILL, et.STROKE],
        dataGroupName: p.data.dataGroupName,
        originalClassName: p.children ? `node ${m}` : `node node-leaf ${m}`
      });
    }).style("fill", (p) => this.model.getFillColor(p.data.dataGroupName)).style("stroke", (p) => this.model.getFillColor(p.data.dataGroupName)).attr("cx", (p) => p.x).attr("cy", (p) => p.y).transition("circlepack-leaf-update-enter").call(
      (p) => this.services.transitions.setupTransition({
        transition: p,
        name: "circlepack-leaf-update-enter"
      })
    ).attr("r", (p) => p.r).attr("opacity", 1).attr("fill-opacity", xr.circles.fillOpacity), c === !0 && this.focal && (this.services.canvasZoom.zoomIn(this.focal, f, Mr), this.setBackgroundListeners()), a || this.addLegendListeners(), this.addEventListeners();
  }
  // turn off the highlight class on children circles
  unhighlightChildren(t) {
    const n = t.map((r) => r.data);
    this.parent.selectAll("circle.node").filter((r) => n.some((i) => i === r.data) && r.depth > 1).style("stroke", (r) => this.model.getFillColor(r.data.dataGroupName));
  }
  // highlight the children circles with a stroke
  highlightChildren(t) {
    const n = t.map((r) => r.data);
    this.parent.selectAll("circle.node").filter((r) => n.some((i) => i === r.data) && r.depth > 1).style("stroke", xr.circles.hover.stroke);
  }
  getZoomClass(t) {
    return this.model.getHierarchyLevel() === 3 && this.focal && (t.data === this.focal.data || this.focal.children.some((n) => n.data === t.data)) ? "focal" : "non-focal";
  }
  addLegendListeners() {
    const { events: t } = this.services;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  removeBackgroundListeners() {
    R(this.services.domUtils.getMainContainer()).on("click", () => null);
  }
  setBackgroundListeners() {
    const t = R(this.services.domUtils.getMainContainer()), n = this, r = this.parent.selectAll("circle.node");
    t.on("click", () => {
      n.focal = null, n.model.updateHierarchyLevel(2), t.classed("zoomed-in", !1), n.services.canvasZoom.zoomOut(r, Mr);
    });
  }
  // Zoom icon to be appended to the label in the tooltip
  getZoomIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">
			<polygon points="5.93 3.71 4.45 3.71 4.45 2.23 3.71 2.23 3.71 3.71 2.23 3.71 2.23 4.45 3.71 4.45 3.71 5.93 4.45 5.93 4.45 4.45 5.93 4.45 5.93 3.71"/>
			<path d="M7.2,6.67a4,4,0,0,0,1-2.59A4.08,4.08,0,1,0,4.07,8.15h0a4,4,0,0,0,2.59-1L9.48,10,10,9.48Zm-3.12.77A3.34,3.34,0,1,1,7.41,4.08,3.34,3.34,0,0,1,4.08,7.44Z"/>
		</svg>`;
  }
  // add event listeners for tooltip on the circles
  addEventListeners() {
    const t = this;
    this.parent.selectAll("circle.node").on("mouseover", function(n, r) {
      const i = R(this);
      i.classed("hovered", !0);
      const s = t.model.getHierarchyLevel(), a = s > 2 && !i.classed("focal"), o = b(t.model.getOptions(), "canvasZoom", "enabled");
      let l = !1;
      if (!a) {
        let c = [], u = [], h = null;
        if (r.children) {
          r.depth > 1 && o && (l = !0, i.classed("clickable", !0)), c = r.children.map((p) => {
            if (p !== null)
              return typeof p.data.value == "number" ? {
                label: p.data.name,
                value: p.data.value
              } : {
                label: p.data.name,
                labelIcon: o && s <= 2 ? t.getZoomIcon() : null,
                value: p.value
              };
          });
          const f = t.model.getOptions();
          u = [
            {
              label: At(f, "tooltip.totalLabel") || "Total",
              value: r.value,
              bold: !0
            }
          ], t.highlightChildren(r.children);
        } else
          h = r.value;
        const d = getComputedStyle(this, null).getPropertyValue("fill");
        t.services.events.dispatchEvent(O.Tooltip.SHOW, {
          event: n,
          hoveredElement: i,
          items: [
            {
              color: d,
              label: r.data.name,
              labelIcon: l && o && s <= 2 ? t.getZoomIcon() : null,
              value: h
            },
            ...c,
            ...u
          ]
        });
      }
      t.services.events.dispatchEvent(O.CirclePack.CIRCLE_MOUSEOVER, {
        event: n,
        element: i,
        datum: r
      });
    }).on("mousemove", function(n, r) {
      const i = R(this);
      t.services.events.dispatchEvent(O.CirclePack.CIRCLE_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: n
      });
    }).on("mouseout", function(n, r) {
      const i = R(this);
      i.classed("hovered", !1), r.children && t.unhighlightChildren(r.children), t.services.events.dispatchEvent(O.CirclePack.CIRCLE_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: i
      });
    }).on("click", function(n, r) {
      const i = R(this), s = i.classed("non-focal"), a = b(t.model.getOptions(), "canvasZoom", "enabled");
      if (a && t.model.getHierarchyLevel() > 2) {
        const o = t.parent.selectAll("circle.node");
        R(t.services.domUtils.getMainContainer()).classed("zoomed-in", !1), t.focal = null, t.model.updateHierarchyLevel(2), t.services.canvasZoom.zoomOut(o, Mr);
      } else if (r.depth === 2 && r.children && !s && a) {
        const o = t.parent.selectAll("circle.node");
        R(t.services.domUtils.getMainContainer()).classed("zoomed-in", !0), t.focal = r, t.model.updateHierarchyLevel(3), t.services.canvasZoom.zoomIn(r, o, Mr), n.stopPropagation();
      }
      t.services.events.dispatchEvent(O.CirclePack.CIRCLE_CLICK, {
        event: n,
        element: i,
        datum: r
      });
    });
  }
  destroy() {
    this.parent.selectAll("circle.node").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), this.removeBackgroundListeners();
  }
}
function oN(e, t) {
  const n = qi(this._current, e);
  return (r) => (this._current = n(r), t(this._current));
}
class wv extends dt {
  constructor() {
    super(...arguments), this.type = "pie", this.renderType = K.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.slice").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr(
        "opacity",
        (i) => i.data[r] !== n.datum().name ? 0.3 : 1
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.slice").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getInnerRadius() {
    return $t.innerRadius;
  }
  render(t = !0) {
    const n = this, r = this.getComponentContainer(), i = this.getOptions(), { groupMapsTo: s } = i.data, { valueMapsTo: a } = i.pie, o = this.model.getDisplayData().filter((T) => T[a] > 0), l = this.computeRadius();
    this.arc = Bi().innerRadius(this.getInnerRadius()).outerRadius(l), this.hoverArc = Bi().innerRadius(this.getInnerRadius()).outerRadius(l + $t.hoverArc.outerRadiusOffset);
    const c = lS().value((T) => T[a]).sort(b(i, "pie", "sortFunction")).padAngle($t.padAngle)(o), u = D.appendOrSelect(r, "g.slices").attr("role", at.GROUP).attr("data-name", "slices").selectAll("path.slice").data(c, (T) => T.data[s]);
    u.exit().attr("opacity", 0).remove(), u.enter().append("path").classed("slice", !0).attr("opacity", 0).merge(u).attr(
      "class",
      (T) => this.model.getColorClassName({
        classNameTypes: [et.FILL],
        dataGroupName: T.data[s],
        originalClassName: "slice"
      })
    ).style("fill", (T) => n.model.getFillColor(T.data[s])).attr("d", this.arc).transition().call(
      (T) => this.services.transitions.setupTransition({
        transition: T,
        name: "pie_slice_enter_update",
        animate: t
      })
    ).attr("opacity", 1).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "slice").attr(
      "aria-label",
      (T) => `${T[a]}, ${Ad(T.data[a], o, a) + "%"}`
    ).attrTween("d", function(T) {
      return oN.bind(this)(T, n.arc);
    });
    const h = i.pie.labels.enabled, d = h ? c.filter((T) => T.data[a] > 0) : [], f = D.appendOrSelect(r, "g.labels").attr("role", at.GROUP).attr("data-name", "labels").selectAll("text.pie-label").data(d, (T) => T.data[s]);
    f.exit().attr("opacity", 0).remove();
    const p = f.enter().append("text").classed("pie-label", !0), m = [];
    p.merge(f).style("text-anchor", "middle").text((T) => i.pie.labels.formatter ? i.pie.labels.formatter(T) : Ad(T.data[a], o, a) + "%").datum(function(T) {
      const k = l + 7, N = (T.endAngle - T.startAngle) / 2 + T.startAngle, L = N / Math.PI * 180, C = this.getComputedTextLength();
      return T.textOffsetX = C / 2, T.textOffsetY = L > 90 && L < 270 ? 10 : 0, T.xPosition = (T.textOffsetX + k) * Math.sin(N), T.yPosition = (T.textOffsetY + k) * -Math.cos(N), T;
    }).attr("transform", function(T, k) {
      const N = d.length, L = (T.endAngle - T.startAngle) * (180 / Math.PI);
      if (k >= N - 2 && L < $t.callout.minSliceDegree) {
        let C, V;
        return T.index === N - 1 ? (C = T.xPosition + $t.callout.offsetX + $t.callout.textMargin + T.textOffsetX, V = T.yPosition - $t.callout.offsetY, T.direction = bs.RIGHT, m.push(T)) : (C = T.xPosition - $t.callout.offsetX - T.textOffsetX - $t.callout.textMargin, V = T.yPosition - $t.callout.offsetY, T.direction = bs.LEFT, m.push(T)), `translate(${C}, ${V})`;
      }
      return `translate(${T.xPosition}, ${T.yPosition})`;
    }), this.renderCallouts(m);
    const g = b(i, "donut") ? "donut" : "pie", v = b(i, g, "alignment"), { width: y } = D.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    }), x = h ? $t.xOffset : 0, S = h ? $t.yOffset : 0;
    let _ = l + x;
    v === Yt.CENTER ? _ = y / 2 : v === Yt.RIGHT && (_ = y - l - $t.xOffset);
    let E = l + S;
    m.length > 0 && (E += $t.yOffsetCallout), r.attr("x", _ + 7).attr("y", E), this.addEventListeners();
  }
  renderCallouts(t) {
    const n = D.appendOrSelect(this.getComponentContainer(), "g.callouts").attr("role", at.GROUP).attr("data-name", "callouts"), r = n.selectAll("g.callout").data(t);
    r.exit().remove();
    const i = r.enter().append("g").classed("callout", !0).attr("role", at.GROUP).attr("aria-roledescription", "label callout");
    i.merge(r).datum(function(s) {
      const { xPosition: a, yPosition: o, direction: l } = s;
      return l === bs.RIGHT ? (s.startPos = {
        x: a,
        y: o + s.textOffsetY
      }, s.endPos = {
        x: a + $t.callout.offsetX,
        y: o - $t.callout.offsetY + s.textOffsetY
      }, s.intersectPointX = s.endPos.x - $t.callout.horizontalLineLength) : (s.startPos = {
        x: a,
        y: o + s.textOffsetY
      }, s.endPos = {
        x: a - $t.callout.offsetX,
        y: o - $t.callout.offsetY + s.textOffsetY
      }, s.intersectPointX = s.endPos.x + $t.callout.horizontalLineLength), s;
    }), i.append("line").classed("vertical-line", !0).merge(n.selectAll("line.vertical-line")).datum(function() {
      return R(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (s) => s.startPos.x).attr("y1", (s) => s.startPos.y).attr("x2", (s) => s.intersectPointX).attr("y2", (s) => s.endPos.y), i.append("line").classed("horizontal-line", !0).merge(n.selectAll("line.horizontal-line")).datum(function() {
      return R(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (s) => s.intersectPointX).attr("y1", (s) => s.endPos.y).attr("x2", (s) => s.endPos.x).attr("y2", (s) => s.endPos.y);
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.slice").on("mouseover", function(n, r) {
      const i = R(this);
      i.classed("hovered", !0).transition("pie_slice_mouseover").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "pie_slice_mouseover"
        })
      ).attr("d", t.hoverArc), t.services.events.dispatchEvent(O.Pie.SLICE_MOUSEOVER, {
        event: n,
        element: R(this),
        datum: r
      });
      const { groupMapsTo: s } = t.getOptions().data, { valueMapsTo: a } = t.getOptions().pie;
      t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        items: [
          {
            label: r.data[s],
            value: r.data[a]
          }
        ]
      });
    }).on("mousemove", function(n, r) {
      const i = R(this);
      t.services.events.dispatchEvent(O.Pie.SLICE_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(O.Pie.SLICE_CLICK, {
        event: n,
        element: R(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = R(this);
      i.classed("hovered", !1).transition("pie_slice_mouseout").call(
        (s) => t.services.transitions.setupTransition({
          transition: s,
          name: "pie_slice_mouseout"
        })
      ).attr("d", t.arc), t.services.events.dispatchEvent(O.Pie.SLICE_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  // Helper functions
  computeRadius() {
    const { width: t, height: n } = D.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), r = this.getOptions(), i = Math.min(t, n) / 2;
    return r.pie.labels.enabled ? i + $t.radiusOffset : i;
  }
}
class lN extends wv {
  constructor() {
    super(...arguments), this.type = "donut", this.renderType = K.SVG;
  }
  render(t = !0) {
    super.render(t);
    const n = this;
    if (this.model.isDataEmpty()) {
      this.getComponentContainer().select("g.center").remove();
      return;
    }
    const r = D.appendOrSelect(this.getComponentContainer(), "g.center"), i = this.getOptions(), s = this.computeRadius(), a = b(i, "donut", "center", "label");
    D.appendOrSelect(r, "text.donut-figure").attr("text-anchor", "middle").style("dominant-baseline", () => a === null || a === "" ? "central" : "initial").style("font-size", () => i.donut.center.numberFontSize(s)).transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "donut-figure-enter-update",
        animate: t
      })
    ).tween("text", function() {
      return n.centerNumberTween(R(this));
    }), a !== null && a !== "" && D.appendOrSelect(r, "text.donut-title").attr("text-anchor", "middle").style("font-size", () => i.donut.center.titleFontSize(s)).attr("y", i.donut.center.titleYPosition(s)).text(a);
  }
  getInnerRadius() {
    return this.computeRadius() * (3 / 4);
  }
  centerNumberTween(t) {
    const n = this.getOptions();
    let r = b(n, "donut", "center", "number");
    r === null && (r = this.model.getDisplayData().reduce((o, l) => o + l[n.pie.valueMapsTo], 0));
    const i = parseInt(t.text().replace(/[, ]+/g, ""), 10) || 0;
    let s;
    i % 1 === 0 && r % 1 === 0 ? s = yp : s = xe;
    const a = s(i, r);
    return (o) => {
      const { numberFormatter: l } = n.donut.center;
      t.text(l(a(o)));
    };
  }
}
const df = "4,10 8,6 12,10", ff = "12,6 8,10 4,6";
class cN extends dt {
  constructor() {
    super(...arguments), this.type = "gauge", this.renderType = K.SVG;
  }
  getValue() {
    var t;
    return ((t = this.model.getData().find((n) => n.group === "value")) == null ? void 0 : t.value) ?? null;
  }
  getValueRatio() {
    return av(this.getValue(), 0, 100) / 100;
  }
  getDelta() {
    var t;
    return ((t = this.model.getData().find((n) => n.group === "delta")) == null ? void 0 : t.value) ?? null;
  }
  getArcRatio() {
    const t = this.getOptions();
    return b(t, "gauge", "type") === _r.FULL ? 1 : 0.5;
  }
  getArcSize() {
    return this.getArcRatio() * Math.PI * 2;
  }
  getStartAngle() {
    const t = this.getArcSize();
    return t === 2 * Math.PI ? 0 : -t / 2;
  }
  // use provided arrow direction or default to using the delta
  getArrow(t) {
    const n = this.getOptions();
    switch (b(n, "gauge", "deltaArrow", "direction")) {
      case Xo.UP:
        return df;
      case Xo.DOWN:
        return ff;
      default:
        return t > 0 ? df : ff;
    }
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer().attr("width", "100%").attr("height", "100%"), r = this.getOptions(), i = this.getValue(), s = this.getValueRatio(), a = this.getArcSize(), o = this.getStartAngle(), l = s * a, c = o + l, u = o + a, h = this.computeRadius(), d = this.getInnerRadius();
    this.backgroundArc = Bi().innerRadius(d).outerRadius(h).startAngle(c).endAngle(u), this.arc = Bi().innerRadius(d).outerRadius(h).startAngle(o).endAngle(c), D.appendOrSelect(n, "path.arc-background").attr("d", this.backgroundArc);
    const f = n.selectAll("path.arc-foreground").data([i]);
    f.enter().append("path").merge(f).attr(
      "class",
      this.model.getColorClassName({
        classNameTypes: [et.FILL],
        dataGroupName: "value",
        originalClassName: "arc-foreground"
      })
    ).style("fill", () => b(this.getOptions(), "color", "scale", "value")).attr("d", this.arc).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (v) => v), this.drawValueNumber(), this.drawDelta(), f.exit().remove();
    const p = b(r, "gauge", "alignment"), { width: m } = D.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    });
    let g = h;
    p === Yt.CENTER ? g = m / 2 : p === Yt.RIGHT && (g = m - h), n.attr("x", g).attr("y", h), this.addEventListeners();
  }
  /**
   * draws the value number associated with the Gauge component in the center
   */
  drawValueNumber() {
    const t = this.getComponentContainer(), n = this.getOptions(), r = b(n, "gauge", "type"), i = this.getValue(), s = this.getDelta(), a = this.computeRadius(), o = b(n, "gauge", "valueFontSize"), l = b(n, "gauge", "deltaFontSize"), c = b(n, "gauge", "numberSpacing"), u = b(n, "gauge", "showPercentageSymbol");
    let h = 0;
    r === _r.FULL && !s ? h = l(a) : r === _r.SEMI && s && (h = -(l(a) + c));
    const d = D.appendOrSelect(t, "g.gauge-numbers").attr(
      "transform",
      `translate(0, ${h})`
    ), f = o(a), p = D.appendOrSelect(d, "g.gauge-value-number"), m = b(n, "gauge", "numberFormatter"), g = p.selectAll("text.gauge-value-number").data([i]);
    g.enter().append("text").attr("class", "gauge-value-number").merge(g).style("font-size", `${f}px`).attr("text-anchor", "middle").text((T) => m(T));
    const { width: v } = D.getSVGElementSize(
      D.appendOrSelect(t, "text.gauge-value-number"),
      { useBBox: !0 }
    ), y = f / 2, x = u ? "%" : "", S = D.appendOrSelect(p, "text.gauge-value-symbol").style("font-size", `${y}px`).attr("x", v / 2).text(x), { width: _, height: E } = D.getSVGElementSize(S, {
      useBBox: !0
    });
    S.attr("y", `-${E / 2}px`), p.attr("transform", `translate(-${_ / 2}, 0)`);
  }
  /**
   * adds the delta number for the gauge
   */
  drawDelta() {
    const t = this, n = this.getComponentContainer(), r = this.getOptions(), i = this.getDelta();
    if (i) {
      const s = this.computeRadius(), a = i ? b(r, "gauge", "deltaFontSize") : () => 0, o = i ? b(r, "gauge", "numberFormatter") : () => null, l = b(r, "gauge", "deltaArrow", "size"), c = b(r, "gauge", "numberSpacing"), u = b(r, "gauge", "showPercentageSymbol"), h = D.appendOrSelect(n, "g.gauge-numbers"), d = D.appendOrSelect(h, "g.gauge-delta").attr(
        "transform",
        `translate(0, ${a(s) + c})`
      ), f = D.appendOrSelect(d, "text.gauge-delta-number"), p = u ? "%" : "";
      f.data(i === null ? [] : [i]), f.enter().append("text").classed("gauge-delta-number", !0).merge(f).attr("text-anchor", "middle").style("font-size", `${a(s)}px`).text((y) => `${o(y)}${p}`);
      const { width: m } = D.getSVGElementSize(
        D.appendOrSelect(n, ".gauge-delta-number"),
        { useBBox: !0 }
      ), g = b(r, "gauge", "deltaArrow", "enabled"), v = d.selectAll("svg.gauge-delta-arrow").data(i !== null && g ? [i] : []);
      v.enter().append("svg").merge(v).attr("class", "gauge-delta-arrow").attr("x", -l(s) - m / 2).attr("y", -l(s) / 2 - a(s) * 0.35).attr("width", l(s)).attr("height", l(s)).attr("viewBox", "0 0 16 16").each(function() {
        const y = R(this);
        D.appendOrSelect(y, "rect.gauge-delta-arrow-backdrop").attr("width", "16").attr("height", "16").attr("fill", "none");
        const x = b(r, "gauge", "status");
        D.appendOrSelect(y, "polygon.gauge-delta-arrow").attr("class", x !== null ? `gauge-delta-arrow status--${x}` : "").attr("points", t.getArrow(i));
      }), v.exit().remove(), f.exit().remove();
    } else {
      const s = n.select("g.gauge-delta");
      s.empty() || s.remove();
    }
  }
  getInnerRadius() {
    const t = this.computeRadius(), n = b(this.getOptions(), "gauge", "arcWidth");
    return t - n;
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.arc-foreground").on("mouseover", function(n, r) {
      t.services.events.dispatchEvent(O.Gauge.ARC_MOUSEOVER, {
        event: n,
        element: R(this),
        datum: r
      });
    }).on("mousemove", function(n, r) {
      const i = R(this);
      t.services.events.dispatchEvent(O.Gauge.ARC_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(O.Gauge.ARC_CLICK, {
        event: n,
        element: R(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = R(this);
      t.services.events.dispatchEvent(O.Gauge.ARC_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      });
    });
  }
  // Helper functions
  computeRadius() {
    const t = this.getOptions(), n = b(t, "gauge", "type"), { width: r, height: i } = D.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return n === _r.SEMI ? Math.min(r / 2, i) : Math.min(r / 2, i / 2);
  }
}
class _v extends ou {
  constructor() {
    super(...arguments), this.type = "grouped-bar", this.renderType = K.SVG, this.padding = 5, this.defaultStepFactor = 70, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.model.getDisplayData(this.configs.groups), r = this.getOptions(), { groupMapsTo: i } = r.data;
    this.setGroupScale();
    const s = this.getComponentContainer({ withinChartClip: !0 }), a = Gi(
      n.map((u) => {
        const h = this.services.cartesianScales.getDomainIdentifier(u);
        return u[h] && typeof u[h].toString == "function" ? u[h].toString() : u[h];
      })
    ), o = s.selectAll("g.bars").data(a, (u) => u);
    o.exit().attr("opacity", 0).remove();
    const l = o.enter().append("g").classed("bars", !0).attr("role", at.GROUP).attr("data-name", "bars").merge(o);
    l.transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-group-update-enter",
        animate: t
      })
    ).attr("transform", (u) => {
      const h = this.services.cartesianScales.getDomainValue(u) - this.getGroupWidth() / 2;
      return this.services.cartesianScales.getOrientation() === Kt.VERTICAL ? `translate(${h}, 0)` : `translate(0, ${h})`;
    });
    const c = l.selectAll("path.bar").data(
      (u) => this.getDataCorrespondingToLabel(u),
      (u) => u[i]
    );
    c.exit().attr("opacity", 0).remove(), c.enter().append("path").attr("opacity", 0).merge(c).classed("bar", !0).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [et.FILL],
        dataGroupName: u[i],
        originalClassName: "bar"
      })
    ).style("fill", (u) => this.model.getFillColor(u[i])).attr("d", (u) => {
      const h = this.groupScale(u[i]), d = this.getBarWidth(), f = h, p = h + d, m = this.services.cartesianScales.getRangeAxisPosition({ datum: u }), g = this.services.cartesianScales.getValueThroughAxisPosition(m, 0), v = this.services.cartesianScales.getRangeValue(u), y = this.services.cartesianScales.getDomainValue(u) - d / 2, x = y + d;
      if (!this.isOutsideZoomedDomain(y, x))
        return ce(
          { x0: f, x1: p, y0: g, y1: v },
          this.services.cartesianScales.getOrientation()
        );
    }).attr("opacity", 1).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (u) => u.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.bar").on("mouseover", function(n, r) {
      const i = R(this);
      i.classed("hovered", !0), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOVER, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        data: [r]
      });
    }).on("mousemove", function(n, r) {
      const i = R(this);
      t.services.events.dispatchEvent(O.Bar.BAR_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(O.Bar.BAR_CLICK, {
        event: n,
        element: R(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = R(this);
      i.classed("hovered", !1), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getDataCorrespondingToLabel(t) {
    return this.model.getDisplayData(this.configs.groups).filter((n) => {
      const r = this.services.cartesianScales.getDomainIdentifier(n);
      return n[r].toString() === t;
    });
  }
  getGroupWidth() {
    const t = this.model.getGroupedData(this.configs.groups), n = this.getTotalGroupPadding();
    return this.getBarWidth() * t.length + n;
  }
  getDomainScaleStep() {
    const t = this.services.cartesianScales.getDomainScale(), n = this.model.getGroupedData(this.configs.groups);
    let r = this.defaultStepFactor;
    if (typeof t.step == "function")
      r = t.step();
    else if (n.length > 0) {
      const i = n.find((s) => {
        var a;
        return ((a = s.data) == null ? void 0 : a.length) > 1;
      });
      if (i) {
        const s = this.services.cartesianScales.getDomainIdentifier(i.data[0]);
        r = Math.abs(
          t(i.data[1][s]) - t(i.data[0][s])
        );
      }
    }
    return r;
  }
  getTotalGroupPadding() {
    const t = this.model.getGroupedData(this.configs.groups);
    return t.length === 1 ? 0 : Math.min(5, 5 * (this.getDomainScaleStep() / this.defaultStepFactor)) * (t.length - 1);
  }
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions(), n = b(t, "bars", "width"), r = b(t, "bars", "maxWidth");
    if (n !== null && (r === null || n <= r))
      return n;
    const i = this.model.getGroupedData(this.configs.groups).length, s = this.getTotalGroupPadding();
    return Math.min(
      r,
      (this.getDomainScaleStep() - s) / i
    );
  }
  setGroupScale() {
    const t = this.model.getActiveDataGroupNames(this.configs.groups);
    this.groupScale = Xi().domain(t).rangeRound([0, this.getGroupWidth()]);
  }
}
class uN extends dt {
  constructor() {
    super(...arguments), this.type = "heatmap", this.renderType = K.SVG, this.matrix = {}, this.xBandwidth = 0, this.yBandwidth = 0, this.translationUnits = {
      x: 0,
      y: 0
    }, this.handleAxisOnHover = (t) => {
      const { detail: n } = t, { datum: r } = n, i = this.model.getUniqueRanges(), s = this.model.getUniqueDomain(), a = this.services.cartesianScales.getDomainLabel(), o = this.services.cartesianScales.getRangeLabel(), l = this.services.cartesianScales.getMainXScale(), c = this.services.cartesianScales.getMainYScale();
      let u = "", h = null, d = null, f = null;
      this.matrix[r] !== void 0 ? (u = a, i.forEach((p) => {
        if (typeof this.matrix[r][p].value == "number") {
          const m = this.matrix[r][p].value;
          if (h === null) {
            h = m, d = m, f = m;
            return;
          }
          h += m, d = m < d ? m : d, f = m > f ? m : f;
        }
      })) : (u = o, s.forEach((p) => {
        if (typeof this.matrix[p][r].value == "number") {
          const m = this.matrix[p][r].value;
          if (h === null) {
            h = m, d = m, f = m;
            return;
          }
          h += m, d = m < d ? m : d, f = m > f ? m : f;
        }
      })), l(r) !== void 0 ? this.parent.select("g.multi-cell.column-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${l(r)}, ${Ln(c.range())})`) : c(r) !== void 0 && this.parent.select("g.multi-cell.row-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${Ln(l.range())},${c(r)})`), this.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: n.event,
        hoveredElement: R(t.detail.element),
        items: [
          {
            label: u,
            value: r,
            bold: !0
          },
          {
            label: "Min",
            value: d !== null ? d : "-"
          },
          {
            label: "Max",
            value: f !== null ? f : "-"
          },
          {
            label: "Average",
            value: h !== null ? h / s.length : "-"
          }
        ]
      });
    }, this.handleAxisMouseOut = (t) => {
      this.parent.selectAll("g.multi-cell").classed("highlighter-hidden", !0), this.services.events.dispatchEvent(O.Tooltip.HIDE, {
        event: t
      });
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Axis.LABEL_MOUSEOVER, this.handleAxisOnHover), t.addEventListener(O.Axis.LABEL_MOUSEOUT, this.handleAxisMouseOut), t.addEventListener(O.Axis.LABEL_FOCUS, this.handleAxisOnHover), t.addEventListener(O.Axis.LABEL_BLUR, this.handleAxisMouseOut);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 });
    n.lower();
    const { cartesianScales: r } = this.services;
    if (this.matrix = this.model.getMatrix(), n.html(""), b(this.getOptions(), "data", "loading"))
      return;
    const i = r.getMainXScale(), s = r.getMainYScale(), a = r.getDomainIdentifier(), o = r.getRangeIdentifier(), l = this.model.getUniqueDomain(), c = this.model.getUniqueRanges(), u = this.model.getMatrixAsArray(), h = i.range(), d = s.range();
    this.xBandwidth = Math.abs((h[1] - h[0]) / l.length), this.yBandwidth = Math.abs((d[1] - d[0]) / c.length);
    const f = this.services.domUtils.generateElementIDString("heatmap-pattern-stripes");
    n.append("defs").append("pattern").attr("id", f).attr("width", 3).attr("height", 3).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("rect").classed("pattern-fill", !0).attr("width", 0.5).attr("height", 8);
    const p = n.selectAll().data(u).enter().append("g").attr("class", (m) => `heat-${m.index}`).classed("cell", !0).attr(
      "transform",
      (m) => `translate(${i(m[a])}, ${s(m[o])})`
    ).append("rect").attr(
      "class",
      (m) => this.model.getColorClassName({
        value: m.value,
        originalClassName: `heat-${m.index}`
      })
    ).classed("heat", !0).classed("null-state", (m) => m.index === -1 || m.value === null).attr("width", this.xBandwidth).attr("height", this.yBandwidth).style("fill", (m) => m.index === -1 || m.value === null ? `url(#${f})` : this.model.getFillColor(Number(m.value))).attr("aria-label", (m) => m.value);
    this.createOuterBox("g.cell-highlight", this.xBandwidth, this.yBandwidth), this.createOuterBox(
      "g.multi-cell.column-highlight",
      this.xBandwidth,
      Math.abs(d[1] - d[0])
    ), this.createOuterBox(
      "g.multi-cell.row-highlight",
      Math.abs(h[1] - h[0]),
      this.yBandwidth
    ), this.determineDividerStatus() && (p.style("stroke-width", "1px"), this.parent.select("g.cell-highlight").classed("cell-2", !0)), this.addEventListener();
  }
  /**
   * Generates a box using lines to create a hover effect
   * The lines have drop shadow in their respective direction
   * @param parentTag - tag name
   * @param xBandwidth - X length
   * @param yBandwidth - y length
   */
  createOuterBox(t, n, r) {
    const i = D.appendOrSelect(this.parent, t).classed("shadows", !0).classed("highlighter-hidden", !0);
    D.appendOrSelect(i, "line.top").attr("x1", -1).attr("x2", n + 1), D.appendOrSelect(i, "line.left").attr("x1", 0).attr("y1", -1).attr("x2", 0).attr("y2", r + 1), D.appendOrSelect(i, "line.down").attr("x1", -1).attr("x2", n + 1).attr("y1", r).attr("y2", r), D.appendOrSelect(i, "line.right").attr("x1", n).attr("x2", n).attr("y1", -1).attr("y2", r + 1);
  }
  determineDividerStatus() {
    const t = b(this.getOptions(), "heatmap", "divider", "state");
    return t !== Ei.OFF && (t === Ei.AUTO && Md.minCellDividerDimension <= this.xBandwidth && Md.minCellDividerDimension <= this.yBandwidth || t === Ei.ON);
  }
  addEventListener() {
    const t = this, { cartesianScales: n } = this.services, r = this.getOptions(), i = At(r, "tooltip.totalLabel"), s = n.getDomainIdentifier(), a = n.getRangeIdentifier(), o = n.getDomainLabel(), l = n.getRangeLabel();
    this.parent.selectAll("g.cell").on("mouseover", function(c, u) {
      const h = R(this), d = h.select("rect.heat");
      if (!d.classed("null-state")) {
        const f = yi(h.attr("transform"));
        t.parent.select("g.cell-highlight").attr(
          "transform",
          `translate(${f.x + t.translationUnits.x}, ${f.y + t.translationUnits.y})`
        ).classed("highlighter-hidden", !1), t.services.events.dispatchEvent(O.Heatmap.HEATMAP_MOUSEOVER, {
          event: c,
          element: d,
          datum: u
        }), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
          event: c,
          items: [
            {
              label: o,
              value: u[s]
            },
            {
              label: l,
              value: u[a]
            },
            {
              label: i || "Total",
              value: u.value,
              color: d.style("fill")
            }
          ]
        });
      }
    }).on("mousemove", function(c, u) {
      t.services.events.dispatchEvent(O.Heatmap.HEATMAP_MOUSEMOVE, {
        event: c,
        element: R(this),
        datum: u
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: c
      });
    }).on("click", function(c, u) {
      t.services.events.dispatchEvent(O.Heatmap.HEATMAP_CLICK, {
        event: c,
        element: R(this),
        datum: u
      });
    }).on("mouseout", function(c, u) {
      const h = R(this).select("rect.heat"), d = h.classed("null-state");
      t.parent.select("g.cell-highlight").classed("highlighter-hidden", !0), d || (t.services.events.dispatchEvent(O.Heatmap.HEATMAP_MOUSEOUT, {
        event: c,
        element: h,
        datum: u
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        event: c,
        hoveredElement: h
      }));
    });
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("rect.heat").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleAxisOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleAxisMouseOut);
  }
}
class hN extends dt {
  constructor() {
    super(...arguments), this.type = "histogram", this.renderType = K.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (s) => s[i] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getComponentContainer(), r = this.model.getOptions(), { groupIdentifier: i } = r, { groupMapsTo: s } = r.data, a = this.model.getBinnedStackedData(), o = this.services.cartesianScales.getMainXScale(), l = n.selectAll("g.bars").data(a, (u) => At(u, `0.${s}`));
    l.exit().attr("opacity", 0).remove(), l.enter().append("g").classed("bars", !0).attr("role", at.GROUP);
    const c = n.selectAll("g.bars").selectAll("path.bar").data((u) => u);
    c.exit().remove(), c.enter().append("path").merge(c).classed("bar", !0).attr(i, (u, h) => h).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "histogram-bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [et.FILL],
        dataGroupName: u[s],
        originalClassName: "bar"
      })
    ).style("fill", (u) => this.model.getFillColor(u[s])).attr("d", (u) => {
      const h = At(u, "data");
      if (!h)
        return;
      const d = o(h.x1) - o(h.x0) - 1, f = this.services.cartesianScales.getDomainValue(h.x0), p = f + d, m = this.services.cartesianScales.getRangeValue(u[0]);
      let g = this.services.cartesianScales.getRangeValue(u[1]);
      return Math.abs(g - m) > 0 && Math.abs(g - m) > r.bars.dividerSize && (this.services.cartesianScales.getOrientation() === Kt.VERTICAL ? g += 1 : g -= 1), ce(
        { x0: f, x1: p, y0: m, y1: g },
        this.services.cartesianScales.getOrientation()
      );
    }).attr("opacity", 1).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (u) => b(u, "data", u[s])), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.model.getOptions(), { groupMapsTo: n } = t.data, r = this;
    this.parent.selectAll("path.bar").on("mouseover", function(i, s) {
      const a = R(this);
      a.classed("hovered", !0);
      const o = parseFloat(At(s, "data.x0")), l = parseFloat(At(s, "data.x1")), c = r.services.cartesianScales.getRangeAxisPosition(), u = r.services.cartesianScales.getScaleLabel(c);
      r.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: i,
        hoveredElement: a,
        items: [
          {
            label: At(t, "bins.rangeLabel") || "Range",
            value: `${o}  ${l}`
          },
          {
            label: t.tooltip.groupLabel || "Group",
            value: s[n],
            class: r.model.getColorClassName({
              classNameTypes: [et.TOOLTIP],
              dataGroupName: s[n]
            })
          },
          {
            label: u,
            value: At(s, `data.${s[n]}`)
          }
        ]
      });
    }).on("mousemove", function(i) {
      r.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: i
      });
    }).on("mouseout", function() {
      R(this).classed("hovered", !1), r.services.events.dispatchEvent(O.Tooltip.HIDE);
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class dN extends Ze {
  constructor() {
    super(...arguments), this.type = "lollipop", this.renderType = K.SVG, this.handleScatterOnHover = (t) => {
      const n = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("line.line").attr("stroke-width", (s) => s[i] !== n.datum[i] ? ln.weight.unselected : ln.weight.selected);
    }, this.handleScatterOnMouseOut = () => {
      this.parent.selectAll("line.line").attr("stroke-width", ln.weight.unselected);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("line.line").transition("legend-hover-line").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-line"
        })
      ).attr("opacity", (s) => s[i] !== n.datum().name ? ln.opacity.unselected : ln.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("line.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", ln.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.model.getOptions(), { groupMapsTo: i } = r.data, { cartesianScales: s } = this.services, a = s.getMainXScale(), o = s.getMainYScale(), l = s.getDomainIdentifier(), c = (g) => s.getDomainValue(g), u = (g) => s.getRangeValue(g), h = s.getOrientation(), [d, f] = dn(
      c,
      u,
      h
    ), p = n.selectAll("line.line").data(
      this.getScatterData(),
      (g) => `${g[i]}-${g[l]}`
    );
    p.exit().attr("opacity", 0).remove();
    const m = p.enter().append("line").attr("opacity", 0).merge(p).classed("line", !0).attr(
      "class",
      (g) => this.model.getColorClassName({
        classNameTypes: [et.STROKE],
        dataGroupName: g[i],
        originalClassName: "line"
      })
    ).transition().call(
      (g) => this.services.transitions.setupTransition({
        transition: g,
        name: "lollipop-line-update-enter",
        animate: t
      })
    ).style("stroke", (g) => this.model.getFillColor(g[i], g[l], g)).attr("opacity", 1);
    h === Kt.HORIZONTAL ? m.attr("y1", f).attr("y2", f).attr("x1", a.range()[0]).attr("x2", (g) => d(g) - r.points.radius) : m.attr("x1", d).attr("x2", d).attr("y1", o.range()[0]).attr("y2", (g) => f(g) + r.points.radius), this.addScatterPointEventListeners();
  }
  // listen for when individual datapoints are hovered
  addScatterPointEventListeners() {
    this.services.events.addEventListener(
      O.Scatter.SCATTER_MOUSEOVER,
      this.handleScatterOnHover
    ), this.services.events.addEventListener(
      O.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), t.removeEventListener(O.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover), t.removeEventListener(
      O.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
}
class fN extends dt {
  constructor() {
    super(...arguments), this.type = "meter", this.renderType = K.SVG;
  }
  getStackedBounds(t, n) {
    let r = 0;
    return t.map((i, s) => s !== 0 ? (r += n(i.value), {
      ...i,
      width: Math.abs(n(i.value) - Jt.dividerWidth),
      x: r - n(i.value)
    }) : (r = n(i.value), {
      ...i,
      width: Math.abs(n(i.value) - Jt.dividerWidth),
      x: 0
    }));
  }
  render(t = !0) {
    const n = this, r = this.getComponentContainer(), i = this.getOptions(), s = b(i, "meter", "proportional"), a = this.model.getDisplayData(), o = this.model.getStatus(), { width: l } = D.getSVGElementSize(r, {
      useAttrs: !0
    }), { groupMapsTo: c } = i.data;
    let u;
    b(i, "meter", "proportional") === null ? u = 100 : u = b(i, "meter", "proportional", "total") || this.model.getMaximumDomain(this.model.getDisplayData());
    const h = Be().domain([0, u]).range([0, l]), d = this.getStackedBounds(a, h), f = b(i, "meter", "height");
    D.appendOrSelect(r, "rect.container").attr("x", 0).attr("y", 0).attr("width", l).attr(
      "height",
      f || (s ? Jt.height.proportional : Jt.height.default)
    ), D.appendOrSelect(r, "line.rangeIndicator").attr("x1", l).attr("x2", l).attr("y1", 0).attr(
      "y2",
      f || (s ? Jt.height.proportional : Jt.height.default)
    );
    const p = r.selectAll("rect.value").data(d), m = o != null && !n.model.isUserProvidedColorScaleValid() && !s ? `value status--${o}` : "value";
    p.enter().append("rect").classed("value", !0).merge(p).attr("x", (x) => x.x).attr("y", 0).attr("height", () => f || (s ? Jt.height.proportional : Jt.height.default)).attr(
      "class",
      (x) => this.model.getColorClassName({
        classNameTypes: [et.FILL],
        dataGroupName: x[c],
        originalClassName: m
      })
    ).transition().call(
      (x) => this.services.transitions.setupTransition({
        transition: x,
        name: "meter-bar-update",
        animate: t
      })
    ).attr("width", (x) => x.value > u ? h(u) : x.width).style("fill", (x) => n.model.getFillColor(x[c])).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (x) => x.value), p.exit().remove();
    const g = b(i, "meter", "peak");
    let v = g;
    g !== null && (g > u ? v = u : g < a[0].value && (v = a[0].value > u ? u : a[0].value));
    const y = r.selectAll("line.peak").data(v == null ? [] : [v]);
    y.enter().append("line").classed("peak", !0).merge(y).attr("y1", 0).attr("y2", () => f || (s ? Jt.height.proportional : Jt.height.default)).transition().call(
      (x) => this.services.transitions.setupTransition({
        transition: x,
        name: "peak-line-update",
        animate: t
      })
    ).attr("x1", (x) => h(x)).attr("x2", (x) => h(x)).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "peak").attr("aria-label", (x) => x), y.exit().remove(), this.services.domUtils.setSVGMaxHeight(), this.addEventListeners();
  }
  // add event listeners for tooltips on proportional meter bars
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this, i = b(t, "meter", "proportional");
    this.parent.selectAll("rect.value").on("mouseover", function(s, a) {
      const o = R(this);
      r.services.events.dispatchEvent(O.Meter.METER_MOUSEOVER, {
        event: s,
        element: o,
        datum: a
      }), i && (o.classed("hovered", !0), r.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: s,
        hoveredElement: o,
        items: [
          {
            label: a[n],
            value: a.value
          }
        ]
      }));
    }).on("mousemove", function(s, a) {
      const o = R(this);
      r.services.events.dispatchEvent(O.Meter.METER_MOUSEMOVE, {
        event: s,
        element: o,
        datum: a
      }), i && r.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      r.services.events.dispatchEvent(O.Meter.METER_CLICK, {
        event: s,
        element: R(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const o = R(this);
      r.services.events.dispatchEvent(O.Meter.METER_MOUSEOUT, {
        event: s,
        element: o,
        datum: a
      }), i && (o.classed("hovered", !1), r.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: o
      }));
    });
  }
  destroy() {
    this.parent.selectAll("rect.value").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
  }
}
class pN extends dt {
  constructor() {
    super(...arguments), this.type = "radar", this.renderType = K.SVG, this.getLabelDimensions = (t) => {
      const n = D.appendOrSelect(this.getComponentContainer(), "g.tmp-tick"), r = D.appendOrSelect(n, "text").text(t), { width: i, height: s } = D.getSVGElementSize(r.node(), { useBBox: !0 });
      return n.remove(), { width: i, height: s };
    }, this.normalizeFlatData = (t) => {
      const n = this.getOptions(), { angle: r, value: i } = b(n, "radar", "axes"), s = b(n, "data", "groupMapsTo"), a = pR(
        this.uniqueKeys.map((o) => this.uniqueGroups.map((l) => ({
          [r]: o,
          [s]: l,
          [i]: null
        })))
      );
      return rt(a, t);
    }, this.normalizeGroupedData = (t) => {
      const n = this.getOptions(), { angle: r, value: i } = b(n, "radar", "axes"), s = b(n, "data", "groupMapsTo");
      return t.map(({ name: a, data: o }) => {
        const l = this.uniqueKeys.map((c) => ({
          [s]: a,
          [r]: c,
          [i]: null
        }));
        return { name: a, data: rt(l, o) };
      });
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("g.blobs path").transition("legend-hover-blob").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-blob"
        })
      ).style("fill-opacity", (r) => r.name !== n.datum().name ? Pn.opacity.unselected : Pn.opacity.selected).style("stroke-opacity", (r) => r.name !== n.datum().name ? Pn.opacity.unselected : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g.blobs path").transition("legend-mouseout-blob").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-blob"
        })
      ).style("fill-opacity", Pn.opacity.selected).style("stroke-opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer(), { width: r, height: i } = D.getSVGElementSize(n, {
      useAttrs: !0
    }), s = this.model.getData(), a = this.model.getGroupedData(), o = this.getOptions(), l = b(o, "data", "groupMapsTo"), c = b(o, "radar", "axes", "value"), { angle: u, value: h } = b(o, "radar", "axes"), { xLabelPadding: d, yLabelPadding: f, yTicksNumber: p, minRange: m, xAxisRectHeight: g } = Pn;
    this.uniqueKeys = Array.from(new Set(s.map((M) => M[u]))), this.uniqueGroups = Array.from(new Set(s.map((M) => M[l]))), this.fullDataNormalized = this.normalizeFlatData(s), this.groupedDataNormalized = this.normalizeGroupedData(a);
    const v = 2 * (this.getLabelDimensions(this.uniqueKeys[0]).height + f), y = (Math.min(r, i) - v) / 2;
    if (y <= 0)
      return;
    const x = Xi().domain(this.fullDataNormalized.map((M) => M[u])).range([0, 2 * Math.PI].map((M) => M - Math.PI / 2)), S = Ln(this.fullDataNormalized.map((M) => M[h])), _ = Be().domain([
      S >= 0 ? 0 : S,
      qn(this.fullDataNormalized.map((M) => M[h]))
    ]).range([m, y]).nice(p), E = _.ticks(p), T = (M) => this.model.getFillColor(M), k = hS().angle((M) => x(M[u]) + Math.PI / 2).radius((M) => _(M[h])).curve($g), N = this.uniqueKeys.map((M) => {
      const A = this.getLabelDimensions(M).width, w = kD(
        x(M),
        y
      );
      return A + w;
    }), L = {
      x: qn(N) + d,
      y: i / 2
    }, C = D.appendOrSelect(n, "g.y-axes").attr("role", at.GROUP).selectAll("path").data(E, (M) => M), V = (M) => this.uniqueKeys.map((A) => ({ [u]: A, [h]: M }));
    C.join(
      (M) => M.append("path").attr("opacity", 0).attr("transform", `translate(${L.x}, ${L.y})`).attr("fill", "none").call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_y_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("d", (w) => k(V(w)))
      ),
      (M) => M.call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_y_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${L.x}, ${L.y})`).attr("d", (w) => k(V(w)))
      ),
      (M) => M.call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_y_axes_exit",
            animate: t
          })
        ).attr("d", (w) => k(V(w))).attr("opacity", 0).remove()
      )
    ), D.appendOrSelect(n, "g.x-axes").attr("role", at.GROUP).selectAll("line").data(this.uniqueKeys, (M) => M).join(
      (M) => M.append("line").attr("opacity", 0).attr("class", (A) => `x-axis-${pr(A)}`).attr("stroke-dasharray", "0").attr("x1", (A) => Vt(x(A), 0, L).x).attr("y1", (A) => Vt(x(A), 0, L).y).attr("x2", (A) => Vt(x(A), 0, L).x).attr("y2", (A) => Vt(x(A), 0, L).y).call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_x_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", (w) => Vt(x(w), _.range()[0], L).x).attr("y1", (w) => Vt(x(w), _.range()[0], L).y).attr("x2", (w) => Vt(x(w), _.range()[1], L).x).attr("y2", (w) => Vt(x(w), _.range()[1], L).y)
      ),
      (M) => M.call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_x_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", (w) => Vt(x(w), _.range()[0], L).x).attr("y1", (w) => Vt(x(w), _.range()[0], L).y).attr("x2", (w) => Vt(x(w), _.range()[1], L).x).attr("y2", (w) => Vt(x(w), _.range()[1], L).y)
      ),
      (M) => M.call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_x_axes_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), D.appendOrSelect(n, "g.x-labels").attr("role", at.GROUP).selectAll("text").data(this.uniqueKeys).join(
      (M) => M.append("text").text((A) => A).attr("opacity", 0).attr(
        "x",
        (A) => Vt(x(A), _.range()[1] + d, L).x
      ).attr(
        "y",
        (A) => Vt(x(A), _.range()[1] + d, L).y
      ).style("text-anchor", (A) => Vd(x(A)).textAnchor).style(
        "dominant-baseline",
        (A) => Vd(x(A)).dominantBaseline
      ).call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_x_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (M) => M.call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_x_labels_update",
            animate: t
          })
        ).attr("opacity", 1).attr(
          "x",
          (w) => Vt(x(w), _.range()[1] + d, L).x
        ).attr(
          "y",
          (w) => Vt(x(w), _.range()[1] + d, L).y
        ).end().finally(() => {
          const w = b(o, "radar", "alignment"), P = this.getAlignmentXOffset(w, n, this.getParent());
          n.attr("x", P);
        })
      ),
      (M) => M.call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_x_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), D.appendOrSelect(n, "g.blobs").attr("role", at.GROUP).selectAll("path").data(this.groupedDataNormalized, (M) => M.name).join(
      (M) => M.append("path").attr(
        "class",
        (A) => this.model.getColorClassName({
          classNameTypes: [et.FILL, et.STROKE],
          dataGroupName: A.name,
          originalClassName: "blob"
        })
      ).attr("role", at.GRAPHICS_SYMBOL).attr("aria-label", (A) => A.name).attr("opacity", 0).attr(
        "transform",
        t ? () => `translate(${L.x}, ${L.y}) scale(${1 + Math.random() * 0.35})` : `translate(${L.x}, ${L.y})`
      ).style("fill", (A) => T(A.name)).style("fill-opacity", Pn.opacity.selected).style("stroke", (A) => T(A.name)).call((A) => {
        const w = A.transition().call(
          (P) => this.services.transitions.setupTransition({
            transition: P,
            name: "radar_blobs_enter",
            animate: t
          })
        );
        t && w.delay(() => Math.random() * 30).attr("transform", `translate(${L.x}, ${L.y})`), w.attr("opacity", 1).attr("d", (P) => k(P.data));
      }),
      (M) => (M.attr(
        "class",
        (A) => this.model.getColorClassName({
          classNameTypes: [et.FILL, et.STROKE],
          dataGroupName: A.name,
          originalClassName: "blob"
        })
      ).style("fill", (A) => T(A.name)).style("stroke", (A) => T(A.name)), M.call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_blobs_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${L.x}, ${L.y})`).attr("d", (w) => k(w.data))
      ), M),
      (M) => M.call((A) => {
        const w = A.transition().call(
          (P) => this.services.transitions.setupTransition({
            transition: P,
            name: "radar_blobs_exit",
            animate: t
          })
        );
        t && w.delay(() => Math.random() * 30).attr(
          "transform",
          () => `translate(${L.x}, ${L.y}) scale(${1 + Math.random() * 0.35})`
        ), w.attr("opacity", 0).remove();
      })
    ), D.appendOrSelect(n, "g.dots").attr("role", at.GROUP).selectAll("circle").data(this.fullDataNormalized.filter((M) => b(M, h) !== null)).join(
      (M) => M.append("circle").attr("role", at.GRAPHICS_SYMBOL).attr("aria-label", (A) => A[c]),
      (M) => M,
      (M) => M.remove()
    ).attr(
      "class",
      (M) => this.model.getColorClassName({
        classNameTypes: [et.FILL],
        dataGroupName: M[l],
        originalClassName: pr(M[u])
      })
    ).attr("cx", (M) => Vt(x(M[u]), _(M[h]), L).x).attr("cy", (M) => Vt(x(M[u]), _(M[h]), L).y).attr("r", 0).attr("opacity", 0).style("fill", (M) => T(M[l])), D.appendOrSelect(n, "g.x-axes-rect").attr("role", at.GROUP).selectAll("rect").data(this.uniqueKeys).join(
      (M) => M.append("rect"),
      (M) => M,
      (M) => M.remove()
    ).attr("x", L.x).attr("y", L.y - g / 2).attr("width", _.range()[1]).attr("height", g).style("fill", "red").style("fill-opacity", 0).attr("transform", (M) => `rotate(${Vm(x(M))}, ${L.x}, ${L.y})`), D.appendOrSelect(n, "g.y-labels").attr("role", at.GROUP).selectAll("text").data(Ne(E)).join(
      (M) => M.append("text").attr("opacity", 0).text((A) => A).attr(
        "x",
        (A) => Vt(-Math.PI / 2, _(A), L).x + f
      ).attr("y", (A) => Vt(-Math.PI / 2, _(A), L).y).style("text-anchor", "start").style("dominant-baseline", "middle").call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_y_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (M) => M.call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_y_labels_update",
            animate: t
          })
        ).text((w) => w).attr("opacity", 1).attr(
          "x",
          (w) => Vt(-Math.PI / 2, _(w), L).x + f
        ).attr("y", (w) => Vt(-Math.PI / 2, _(w), L).y)
      ),
      (M) => M.call(
        (A) => A.transition().call(
          (w) => this.services.transitions.setupTransition({
            transition: w,
            name: "radar_y_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), this.addEventListeners();
  }
  getAlignmentXOffset(t, n, r) {
    const i = D.getSVGElementSize(n, {
      useBBox: !0
    }), { width: s } = D.getSVGElementSize(r, {
      useAttrs: !0
    });
    let a = 0;
    return t === Yt.CENTER ? a = Math.floor((s - i.width) / 2) : t === Yt.RIGHT && (a = s - i.width), a;
  }
  destroy() {
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  addEventListeners() {
    const t = this, {
      axes: { angle: n }
    } = b(this.getOptions(), "radar");
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", function(r, i) {
      const s = R(this);
      t.services.events.dispatchEvent(O.Radar.X_AXIS_MOUSEOVER, {
        event: r,
        element: s,
        datum: i
      });
      const a = t.parent.select(`.x-axes .x-axis-${pr(i)}`), o = t.parent.selectAll(`.dots circle.${pr(i)}`), l = t.model.getActiveDataGroupNames(), c = t.getOptions(), { groupMapsTo: u } = c.data, h = b(c, "radar", "axes", "value");
      a.classed("hovered", !0).attr("stroke-dasharray", "4 4"), o.classed("hovered", !0).attr(
        "opacity",
        (f) => l.indexOf(f[u]) !== -1 ? 1 : 0
      ).attr("r", Pn.dotsRadius);
      const d = t.fullDataNormalized.filter(
        (f) => f[n] === i && l.indexOf(f[u]) !== -1
      );
      t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: r,
        hoveredElement: s,
        items: d.filter((f) => typeof f[h] == "number").map((f) => ({
          label: f[u],
          value: f[h],
          color: t.model.getFillColor(f[u]),
          class: t.model.getColorClassName({
            classNameTypes: [et.TOOLTIP],
            dataGroupName: f[u]
          })
        }))
      });
    }).on("mousemove", function(r, i) {
      const s = R(this);
      t.services.events.dispatchEvent(O.Radar.X_AXIS_MOUSEMOVE, {
        event: r,
        element: s,
        datum: i
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, i) {
      t.services.events.dispatchEvent(O.Radar.X_AXIS_CLICK, {
        event: r,
        element: R(this),
        datum: i
      });
    }).on("mouseout", function(r, i) {
      const s = R(this), a = t.parent.select(`.x-axes .x-axis-${pr(i)}`), o = t.parent.selectAll(`.dots circle.${pr(i)}`);
      a.classed("hovered", !1).attr("stroke-dasharray", "0"), o.classed("hovered", !1).attr("opacity", 0).attr("r", 0), t.services.events.dispatchEvent(O.Radar.X_AXIS_MOUSEOUT, {
        event: r,
        element: s,
        datum: i
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE);
    });
  }
}
class Ev extends ou {
  constructor() {
    super(...arguments), this.type = "simple-bar", this.renderType = K.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getOptions(), { groupMapsTo: r } = n.data, i = this.getComponentContainer({ withinChartClip: !0 }), s = this.model.getDisplayData(this.configs.groups), a = this.services.cartesianScales.getOrientation(), o = i.selectAll("path.bar").data(s, (l) => l[r]);
    o.exit().attr("opacity", 0).remove(), o.enter().append("path").attr("opacity", 0).merge(o).classed("bar", !0).attr("width", this.getBarWidth.bind(this)).transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (l) => this.model.getColorClassName({
        classNameTypes: [et.FILL],
        dataGroupName: l[r],
        originalClassName: "bar"
      })
    ).style("fill", (l) => this.model.getFillColor(l[r])).attr("d", (l) => {
      const c = this.services.cartesianScales.getRangeIdentifier(), u = this.getBarWidth(), h = l[c], d = this.services.cartesianScales.getDomainValue(l) - u / 2, f = d + u;
      let p, m;
      if (Array.isArray(h) && h.length === 2)
        p = this.services.cartesianScales.getRangeValue(h[0]), m = this.services.cartesianScales.getRangeValue(h[1]);
      else {
        const v = this.services.cartesianScales.getRangeScale().domain()[0];
        p = this.services.cartesianScales.getRangeValue(Math.max(0, v)), m = this.services.cartesianScales.getRangeValue(l);
      }
      const g = Math.abs(m - p);
      if (g !== 0 && g < 2 && (h > 0 && a === Kt.VERTICAL || h < 0 && a === Kt.HORIZONTAL ? m = p - 2 : m = p + 2), !this.isOutsideZoomedDomain(d, f))
        return ce({ x0: d, x1: f, y0: p, y1: m }, a);
    }).attr("opacity", 1).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (l) => l.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.bar").on("mouseover", function(n, r) {
      const i = R(this);
      i.classed("hovered", !0), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOVER, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        data: [r]
      });
    }).on("mousemove", function(n, r) {
      t.services.events.dispatchEvent(O.Bar.BAR_MOUSEMOVE, {
        event: n,
        element: R(this),
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(O.Bar.BAR_CLICK, {
        event: n,
        element: R(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = R(this);
      i.classed("hovered", !1), t.services.events.dispatchEvent(O.Bar.BAR_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class gN extends ue {
  constructor() {
    super(...arguments), this.type = "skeleton-lines";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = b(this.getOptions(), "data", "loading"), r = !b(this.getOptions(), "grid", "x", "enabled") && !b(this.getOptions(), "grid", "y", "enabled") && !b(this.getOptions(), "axes", "bottom", "visible") && !b(this.getOptions(), "axes", "left", "visible");
    n && !r ? super.renderGridSkeleton(n) : n && r ? this.renderSparklineSkeleton(n) : this.removeSkeleton();
  }
  renderSparklineSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawSparkline(t), this.updateBackdropStyle(), t && this.setShimmerEffect("shimmer-lines");
  }
  drawSparkline(t) {
    const n = this.backdrop.attr("width"), r = [100], i = D.appendOrSelect(this.backdrop, "g.y.skeleton"), s = i.selectAll("line").data(r);
    s.enter().append("line").merge(s).attr("x1", 0).attr("x2", n).attr("y1", (a) => a).attr("y2", (a) => a), i.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  updateBackdropStyle() {
    const t = this.parent;
    this.backdrop = D.appendOrSelect(t, "svg.chart-skeleton.DAII"), D.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop").classed("shimmer-effect-lines", !1).classed("shimmer-effect-sparkline", !0).style("stroke", null);
  }
}
class Sv extends dt {
  constructor() {
    super(...arguments), this.type = "area-stacked", this.renderType = K.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, r = this.getOptions(), { groupMapsTo: i } = r.data;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (s) => this.services.transitions.setupTransition({
          transition: s,
          name: "legend-hover-area"
        })
      ).attr("opacity", (s) => b(s, 0, i) !== n.datum().name ? cn.opacity.unselected : cn.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", cn.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this, i = this.getOptions(), { groupMapsTo: s } = i.data, a = Object.keys(i.axes).some((f) => i.axes[f].percentage), o = this.model.getStackedData({
      percentage: a,
      groups: this.configs.groups
    }), l = b(o, 0, 0), c = this.services.cartesianScales.getDomainAxisPosition({ datum: l }), u = this.services.cartesianScales.getRangeAxisPosition({ datum: l }), h = this.services.cartesianScales.getScaleByPosition(u), d = n.selectAll("path.area").data(o, (f) => b(f, 0, s));
    this.areaGenerator = Nc().x(
      (f) => this.services.cartesianScales.getValueThroughAxisPosition(
        c,
        f.data.sharedStackKey
      )
    ).y0((f) => h(f[0])).y1((f) => h(f[1])).curve(this.services.curves.getD3Curve()), d.exit().attr("opacity", 0).remove(), d.enter().append("path").attr("opacity", 0).merge(d).data(o, (f) => b(f, 0, s)).attr("class", "area").attr(
      "class",
      (f) => this.model.getColorClassName({
        classNameTypes: [et.FILL],
        dataGroupName: b(f, 0, s),
        originalClassName: "area"
      })
    ).style("fill", (f) => r.model.getFillColor(b(f, 0, s))).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "area").attr("aria-label", (f) => b(f, 0, s)).transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", cn.opacity.selected).attr("d", this.areaGenerator);
  }
}
class Ov extends ou {
  constructor() {
    super(...arguments), this.type = "stacked-bar", this.renderType = K.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.model.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = this.model.getStackedData({
      groups: this.configs.groups,
      divergent: !0
    }), a = this.model.getActiveDataGroupNames(), o = n.selectAll("g.bars").data(s, (c) => b(c, 0, i));
    o.exit().attr("opacity", 0).remove(), o.enter().append("g").classed("bars", !0).attr("role", at.GROUP).attr("data-name", "bars");
    const l = n.selectAll("g.bars").selectAll("path.bar").data(
      (c) => c,
      (c) => c.data.sharedStackKey
    );
    l.exit().remove(), l.enter().append("path").merge(l).classed("bar", !0).transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (c) => this.model.getColorClassName({
        classNameTypes: [et.FILL],
        dataGroupName: c[i],
        originalClassName: "bar"
      })
    ).style("fill", (c) => this.model.getFillColor(c[i])).attr("d", (c) => {
      const u = c.data.sharedStackKey, h = this.getBarWidth(), d = this.services.cartesianScales.getDomainValue(u) - h / 2, f = d + h, p = this.services.cartesianScales.getRangeValue(c[0]);
      let m = this.services.cartesianScales.getRangeValue(c[1]);
      if (!this.isOutsideZoomedDomain(d, f)) {
        if (Math.abs(m - p) > 0 && Math.abs(m - p) > r.bars.dividerSize) {
          const g = c[0] < 0 && c[1] <= 0;
          g && a.length > 1 ? this.services.cartesianScales.getOrientation() === Kt.VERTICAL ? m += c[1] === 0 ? 2 : 1 : m -= 1 : g || (this.services.cartesianScales.getOrientation() === Kt.VERTICAL ? m += 1 : m -= 1);
        }
        return ce(
          { x0: d, x1: f, y0: p, y1: m },
          this.services.cartesianScales.getOrientation()
        );
      }
    }).attr("opacity", 1).attr("role", at.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (c) => c[1] - c[0]), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this;
    this.parent.selectAll("path.bar").on("mouseover", function(i, s) {
      const a = R(this);
      a.classed("hovered", !0), r.services.events.dispatchEvent(O.Bar.BAR_MOUSEOVER, {
        event: i,
        element: a,
        datum: s
      });
      let o = r.model.getDisplayData(r.configs.groups).find((l) => {
        const c = r.services.cartesianScales.getDomainIdentifier(l), u = r.services.cartesianScales.getRangeIdentifier(l);
        return l[u] === s.data[s[n]] && l[c].toString() === s.data.sharedStackKey && l[n] === s[n];
      });
      if (o === void 0) {
        const l = r.services.cartesianScales.getDomainIdentifier(), c = r.services.cartesianScales.getRangeIdentifier();
        o = {
          [l]: s.data.sharedStackKey,
          [c]: s.data[s[n]],
          [n]: s[n]
        };
      }
      r.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: i,
        hoveredElement: a,
        data: [o]
      });
    }).on("mousemove", function(i, s) {
      const a = R(this);
      r.services.events.dispatchEvent(O.Bar.BAR_MOUSEMOVE, {
        event: i,
        element: a,
        datum: s
      }), r.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function(i, s) {
      r.services.events.dispatchEvent(O.Bar.BAR_CLICK, {
        event: i,
        element: R(this),
        datum: s
      });
    }).on("mouseout", function(i, s) {
      const a = R(this);
      a.classed("hovered", !1), r.services.events.dispatchEvent(O.Bar.BAR_MOUSEOUT, {
        event: i,
        element: a,
        datum: s
      }), r.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  getBarWidth() {
    const t = this.getOptions();
    if (b(t, "bars", "width"))
      return t.bars.width;
    const n = this.services.cartesianScales.getMainXScale(), r = D.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width, i = this.model.getStackKeys().length, s = b(t, "bars", "spacingFactor");
    return n.step ? Math.min(t.bars.maxWidth, n.step() / 2) : Math.min(t.bars.maxWidth, r * s / i);
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Tv extends Ze {
  constructor() {
    super(...arguments), this.type = "scatter-stacked", this.renderType = K.SVG;
  }
  render(t) {
    if (!b(this.getOptions(), "points", "enabled"))
      return;
    const n = this.getComponentContainer({ withinChartClip: !0 }), r = this.getOptions(), { groupMapsTo: i } = r.data, s = Object.keys(r.axes).some((u) => r.axes[u].percentage), a = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: s
    }), o = n.selectAll("g.dots").data(a, (u) => b(u, 0, i));
    o.exit().attr("opacity", 0).remove();
    const l = o.enter().append("g").classed("dots", !0).attr("role", at.GROUP).merge(o).selectAll("circle.dot").data((u) => u);
    l.exit().attr("opacity", 0).remove();
    const c = l.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(l).datum((u) => {
      const h = u[i], d = this.services.cartesianScales.getDomainIdentifier(u), f = this.services.cartesianScales.getRangeIdentifier(u);
      return {
        [i]: h,
        [d]: u.data.sharedStackKey,
        [f]: u[1]
      };
    });
    this.styleCircles(c, t), this.addEventListeners();
  }
  getTooltipData(t, n) {
    const r = this.getOptions(), { groupMapsTo: i } = r.data, s = Object.keys(r.axes).some((l) => r.axes[l].percentage), a = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: s
    }), o = [];
    return a.forEach((l, c) => {
      l.forEach((u, h) => {
        const d = u[i], f = u.data.sharedStackKey;
        let p = u.data[d];
        const m = u[1], g = this.services.cartesianScales.getDomainIdentifier(u), v = this.services.cartesianScales.getRangeIdentifier(u);
        p != null && t === this.services.cartesianScales.getDomainValue(f) && n === this.services.cartesianScales.getRangeValue(m) && (s && (p = this.model.getStackedData({
          groups: this.configs.groups
        })[c][h].data[d]), p !== null && o.push({
          [i]: d,
          [g]: f,
          [v]: p
        }));
      });
    }), this.model.getDisplayData(this.configs.groups).filter((l) => {
      const c = this.services.cartesianScales.getDomainIdentifier(l), u = this.services.cartesianScales.getRangeIdentifier(l);
      return o.find((h) => h[i] == l[i] && h[c] == l[c] && h[u] == l[u]) !== void 0;
    });
  }
}
const mr = 6;
class mN extends dt {
  constructor() {
    super(...arguments), this.type = "tree", this.renderType = K.SVG;
  }
  getLongestLabel(t) {
    let n = "";
    return t.forEach((r) => {
      const i = r.children ? this.getLongestLabel(r.children) : "";
      (i.length > n.length || r.name.length > n.length) && (n = i.length > r.name.length ? i : r.name);
    }), n;
  }
  getMockLabelWidth(t, n) {
    const r = t.append("text").attr("dy", "0.31em").attr("x", 0).attr("text-anchor", "end").text(n), { width: i } = D.getSVGElementSize(r.node(), {
      useBBox: !0
    });
    return r.remove(), i;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const n = this.getComponentContainer();
    n.html("");
    const { width: r, height: i } = D.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (r < 1 || i < 1)
      return;
    const s = this.model.getOptions(), a = this.model.getDisplayData(), o = b(s, "tree", "rootTitle") || "Tree", l = this.getMockLabelWidth(n, o), c = this.getLongestLabel(a), u = this.getMockLabelWidth(n, c), h = {
      top: 0,
      right: 0,
      bottom: 0,
      left: l > 0 ? l + mr : 30 - mr
    }, d = Yi({
      name: o,
      children: a
    }), f = 10, p = r / 6, m = (E) => {
      const T = d.descendants().reverse(), k = d.links();
      let N = d, L = d;
      d.eachBefore((I) => {
        I.x < N.x && (N = I), I.x > L.x && (L = I);
      });
      const C = L.x - N.x, V = n.transition().call(
        (I) => this.services.transitions.setupTransition({
          transition: I,
          name: "tree-update-viewbox",
          animate: !0
        })
      ).attr("viewBox", [-h.left, N.x, r, C].join(" ")), M = _.selectAll("g").data(T, (I) => I.id), A = this, w = M.enter().append("g").attr("transform", () => `translate(${E.y0},${E.x0})`).attr(
        "class",
        (I) => I.depth !== 0 && I.children && I.children.length > 0 ? "clickable" : null
      ).on("mouseover", function(I, B) {
        A.services.events.dispatchEvent(O.Tree.NODE_MOUSEOVER, {
          event: I,
          element: R(this),
          datum: B
        });
      }).on("click", function(I, B) {
        B.depth !== 0 && (B.children = B.children ? null : B._children, m(B)), A.services.events.dispatchEvent(O.Tree.NODE_CLICK, {
          event: I,
          element: R(this),
          datum: B
        });
      }).on("mouseout", function(I, B) {
        A.services.events.dispatchEvent(O.Tree.NODE_MOUSEOUT, {
          event: I,
          element: R(this),
          datum: B
        });
      });
      w.append("circle").attr("r", 2.5).attr("class", (I) => I._children ? "parent" : "child").attr("stroke-width", 10), w.append("text").attr("dy", "0.31em").attr("x", (I) => I._children ? -mr : mr).attr("text-anchor", (I) => I._children ? "end" : "start").text((I) => I.data.name).clone(!0).attr("class", "text-stroke").lower(), M.merge(w).transition(V).attr("transform", (I) => `translate(${I.y},${I.x})`).attr("fill-opacity", 1).attr("stroke-opacity", 1), M.exit().transition(V).remove().attr("transform", () => `translate(${E.y},${E.x})`).attr("fill-opacity", 0).attr("stroke-opacity", 0);
      const P = S.selectAll("path").data(k, (I) => I.target.id), U = P.enter().append("path").attr("d", () => {
        const I = { x: E.x0, y: E.y0 };
        return x({ source: I, target: I });
      });
      P.merge(U).transition(V).attr("d", x), P.exit().transition(V).remove().attr("d", () => {
        const I = { x: E.x, y: E.y };
        return x({ source: I, target: I });
      }), d.eachBefore((I) => {
        I.x0 = I.x, I.y0 = I.y;
      });
    }, g = d.descendants(), v = g[g.length - 1].depth, y = b(s, "tree", "type") === lc.DENDROGRAM ? Cw().size([
      i,
      r - u - v * mr - l
    ]) : g_().nodeSize([f, p]).size([
      i,
      r - u - v * mr - l
    ]), x = vS().x((E) => E.y).y((E) => E.x);
    d.x0 = p / 2, d.y0 = 0, d.descendants().forEach((E, T) => {
      E.id = T, E._children = E.children;
    }), y(d), n.attr("viewBox", [-h.left, -h.top, r, f]).style("user-select", "none");
    const S = n.append("g").attr("class", "links"), _ = n.append("g").attr("class", "nodes");
    m(d);
  }
}
var vN = "#000000", yN = "#ffffff", xN = "#fcf4d6", bN = "#fddc69", wN = "#f1c21b", _N = "#d2a106", EN = "#b28600", SN = "#8e6a00", ON = "#684e00", TN = "#483700", MN = "#302400", CN = "#1c1500", $N = {
  10: xN,
  20: bN,
  30: wN,
  40: _N,
  50: EN,
  60: SN,
  70: ON,
  80: TN,
  90: MN,
  100: CN
}, AN = "#fff2e8", LN = "#ffd9be", DN = "#ffb784", kN = "#ff832b", RN = "#eb6200", IN = "#ba4e00", NN = "#8a3800", PN = "#5e2900", UN = "#3e1a00", BN = "#231000", VN = {
  10: AN,
  20: LN,
  30: DN,
  40: kN,
  50: RN,
  60: IN,
  70: NN,
  80: PN,
  90: UN,
  100: BN
}, HN = "#fff1f1", FN = "#ffd7d9", GN = "#ffb3b8", zN = "#ff8389", jN = "#fa4d56", WN = "#da1e28", qN = "#a2191f", YN = "#750e13", XN = "#520408", ZN = "#2d0709", KN = {
  10: HN,
  20: FN,
  30: GN,
  40: zN,
  50: jN,
  60: WN,
  70: qN,
  80: YN,
  90: XN,
  100: ZN
}, QN = "#fff0f7", JN = "#ffd6e8", tP = "#ffafd2", eP = "#ff7eb6", nP = "#ee5396", rP = "#d02670", iP = "#9f1853", sP = "#740937", aP = "#510224", oP = "#2a0a18", lP = {
  10: QN,
  20: JN,
  30: tP,
  40: eP,
  50: nP,
  60: rP,
  70: iP,
  80: sP,
  90: aP,
  100: oP
}, cP = "#f6f2ff", uP = "#e8daff", hP = "#d4bbff", dP = "#be95ff", fP = "#a56eff", pP = "#8a3ffc", gP = "#6929c4", mP = "#491d8b", vP = "#31135e", yP = "#1c0f30", xP = {
  10: cP,
  20: uP,
  30: hP,
  40: dP,
  50: fP,
  60: pP,
  70: gP,
  80: mP,
  90: vP,
  100: yP
}, bP = "#edf5ff", wP = "#d0e2ff", _P = "#a6c8ff", EP = "#78a9ff", SP = "#4589ff", OP = "#0f62fe", TP = "#0043ce", MP = "#002d9c", CP = "#001d6c", $P = "#001141", AP = {
  10: bP,
  20: wP,
  30: _P,
  40: EP,
  50: SP,
  60: OP,
  70: TP,
  80: MP,
  90: CP,
  100: $P
}, LP = "#e5f6ff", DP = "#bae6ff", kP = "#82cfff", RP = "#33b1ff", IP = "#1192e8", NP = "#0072c3", PP = "#00539a", UP = "#003a6d", BP = "#012749", VP = "#061727", HP = {
  10: LP,
  20: DP,
  30: kP,
  40: RP,
  50: IP,
  60: NP,
  70: PP,
  80: UP,
  90: BP,
  100: VP
}, FP = "#d9fbfb", GP = "#9ef0f0", zP = "#3ddbd9", jP = "#08bdba", WP = "#009d9a", qP = "#007d79", YP = "#005d5d", XP = "#004144", ZP = "#022b30", KP = "#081a1c", QP = {
  10: FP,
  20: GP,
  30: zP,
  40: jP,
  50: WP,
  60: qP,
  70: YP,
  80: XP,
  90: ZP,
  100: KP
}, JP = "#defbe6", tU = "#a7f0ba", eU = "#6fdc8c", nU = "#42be65", rU = "#24a148", iU = "#198038", sU = "#0e6027", aU = "#044317", oU = "#022d0d", lU = "#071908", cU = {
  10: JP,
  20: tU,
  30: eU,
  40: nU,
  50: rU,
  60: iU,
  70: sU,
  80: aU,
  90: oU,
  100: lU
}, uU = "#f2f4f8", hU = "#dde1e6", dU = "#c1c7cd", fU = "#a2a9b0", pU = "#878d96", gU = "#697077", mU = "#4d5358", vU = "#343a3f", yU = "#21272a", xU = "#121619", bU = {
  10: uU,
  20: hU,
  30: dU,
  40: fU,
  50: pU,
  60: gU,
  70: mU,
  80: vU,
  90: yU,
  100: xU
}, wU = "#f4f4f4", _U = "#e0e0e0", EU = "#c6c6c6", SU = "#a8a8a8", OU = "#8d8d8d", TU = "#6f6f6f", MU = "#525252", CU = "#393939", $U = "#262626", AU = "#161616", LU = {
  10: wU,
  20: _U,
  30: EU,
  40: SU,
  50: OU,
  60: TU,
  70: MU,
  80: CU,
  90: $U,
  100: AU
}, DU = "#f7f3f2", kU = "#e5e0df", RU = "#cac5c4", IU = "#ada8a8", NU = "#8f8b8b", PU = "#726e6e", UU = "#565151", BU = "#3c3838", VU = "#272525", HU = "#171414", FU = {
  10: DU,
  20: kU,
  30: RU,
  40: IU,
  50: NU,
  60: PU,
  70: UU,
  80: BU,
  90: VU,
  100: HU
}, pf = {
  black: {
    100: vN
  },
  blue: AP,
  coolGray: bU,
  cyan: HP,
  gray: LU,
  green: cU,
  magenta: lP,
  orange: VN,
  purple: xP,
  red: KN,
  teal: QP,
  warmGray: FU,
  white: {
    0: yN
  },
  yellow: $N
};
const GU = (e) => {
  if (!e)
    return null;
  for (const t of Object.keys(pf)) {
    const n = pf[t];
    for (const r of Object.keys(n))
      if (n[+r] === e)
        return r;
  }
  return null;
}, gf = function() {
  const e = R(this.parentNode).select("rect.leaf"), t = getComputedStyle(e.node(), null).getPropertyValue(
    "fill"
  ), n = pn(t);
  let r;
  if (n && (r = GU(n ? n.hex() : null)), r == null) {
    const i = mc(n).l;
    r = Math.abs(i * 100 - 100);
  }
  return r > 50 ? "white" : "black";
};
let zU = 0;
class jU extends dt {
  constructor() {
    super(...arguments), this.type = "treemap", this.renderType = K.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail;
      this.parent.selectAll("g[data-name='leaf']").transition("legend-hover-treemap").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-treemap"
        })
      ).attr(
        "opacity",
        (r) => r.parent.data.name === n.datum().name ? 1 : 0.3
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g[data-name='leaf']").transition("legend-mouseout-treemap").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-treemap"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this.getComponentContainer();
    this.model.getData();
    const r = this.model.getDisplayData(), i = this.model.getOptions(), s = b(window, "location"), { width: a, height: o } = D.getSVGElementSize(n, {
      useAttrs: !0
    }), l = Yi({
      name: i.title || "Treemap",
      children: r
    }).sum((f) => f.value).sort((f, p) => p.value - f.value), c = b_().size([a, o]).paddingInner(1).paddingOuter(0).round(!0)(
      l
    ), u = n.selectAll("g[data-name='leaf']").data(c.leaves(), (f) => f.data.name);
    u.exit().attr("opacity", 0).remove();
    const h = u.enter().append("g").attr("data-name", "leaf").attr("data-uid", () => zU++).merge(u);
    h.attr("data-name", "leaf").transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "treemap-group-update",
        animate: t
      })
    ).attr("transform", (f) => `translate(${f.x0},${f.y0})`);
    const d = h.selectAll("rect.leaf").data((f) => [f]);
    d.exit().attr("width", 0).attr("height", 0).remove(), d.enter().append("rect").classed("leaf", !0).merge(d).attr("width", 0).attr("height", 0).attr("id", function() {
      const f = R(this.parentNode).attr("data-uid");
      return `${i.style.prefix}-leaf-${f}`;
    }).attr("class", (f) => {
      for (; f.depth > 1; )
        f = f.parent;
      return this.model.getColorClassName({
        classNameTypes: [et.FILL],
        dataGroupName: f.data.name,
        originalClassName: "leaf"
      });
    }).transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "treemap-leaf-update-enter",
        animate: t
      })
    ).attr("width", (f) => f.x1 - f.x0).attr("height", (f) => f.y1 - f.y0).style("fill", (f) => {
      for (; f.depth > 1; )
        f = f.parent;
      return this.model.getFillColor(f.data.name);
    }), h.selectAll("clipPath").data(
      (f) => f.data.showLabel !== !0 ? [] : [1],
      (f) => f
    ).join(
      (f) => f.append("clipPath").attr("id", function() {
        const p = R(this.parentNode).attr("data-uid");
        return `${i.style.prefix}-clip-${p}`;
      }).append("use").attr("xlink:href", function() {
        const p = R(this.parentNode.parentNode).attr("data-uid"), m = `${i.style.prefix}-leaf-${p}`;
        return new URL(`#${m}`, s) + "";
      }),
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (f) => null,
      (f) => f.remove()
    ), h.selectAll("text").data(
      (f) => {
        if (f.data.showLabel !== !0)
          return [];
        let p = f;
        for (; p.depth > 1; )
          p = p.parent;
        const m = mc(this.model.getFillColor(p.data.name));
        return [
          {
            text: f.data.name,
            color: m.l < 0.5 ? "white" : "black"
          }
        ];
      },
      (f) => f
    ).join(
      (f) => {
        const p = f.append("text").text((m) => m.text).style("fill", gf).attr("x", 7).attr("y", 18);
        return s && p.attr("clip-path", function() {
          const m = R(this.parentNode).attr("data-uid"), g = `${i.style.prefix}-clip-${m}`;
          return `url(${new URL(`#${g}`, s) + ""})`;
        }), p;
      },
      (f) => f.text((p) => p.text).style("fill", gf),
      (f) => f.remove()
    ), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("rect.leaf").on("mouseover", function(n, r) {
      const i = R(this);
      let s = getComputedStyle(this, null).getPropertyValue("fill"), a = r;
      for (; a.depth > 1; )
        a = a.parent;
      i.transition("graph_element_mouseover_fill_update").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "graph_element_mouseover_fill_update"
        })
      ).style("fill", (o) => {
        const l = t.model.getFillColor(o.parent.data.name);
        return l && (s = l), pn(s).darker(0.7).toString();
      }), t.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: n,
        hoveredElement: i,
        items: [
          {
            color: s,
            label: a.data.name,
            bold: !0
          },
          {
            label: r.data.name,
            value: r.data.value
          }
        ]
      }), t.services.events.dispatchEvent(O.Treemap.LEAF_MOUSEOVER, {
        event: n,
        element: i,
        datum: r
      });
    }).on("mousemove", function(n, r) {
      const i = R(this);
      t.services.events.dispatchEvent(O.Treemap.LEAF_MOUSEMOVE, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, r) {
      t.services.events.dispatchEvent(O.Treemap.LEAF_CLICK, {
        event: n,
        element: R(this),
        datum: r
      });
    }).on("mouseout", function(n, r) {
      const i = R(this);
      i.classed("hovered", !1);
      let s = r;
      for (; s.depth > 1; )
        s = s.parent;
      i.transition().call(
        (a) => t.services.transitions.setupTransition({
          transition: a,
          name: "graph_element_mouseout_fill_update"
        })
      ).style("fill", (a) => t.model.getFillColor(a.parent.data.name)), t.services.events.dispatchEvent(O.Treemap.LEAF_MOUSEOUT, {
        event: n,
        element: i,
        datum: r
      }), t.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
}
class WU extends dt {
  constructor() {
    super(...arguments), this.type = "wordcloud", this.renderType = K.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: n } = t.detail, { groupMapsTo: r } = this.getOptions().data;
      this.parent.selectAll("text.word").transition("legend-hover-wordcloud").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-wordcloud"
        })
      ).attr("opacity", (i) => i[r] !== n.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("text.word").transition("legend-mouseout-wordcloud").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-wordcloud"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(O.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(O.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const n = this, r = this.getComponentContainer().attr("width", "100%").attr("height", "100%"), i = this.model.getDisplayData(), s = this.getFontSizeScale(i), a = this.getOptions(), { fontSizeMapsTo: o, wordMapsTo: l } = a.wordCloud, { groupMapsTo: c } = a.data, { width: u, height: h } = D.getSVGElementSize(r, {
      useAttrs: !0
    });
    if (u === 0 || h === 0)
      return;
    const d = bk().size([u, h]).words(
      i.map(function(p) {
        const m = p[o];
        if (typeof p[o] != "number")
          throw Error(
            "Badly formatted WordCloud data. `value` should only be an integer or float"
          );
        return {
          [c]: p[c],
          text: p[l],
          size: m,
          value: m
        };
      })
    ).padding(5).rotate(0).fontSize((p) => s(p.size)).on("end", f);
    d.start();
    function f(p) {
      const m = D.appendOrSelect(r, "g.words");
      m.attr("transform", `translate(${d.size()[0] / 2}, ${d.size()[1] / 2})`);
      const g = m.selectAll("text").data(p, (v) => `${v[c]}-${v.text}`);
      g.exit().attr("opacity", 0).remove(), g.enter().append("text").attr("opacity", 0).merge(g).style("font-size", (v) => `${v.size}px`).text(function(v) {
        return v.text;
      }).attr(
        "class",
        (v) => n.model.getColorClassName({
          classNameTypes: [et.FILL],
          dataGroupName: v[c],
          originalClassName: `word ${v.size > 32 ? "light" : ""}`
        })
      ).style("fill", (v) => n.model.getFillColor(v[c], v.text, v)).attr("text-anchor", "middle").transition().call(
        (v) => n.services.transitions.setupTransition({
          transition: v,
          name: "wordcloud-text-update-enter",
          animate: t
        })
      ).attr("transform", (v) => `translate(${v.x}, ${v.y})`).attr("opacity", 1);
    }
    this.addEventListeners();
  }
  getFontSizeScale(t) {
    const n = this.getOptions(), { fontSizeMapsTo: r } = n.wordCloud, i = t.map((l) => l[r]).filter((l) => l), s = D.getHTMLElementSize(this.services.domUtils.getMainContainer()), a = i.length > 0, o = a ? Ne(i) : [1, 1];
    return Be().domain(o).range(a ? n.wordCloud.fontSizeRange(s, t) : [4, 4]);
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: n } = t.data, r = this, i = ba((s) => {
      const a = r.parent.selectAll("text.word").transition("wordcloud-word-mouse-highlight").call(
        (o) => r.services.transitions.setupTransition({
          transition: o,
          name: "wordcloud-word-mouse-highlight"
        })
      );
      s === null ? a.attr("opacity", 1) : a.attr("opacity", function() {
        return s === this ? 1 : 0.3;
      });
    }, 6);
    this.parent.selectAll("text.word").on("mouseover", function(s, a) {
      const o = this;
      i(o), r.services.events.dispatchEvent(O.WordCloud.WORD_MOUSEOVER, {
        event: s,
        element: R(this),
        datum: a
      }), r.services.events.dispatchEvent(O.Tooltip.SHOW, {
        event: s,
        hoveredElement: o,
        items: [
          {
            label: t.tooltip.wordLabel,
            value: a.text
          },
          {
            label: t.tooltip.valueLabel,
            value: a.value
          },
          {
            label: t.tooltip.groupLabel,
            value: a[n],
            class: r.model.getColorClassName({
              classNameTypes: [et.TOOLTIP],
              dataGroupName: a[n]
            })
          }
        ]
      });
    }).on("mousemove", function(s, a) {
      const o = R(this);
      r.services.events.dispatchEvent(O.WordCloud.WORD_MOUSEMOVE, {
        element: o,
        datum: a
      }), r.services.events.dispatchEvent(O.Tooltip.MOVE, {
        event: s
      });
    }).on("click", function(s, a) {
      r.services.events.dispatchEvent(O.WordCloud.WORD_CLICK, {
        event: s,
        element: R(this),
        datum: a
      });
    }).on("mouseout", function(s, a) {
      const o = R(this);
      i(null), r.services.events.dispatchEvent(O.WordCloud.WORD_MOUSEOUT, {
        event: s,
        element: o,
        datum: a
      }), r.services.events.dispatchEvent(O.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class qU extends dt {
  constructor() {
    super(...arguments), this.type = "geo", this.renderType = K.SVG;
  }
  render() {
    const t = this.getComponentContainer({ withinChartClip: !0 }), { width: n, height: r } = D.getSVGElementSize(t, {
      useAttrs: !0
    });
    if (n < 1 || r < 1)
      return;
    const i = this.getProjection(), s = b(this.getOptions(), "geoData"), a = this.model.getCombinedData(), o = {}, l = {};
    Object.keys(a).forEach((g) => {
      typeof a[g].value == "number" ? o[g] = a[g] : l[g] = a[g];
    });
    const c = XI(s, Object.values(l)), u = WI(s, {
      // We need to specify that we are converting geometry collections
      type: "GeometryCollection",
      geometries: Object.values(o)
    }), h = i.fitSize([n, r], u), d = tw().projection(h);
    D.appendOrSelect(t, "g.geo").selectAll("path").data(u.features).join("path").attr("d", d);
    const f = this.services.domUtils.generateElementIDString("geo-pattern-stripes"), p = D.appendOrSelect(t, "defs");
    D.appendOrSelect(p, "pattern").attr("id", f).attr("width", 5).attr("height", 10).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("path").classed("pattern-fill", !0).attr(
      "d",
      Ki()([
        [0, 0],
        [0, 10]
      ])
    );
    const m = D.appendOrSelect(t, "g.missing-data");
    D.appendOrSelect(m, "path").datum(c).attr("d", d).style("fill", `url(#${f})`);
  }
  /**
   * @info
   * Depending on projection, we may need to provide additional configuration
   * e.g. sizing
   *
   * In such case, function can be refactored so that
   * projection should return an object with the configuraiton & function
   */
  getProjection() {
    let t = null;
    switch (b(this.getOptions(), "thematic", "projection")) {
      case on.geoEqualEarth:
        t = xw();
        break;
      case on.geoAlbers:
        t = dw();
        break;
      case on.geoConicEqualArea:
        t = tg();
        break;
      case on.geoConicEquidistant:
        t = vw();
        break;
      case on.geoEquirectangular:
        t = gw();
        break;
      case on.geoMercator:
        t = fw();
        break;
      case on.geoNaturalEarth1:
        t = bw();
        break;
      default:
        throw new Error("Projection is not supported.");
    }
    return t;
  }
}
class YU extends qU {
  constructor() {
    super(...arguments), this.type = "choropleth";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    super.render();
    const n = this.model.getCombinedData();
    this.getComponentContainer({ withinChartClip: !0 }).select("g.geo").selectAll("path").classed("border", !0).attr("class", (r) => this.model.getColorClassName({
      value: n[r.properties.NAME].value,
      originalClassName: "border"
    })), this.addCountryAreaEventListener();
  }
  addCountryAreaEventListener() {
    const t = this, n = this.model.getCombinedData();
    this.parent.selectAll("path.border").on("mouseover", function(r, i) {
      const s = R(this);
      t.services.events.dispatchEvent(wr.CHOROPLETH_MOUSEOVER, {
        event: r,
        element: s,
        datum: n[i.properties.NAME]
      }), t.services.events.dispatchEvent(wi.SHOW, {
        event: r,
        hoveredElement: s,
        items: [
          {
            label: i.properties.NAME,
            value: n[i.properties.NAME].value
          }
        ]
      });
    }).on("mousemove", function(r, i) {
      t.services.events.dispatchEvent(wr.CHOROPLETH_MOUSEMOVE, {
        event: r,
        element: R(this),
        datum: n[i.properties.NAME]
      }), t.services.events.dispatchEvent(wi.MOVE, {
        event: r
      });
    }).on("click", function(r, i) {
      t.services.events.dispatchEvent(wr.CHOROPLETH_CLICK, {
        event: r,
        element: R(this),
        datum: n[i.properties.NAME]
      });
    }).on("mouseout", function(r, i) {
      const s = R(this);
      t.services.events.dispatchEvent(wr.CHOROPLETH_MOUSEOUT, {
        event: r,
        element: s,
        datum: n[i.properties.NAME]
      }), t.services.events.dispatchEvent(wi.HIDE, {
        event: r,
        hoveredElement: s
      });
    });
  }
}
function Mv(e, t) {
  ot(2, arguments);
  var n = xt(e), r = Xt(t);
  return isNaN(r) ? /* @__PURE__ */ new Date(NaN) : (r && n.setDate(n.getDate() + r), n);
}
function lu(e, t) {
  ot(2, arguments);
  var n = xt(e), r = Xt(t);
  if (isNaN(r))
    return /* @__PURE__ */ new Date(NaN);
  if (!r)
    return n;
  var i = n.getDate(), s = new Date(n.getTime());
  s.setMonth(n.getMonth() + r + 1, 0);
  var a = s.getDate();
  return i >= a ? s : (n.setFullYear(s.getFullYear(), s.getMonth(), i), n);
}
var XU = 36e5;
function Cv(e, t) {
  ot(2, arguments);
  var n = Xt(t);
  return Ga(e, n * XU);
}
function mf(e) {
  ot(1, arguments);
  var t = xt(e);
  return t.setHours(0, 0, 0, 0), t;
}
var ZU = 864e5;
function KU(e, t) {
  ot(2, arguments);
  var n = mf(e), r = mf(t), i = n.getTime() - Ml(n), s = r.getTime() - Ml(r);
  return Math.round((i - s) / ZU);
}
var QU = 6e4;
function rc(e, t) {
  ot(2, arguments);
  var n = Xt(t);
  return Ga(e, n * QU);
}
function ic(e, t) {
  ot(2, arguments);
  var n = Xt(t);
  return Ga(e, n * 1e3);
}
function $v(e, t) {
  ot(2, arguments);
  var n = Xt(t);
  return lu(e, n * 12);
}
function Ai(e, t) {
  ot(2, arguments);
  var n = xt(e), r = xt(t), i = n.getTime() - r.getTime();
  return i < 0 ? -1 : i > 0 ? 1 : i;
}
var JU = 6e4, tB = 36e5;
function eB(e, t) {
  ot(2, arguments);
  var n = xt(e), r = xt(t), i = n.getFullYear() - r.getFullYear(), s = n.getMonth() - r.getMonth();
  return i * 12 + s;
}
function nB(e, t) {
  ot(2, arguments);
  var n = xt(e), r = xt(t);
  return n.getFullYear() - r.getFullYear();
}
function vf(e, t) {
  var n = e.getFullYear() - t.getFullYear() || e.getMonth() - t.getMonth() || e.getDate() - t.getDate() || e.getHours() - t.getHours() || e.getMinutes() - t.getMinutes() || e.getSeconds() - t.getSeconds() || e.getMilliseconds() - t.getMilliseconds();
  return n < 0 ? -1 : n > 0 ? 1 : n;
}
function rB(e, t) {
  ot(2, arguments);
  var n = xt(e), r = xt(t), i = vf(n, r), s = Math.abs(KU(n, r));
  n.setDate(n.getDate() - i * s);
  var a = +(vf(n, r) === -i), o = i * (s - a);
  return o === 0 ? 0 : o;
}
function cu(e, t) {
  return ot(2, arguments), xt(e).getTime() - xt(t).getTime();
}
var yf = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function(e) {
    return e < 0 ? Math.ceil(e) : Math.floor(e);
  }
  // Math.trunc is not supported by IE
}, iB = "trunc";
function uu(e) {
  return e ? yf[e] : yf[iB];
}
function sB(e, t, n) {
  ot(2, arguments);
  var r = cu(e, t) / tB;
  return uu(n == null ? void 0 : n.roundingMethod)(r);
}
function xf(e, t, n) {
  ot(2, arguments);
  var r = cu(e, t) / JU;
  return uu(n == null ? void 0 : n.roundingMethod)(r);
}
function aB(e) {
  ot(1, arguments);
  var t = xt(e);
  return t.setHours(23, 59, 59, 999), t;
}
function oB(e) {
  ot(1, arguments);
  var t = xt(e), n = t.getMonth();
  return t.setFullYear(t.getFullYear(), n + 1, 0), t.setHours(23, 59, 59, 999), t;
}
function lB(e) {
  ot(1, arguments);
  var t = xt(e);
  return aB(t).getTime() === oB(t).getTime();
}
function cB(e, t) {
  ot(2, arguments);
  var n = xt(e), r = xt(t), i = Ai(n, r), s = Math.abs(eB(n, r)), a;
  if (s < 1)
    a = 0;
  else {
    n.getMonth() === 1 && n.getDate() > 27 && n.setDate(30), n.setMonth(n.getMonth() - i * s);
    var o = Ai(n, r) === -i;
    lB(xt(e)) && s === 1 && Ai(e, r) === 1 && (o = !1), a = i * (s - Number(o));
  }
  return a === 0 ? 0 : a;
}
function bf(e, t, n) {
  ot(2, arguments);
  var r = cu(e, t) / 1e3;
  return uu(n == null ? void 0 : n.roundingMethod)(r);
}
function uB(e, t) {
  ot(2, arguments);
  var n = xt(e), r = xt(t), i = Ai(n, r), s = Math.abs(nB(n, r));
  n.setFullYear(1584), r.setFullYear(1584);
  var a = Ai(n, r) === -i, o = i * (s - Number(a));
  return o === 0 ? 0 : o;
}
function hB(e, t) {
  ot(2, arguments);
  var n = Xt(t);
  return Mv(e, -n);
}
function dB(e, t) {
  ot(2, arguments);
  var n = Xt(t);
  return lu(e, -n);
}
function fB(e, t) {
  ot(2, arguments);
  var n = Xt(t);
  return Cv(e, -n);
}
function wf(e, t) {
  ot(2, arguments);
  var n = Xt(t);
  return rc(e, -n);
}
function _f(e, t) {
  ot(2, arguments);
  var n = Xt(t);
  return ic(e, -n);
}
function pB(e, t) {
  ot(2, arguments);
  var n = Xt(t);
  return $v(e, -n);
}
function Av(e) {
  var t = e == null ? 0 : e.length;
  return t ? Qa(e, 1) : [];
}
class gB extends En {
  /**
   * focal:  object to zoom into
   * canvasElements: all the elements to translate and zoom on the chart area
   * zoomSettings: object containing duration, easing and zoomlevel for the zoom behaviours
   *  */
  zoomIn(t, n, r) {
    let i, s, a;
    const o = r || Mr;
    t && (i = t.x, s = t.y, a = 2);
    const { width: l, height: c } = D.getSVGElementSize(this.services.domUtils.getHolder(), {
      useClientDimensions: !0
    });
    n.transition().duration(o.duration).ease(o.ease).attr(
      "transform",
      `translate(${l / 2}, ${c / 2}) scale(${a}) translate(${-i},${-s})`
    ), this.services.events.dispatchEvent(O.CanvasZoom.CANVAS_ZOOM_IN, {
      element: R(t)
    });
  }
  zoomOut(t, n) {
    const r = n || Mr;
    t.transition().duration(r.duration).ease(r.ease).attr("transform", ""), this.services.events.dispatchEvent(O.CanvasZoom.CANVAS_ZOOM_OUT);
  }
}
class mB extends En {
  init() {
    this.documentFragment = document.createDocumentFragment();
  }
  addEventListener(t, n) {
    this.documentFragment.addEventListener(t, n);
  }
  removeEventListener(t, n) {
    this.documentFragment.removeEventListener(t, n);
  }
  dispatchEvent(t, n) {
    let r;
    n ? r = new CustomEvent(t, {
      detail: n
    }) : (r = document.createEvent("Event"), r.initEvent(t, !1, !0)), this.documentFragment.dispatchEvent(r);
  }
}
class vB extends En {
  constructor(t, n) {
    super(t, n);
  }
  downloadCSV(t, n) {
    const r = document.createElement("a"), i = "text/csv;encoding:utf-8";
    if (navigator.msSaveBlob)
      navigator.msSaveBlob(
        new Blob([t], {
          type: i
        }),
        n
      );
    else if (URL && "download" in r) {
      const s = URL.createObjectURL(
        new Blob([t], {
          type: i
        })
      );
      r.href = s, r.setAttribute("download", n), document.body.appendChild(r), r.click(), document.body.removeChild(r), URL.revokeObjectURL(s);
    } else
      location.href = `data:application/octet-stream,${encodeURIComponent(t)}`;
  }
  downloadImage(t, n) {
    const r = document.createElement("a");
    r.download = n, r.href = t, document.body.appendChild(r), r.click(), document.body.removeChild(r);
  }
}
class yB extends En {
  constructor() {
    super(...arguments), this.pendingTransitions = {};
  }
  init() {
    var t;
    (t = this.services.events) == null || t.addEventListener(O.Model.UPDATE, () => {
      this.pendingTransitions = {};
    });
  }
  setupTransition({ transition: t, name: n, animate: r }) {
    return this.pendingTransitions[t._id] = t, t.on("end interrupt cancel", () => {
      delete this.pendingTransitions[t._id];
    }), this.model.getOptions().animations === !1 || r === !1 ? t.duration(0) : t.duration(b($d, n, "duration") || $d.default.duration);
  }
  getPendingTransitions() {
    return this.pendingTransitions;
  }
}
let xB = class extends En {
  constructor() {
    super(...arguments), this.scaleTypes = {
      top: null,
      right: null,
      bottom: null,
      left: null
    }, this.scales = {
      // null or function
      top: null,
      right: null,
      bottom: null,
      left: null
    };
  }
  getDomainAxisPosition({ datum: t = null } = {}) {
    if (this.dualAxes && t) {
      const n = this.model.getOptions(), { groupMapsTo: r } = n.data, i = b(n, "axes", this.secondaryDomainAxisPosition), s = t[r];
      if (i != null && i.correspondingDatasets && i.correspondingDatasets.includes(s))
        return this.secondaryDomainAxisPosition;
    }
    return this.domainAxisPosition;
  }
  getRangeAxisPosition({ datum: t = null, groups: n = null } = {}) {
    if (this.dualAxes) {
      const r = this.model.getOptions(), { groupMapsTo: i } = r.data, s = b(r, "axes", this.secondaryRangeAxisPosition);
      let a;
      if (t !== null ? a = t[i] : n && n.length > 0 && (a = n[0]), s != null && s.correspondingDatasets && s.correspondingDatasets.includes(a))
        return this.secondaryRangeAxisPosition;
    }
    return this.rangeAxisPosition;
  }
  getAxisOptions(t) {
    return b(this.model.getOptions(), "axes", t);
  }
  getDomainAxisOptions() {
    const t = this.getDomainAxisPosition();
    return this.getAxisOptions(t);
  }
  getRangeAxisOptions() {
    const t = this.getRangeAxisPosition();
    return this.getAxisOptions(t);
  }
  getScaleLabel(t) {
    return this.getAxisOptions(t).title || (t === H.BOTTOM || t === H.TOP ? "x-value" : "y-value");
  }
  getDomainLabel() {
    return this.getScaleLabel(this.getDomainAxisPosition());
  }
  getRangeLabel() {
    return this.getScaleLabel(this.getRangeAxisPosition());
  }
  update() {
    this.determineAxisDuality(), this.findDomainAndRangeAxes(), this.determineOrientation(), Object.keys(H).map(
      (t) => H[t]
    ).forEach((t) => {
      this.scales[t] = this.createScale(t);
    });
  }
  findDomainAndRangeAxes() {
    const t = this.findVerticalAxesPositions(), n = this.findHorizontalAxesPositions(), r = this.findDomainAndRangeAxesPositions(
      t,
      n
    );
    this.domainAxisPosition = r.primaryDomainAxisPosition, this.rangeAxisPosition = r.primaryRangeAxisPosition, this.isDualAxes() && (this.secondaryDomainAxisPosition = r.secondaryDomainAxisPosition, this.secondaryRangeAxisPosition = r.secondaryRangeAxisPosition);
  }
  determineOrientation() {
    (this.rangeAxisPosition === H.LEFT || this.rangeAxisPosition === H.RIGHT) && (this.domainAxisPosition === H.BOTTOM || this.domainAxisPosition === H.TOP) ? this.orientation = Kt.VERTICAL : this.orientation = Kt.HORIZONTAL;
  }
  isDualAxes() {
    return this.dualAxes;
  }
  // if any of the axes objects have correspondingDatasets [] asserted we flag the chart as dual axes
  // it does not count as dual axes if it just has another axis turned on but is not actually using it to map a dataset
  determineAxisDuality() {
    var t, n, r, i;
    const s = this.model.getOptions(), a = b(s, "axes");
    ((t = a[H.LEFT]) != null && t.correspondingDatasets && a[H.RIGHT] || (n = a[H.RIGHT]) != null && n.correspondingDatasets && a[H.LEFT] || (r = a[H.TOP]) != null && r.correspondingDatasets && a[H.BOTTOM] || (i = a[H.BOTTOM]) != null && i.correspondingDatasets && a[H.TOP]) && (this.dualAxes = !0);
  }
  getCustomDomainValuesByposition(t) {
    const n = b(this.model.getOptions(), "axes", t, "domain");
    if (n && !Array.isArray(n))
      throw new Error(`Domain in ${t} axis is not a valid array`);
    if (Array.isArray(n) && (this.scaleTypes[t] === X.LINEAR || this.scaleTypes[t] === X.TIME) && n.length !== 2)
      throw new Error(
        `There can only be 2 elements in domain for scale type: ${this.scaleTypes[t]}`
      );
    return n;
  }
  getOrientation() {
    return this.orientation;
  }
  getScaleByPosition(t) {
    return this.scales[t];
  }
  getScaleTypeByPosition(t) {
    return this.scaleTypes[t];
  }
  getDomainAxisScaleType() {
    const t = this.getDomainAxisPosition();
    return this.getScaleTypeByPosition(t);
  }
  getRangeAxisScaleType() {
    const t = this.getRangeAxisPosition();
    return this.getScaleTypeByPosition(t);
  }
  getDomainScale() {
    return this.scales[this.domainAxisPosition];
  }
  getRangeScale() {
    return this.scales[this.rangeAxisPosition];
  }
  // Find the main x-axis out of the 2 x-axis on the chart (when 2D axis is used)
  getMainXAxisPosition() {
    const t = [H.BOTTOM, H.TOP];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (n) => t.indexOf(n) > -1
    );
  }
  // Find the main y-axis out of the 2 y-axis on the chart (when 2D axis is used)
  getMainYAxisPosition() {
    const t = [H.LEFT, H.RIGHT];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (n) => t.indexOf(n) > -1
    );
  }
  getMainXScale() {
    return this.scales[this.getMainXAxisPosition()];
  }
  getMainYScale() {
    return this.scales[this.getMainYAxisPosition()];
  }
  getValueFromScale(t, n, r, i) {
    const s = this.model.getOptions(), a = b(s, "axes")[r], { mapsTo: o } = a, l = b(i, o) !== null ? i[o] : i;
    let c;
    switch (n) {
      case X.LABELS:
        c = t(l) + t.step() / 2;
        break;
      case X.TIME:
        c = t(new Date(l));
        break;
      default:
        c = t(l);
    }
    return c;
  }
  getBoundedScaledValues(t) {
    const { bounds: n } = this.model.getOptions(), r = this.getRangeAxisPosition({ datum: t }), i = this.scales[r], s = this.model.getOptions(), a = b(s, "axes")[r], { mapsTo: o } = a, l = t[o] !== void 0 ? t[o] : t;
    return [
      i(
        b(t, n.upperBoundMapsTo) !== null ? t[n.upperBoundMapsTo] : l
      ),
      i(
        b(t, n.lowerBoundMapsTo) !== null ? t[n.lowerBoundMapsTo] : l
      )
    ];
  }
  getValueThroughAxisPosition(t, n) {
    const r = this.scaleTypes[t], i = this.scales[t];
    return this.getValueFromScale(i, r, t, n);
  }
  getDomainValue(t) {
    const n = this.getDomainAxisPosition({ datum: t });
    return this.getValueThroughAxisPosition(n, t);
  }
  getRangeValue(t) {
    const n = this.getRangeAxisPosition({ datum: t });
    return this.getValueThroughAxisPosition(n, t);
  }
  getMainXScaleType() {
    return this.getScaleTypeByPosition(this.getMainXAxisPosition());
  }
  getMainYScaleType() {
    return this.getScaleTypeByPosition(this.getMainYAxisPosition());
  }
  getDomainIdentifier(t) {
    const n = this.model.getOptions();
    return b(n, "axes", this.getDomainAxisPosition({ datum: t }), "mapsTo");
  }
  getRangeIdentifier(t) {
    const n = this.model.getOptions();
    return b(n, "axes", this.getRangeAxisPosition({ datum: t }), "mapsTo");
  }
  extendsDomain(t, n) {
    const r = this.model.getOptions(), i = b(r, "axes", t);
    if (i.scaleType === X.TIME) {
      const s = b(r, "timeScale", "addSpaceOnEdges");
      return bB(n, s);
    } else
      return wB(n, An.paddingRatio, i.scaleType);
  }
  findVerticalAxesPositions() {
    const t = this.model.getOptions(), n = b(t, "axes"), r = this.isDualAxes();
    return b(n, H.LEFT) === null && b(n, H.RIGHT) !== null || b(n, H.RIGHT, "main") === !0 || r && b(n, H.LEFT, "correspondingDatasets") ? {
      primary: H.RIGHT,
      secondary: H.LEFT
    } : { primary: H.LEFT, secondary: H.RIGHT };
  }
  findHorizontalAxesPositions() {
    const t = this.model.getOptions(), n = b(t, "axes"), r = this.isDualAxes();
    return b(n, H.BOTTOM) === null && b(n, H.TOP) !== null || b(n, H.TOP, "main") === !0 || r && b(n, H.BOTTOM, "correspondingDatasets") ? {
      primary: H.TOP,
      secondary: H.BOTTOM
    } : { primary: H.BOTTOM, secondary: H.TOP };
  }
  findDomainAndRangeAxesPositions(t, n) {
    const r = this.model.getOptions(), i = b(r, "axes", t.primary), s = b(r, "axes", n.primary), a = i.scaleType || X.LINEAR, o = s.scaleType || X.LINEAR, l = {
      primaryDomainAxisPosition: null,
      secondaryDomainAxisPosition: null,
      primaryRangeAxisPosition: null,
      secondaryRangeAxisPosition: null
    };
    return l.primaryDomainAxisPosition = n.primary, l.primaryRangeAxisPosition = t.primary, l.secondaryDomainAxisPosition = n.secondary, l.secondaryRangeAxisPosition = t.secondary, (!(o === X.LABELS || o === X.TIME) && a === X.LABELS || a === X.TIME) && (l.primaryDomainAxisPosition = t.primary, l.primaryRangeAxisPosition = n.primary, l.secondaryDomainAxisPosition = t.secondary, l.secondaryRangeAxisPosition = n.secondary), l;
  }
  getScaleDomain(t) {
    const n = this.model.getOptions(), r = b(n, "axes", t), i = b(n, "bounds"), { includeZero: s } = r, a = b(r, "scaleType") || X.LINEAR;
    if (this.model.isDataEmpty())
      return [];
    if (r.binned) {
      const { bins: v } = this.model.getBinConfigurations();
      return [0, qn(v, (y) => y.length)];
    } else if (r.limitDomainToBins) {
      const { bins: v } = this.model.getBinConfigurations(), y = this.model.getStackKeys({ bins: v });
      return [y[0].split("-")[0], y[y.length - 1].split("-")[1]];
    }
    const o = this.model.getDisplayData(), { extendLinearDomainBy: l, mapsTo: c, percentage: u, thresholds: h } = r, { reference: d, compareTo: f } = An.ratio;
    if (r.domain)
      return a === X.LABELS ? r.domain : (a === X.TIME && (r.domain = r.domain.map(
        (v) => v.getTime === void 0 ? new Date(v) : v
      )), this.extendsDomain(t, r.domain));
    if (u)
      return [0, 100];
    if (r && a === X.LABELS)
      return Gi(o.map((v) => v[c]));
    let p, m;
    const g = this.model.getDataGroupNames();
    if (a === X.LABELS_RATIO)
      return o.map((v) => `${v[d]}/${v[f]}`);
    if (a === X.TIME)
      m = o.map((v) => +new Date(v[c]));
    else if (i && n.axes)
      m = [], o.forEach((v) => {
        m.push(v[c]), v[i.upperBoundMapsTo] && m.push(v[i.upperBoundMapsTo]), v[i.lowerBoundMapsTo] && m.push(v[i.lowerBoundMapsTo]);
      });
    else if (r.stacked === !0 && g && t === this.getRangeAxisPosition()) {
      const { groupMapsTo: v } = n.data, y = this.model.getDataValuesGroupedByKeys({
        groups: g
      }), x = o.filter(
        (_) => !g.includes(_[v])
      ), S = [];
      y.forEach((_) => {
        const { ...E } = _;
        let T = 0, k = 0;
        Object.values(E).forEach((N) => {
          isNaN(N) || (N < 0 ? k += N : T += N);
        }), S.push([k, T]);
      }), m = [
        ...Av(S),
        ...x.map((_) => _[c])
      ];
    } else
      m = [], o.forEach((v) => {
        const y = v[c];
        Array.isArray(y) && y.length === 2 ? (m.push(y[0]), m.push(y[1])) : (l && m.push(Math.max(v[c], v[l])), m.push(y));
      });
    return a !== X.TIME && a !== X.LOG && s && m.push(0), h && h.length > 0 && h.forEach((v) => {
      const y = b(v, "value");
      y !== null && m.push(y);
    }), p = Ne(m), p = this.extendsDomain(t, p), p;
  }
  createScale(t) {
    const n = this.model.getOptions(), r = b(n, "axes", t);
    if (!r)
      return null;
    const i = b(r, "scaleType") || X.LINEAR;
    this.scaleTypes[t] = i;
    let s;
    return i === X.TIME ? s = yg() : i === X.LOG ? s = ug().base(r.base || 10) : i === X.LABELS || i === X.LABELS_RATIO ? s = Xi() : s = Be(), s.domain(this.getScaleDomain(t)), s;
  }
  getHighestDomainThreshold() {
    const t = b(this.model.getOptions(), "axes"), n = this.getDomainAxisPosition(), { thresholds: r } = t[n];
    if (!Array.isArray(r) || Array.isArray(r) && !r.length)
      return null;
    const i = this.getDomainScale(), s = r.sort((a, o) => o.value - a.value)[0];
    return this.getScaleTypeByPosition(n) === X.TIME && (typeof s.value == "string" || s.value.getTime === void 0) && (s.value = new Date(s.value)), {
      threshold: s,
      scaleValue: i(s.value)
    };
  }
  getHighestRangeThreshold() {
    const t = b(this.model.getOptions(), "axes"), n = this.getRangeAxisPosition(), { thresholds: r } = t[n];
    if (!Array.isArray(r) || Array.isArray(r) && !r.length)
      return null;
    const i = this.getRangeScale(), s = r.sort((a, o) => o.value - a.value)[0];
    return {
      threshold: s,
      scaleValue: i(s.value)
    };
  }
};
function bB(e, t) {
  const n = new Date(e[0]), r = new Date(e[1]);
  return uB(r, n) > 1 ? [pB(n, t), $v(r, t)] : cB(r, n) > 1 ? [dB(n, t), lu(r, t)] : rB(r, n) > 1 ? [hB(n, t), Mv(r, t)] : sB(r, n) > 1 ? [fB(n, t), Cv(r, t)] : xf(r, n) > 30 ? [
    wf(n, t * 30),
    rc(r, t * 30)
  ] : xf(r, n) > 1 ? [wf(n, t), rc(r, t)] : bf(r, n) > 15 ? [
    _f(n, t * 15),
    ic(r, t * 15)
  ] : bf(r, n) > 1 ? [_f(n, t), ic(r, t)] : [n, r];
}
function wB([e, t], n, r) {
  const i = (t - e) * n, s = t <= 0 && t + i > 0 ? 0 : t + i;
  let a = e >= 0 && e - i < 0 ? 0 : e - i;
  if (r === X.LOG && a <= 0) {
    if (e <= 0)
      throw Error("Data must have values greater than 0 if log scale type is used.");
    a = e;
  }
  return [a, s];
}
let _B = class extends En {
  constructor() {
    super(...arguments), this.curveTypes = {
      curveLinear: Va,
      curveLinearClosed: $g,
      curveBasis: yS,
      curveBasisClosed: xS,
      curveBasisOpen: bS,
      curveBundle: wS,
      curveCardinal: _S,
      curveCardinalClosed: ES,
      curveCardinalOpen: SS,
      curveCatmullRom: OS,
      curveCatmullRomClosed: TS,
      curveCatmullRomOpen: MS,
      curveMonotoneX: CS,
      curveMonotoneY: $S,
      curveNatural: AS,
      curveStep: LS,
      curveStepAfter: kS,
      curveStepBefore: DS
    };
  }
  getD3Curve() {
    let t = "curveLinear";
    const n = this.model.getOptions().curve;
    if (n && (typeof n == "string" ? t = n : t = n.name), this.curveTypes[t]) {
      let r = this.curveTypes[t];
      return n && Object.keys(n).forEach((i) => {
        r[i] && (r = r[i](n[i]));
      }), r;
    }
    return console.warn(`The curve type '${t}' is invalid, using 'curveLinear' instead`), this.curveTypes.curveLinear;
  }
}, EB = class extends En {
  isZoomBarEnabled() {
    if (!this.services.cartesianScales || !b(this.model.getOptions(), "zoomBar", "top", "enabled"))
      return !1;
    this.services.cartesianScales.findDomainAndRangeAxes();
    const t = this.services.cartesianScales.getMainXAxisPosition(), n = b(
      this.model.getOptions(),
      "axes",
      t,
      "scaleType"
    );
    return t === H.BOTTOM && n === X.TIME;
  }
  // get display data for zoom bar
  // basically it's sum of value grouped by time
  getZoomBarData() {
    const t = this.model.getZoomBarData();
    return t && t.length > 1 ? t : this.model.getDisplayData();
  }
  getDefaultZoomBarDomain(t) {
    if (!this.services.zoom)
      throw new Error("Services zoom not defined");
    const n = t || this.services.zoom.getZoomBarData(), { cartesianScales: r } = this.services;
    if (!r)
      throw new Error("Services cartesianScales undefined");
    const i = r.getMainXAxisPosition(), s = r.getDomainIdentifier(), a = b(this.model.getOptions(), "axes", i, "domain");
    if (Array.isArray(a) && a.length === 2)
      return a;
    if (!i)
      throw new Error("Not defined: mainXAxisPosition");
    return r.extendsDomain(
      i,
      Ne(n, (o) => o[s])
    );
  }
  handleDomainChange(t, n = { dispatchEvent: !0 }) {
    var r;
    this.model.set({ zoomDomain: t }, { animate: !1 }), n.dispatchEvent && ((r = this.services.events) == null || r.dispatchEvent(O.ZoomDomain.CHANGE, {
      newDomain: t
    }));
  }
  getZoomRatio() {
    return b(this.model.getOptions(), "zoomBar", "zoomRatio");
  }
  // filter out data not inside zoom domain
  // to get better range value for axis label
  filterDataForRangeAxis(t, n) {
    var r;
    const i = this.model.get("zoomDomain"), s = Object.assign(
      { stacked: !1 },
      // default configs
      n
    ), a = b(this.model.getOptions(), "zoomBar", "updateRangeAxis");
    if (this.isZoomBarEnabled() && a && i) {
      const o = s.stacked ? "sharedStackKey" : (r = this.services.cartesianScales) == null ? void 0 : r.getDomainIdentifier(), l = t.filter(
        (c) => new Date(c[o]) >= i[0] && new Date(c[o]) <= i[1]
      );
      if (l.length > 0)
        return l;
    }
    return t;
  }
  zoomIn(t = this.getZoomRatio()) {
    var n;
    const r = this.model.get("zoomDomain"), i = ye.handleWidth, s = (n = this.services.cartesianScales) == null ? void 0 : n.getMainXScale().copy();
    s.domain(this.getDefaultZoomBarDomain());
    const a = s(r[0]), o = s(r[1]);
    if (o - a < i + 1)
      return;
    const l = s.range(), c = o - a, u = Math.min((l[1] - l[0]) / 2 * (t / 2), c / 2);
    let h = a + u, d = o - u;
    h >= d && (h = a + c / 2 - i / 2, d = o - c / 2 + i / 2);
    const f = [s.invert(h), s.invert(d)];
    (r[0].valueOf() !== f[0].valueOf() || r[1].valueOf() !== f[1].valueOf()) && this.handleDomainChange(f);
  }
  zoomOut(t = this.getZoomRatio()) {
    const n = this.model.get("zoomDomain");
    if (!this.services.cartesianScales)
      throw new Error("Services cartesianScales undefined");
    const r = this.services.cartesianScales.getMainXScale().copy();
    r.domain(this.getDefaultZoomBarDomain());
    const i = r(n[0]), s = r(n[1]), a = r.range(), o = (a[1] - a[0]) / 2 * (t / 2), l = Math.max(i - o, a[0]), c = Math.min(s + o, a[1]), u = [r.invert(l), r.invert(c)];
    (n[0].valueOf() !== u[0].valueOf() || n[1].valueOf() !== u[1].valueOf()) && this.handleDomainChange(u);
  }
  resetZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    (t[0].valueOf() !== n[0].valueOf() || t[1].valueOf() !== n[1].valueOf()) && this.handleDomainChange(n);
  }
  // check if current zoom domain is already the min zoom domain
  // when toolbar is rendered, we don't render chart yet
  // don't depend on scale range
  isMinZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    if (!t || !n)
      return !1;
    const r = t[1].valueOf() - t[0].valueOf(), i = n[1].valueOf() - n[0].valueOf(), s = b(this.model.getOptions(), "zoomBar", "minZoomRatio");
    return r / i < s;
  }
  // check if current zoom domain is already the max zoom domain
  isMaxZoomDomain() {
    const t = this.model.get("zoomDomain"), n = this.getDefaultZoomBarDomain();
    return !!(t && n && t[0].valueOf() === n[0].valueOf() && t[1].valueOf() === n[1].valueOf());
  }
  isEmptyState() {
    return this.getZoomBarData().length === 0;
  }
  isZoomBarLoading(t) {
    return b(this.model.getOptions(), "zoomBar", t, "loading");
  }
  isZoomBarLocked(t) {
    return b(this.model.getOptions(), "zoomBar", t, "locked");
  }
};
function SB(e, t, n) {
  var r = -1, i = e.length;
  t < 0 && (t = -t > i ? 0 : i + t), n = n > i ? i : n, n < 0 && (n += i), i = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var s = Array(i); ++r < i; )
    s[r] = e[r + t];
  return s;
}
function OB(e, t, n) {
  var r = e.length;
  return n = n === void 0 ? r : n, !t && n >= r ? e : SB(e, t, n);
}
var TB = "\\ud800-\\udfff", MB = "\\u0300-\\u036f", CB = "\\ufe20-\\ufe2f", $B = "\\u20d0-\\u20ff", AB = MB + CB + $B, LB = "\\ufe0e\\ufe0f", DB = "\\u200d", kB = RegExp("[" + DB + TB + AB + LB + "]");
function Lv(e) {
  return kB.test(e);
}
function RB(e) {
  return e.split("");
}
var Dv = "\\ud800-\\udfff", IB = "\\u0300-\\u036f", NB = "\\ufe20-\\ufe2f", PB = "\\u20d0-\\u20ff", UB = IB + NB + PB, BB = "\\ufe0e\\ufe0f", VB = "[" + Dv + "]", sc = "[" + UB + "]", ac = "\\ud83c[\\udffb-\\udfff]", HB = "(?:" + sc + "|" + ac + ")", kv = "[^" + Dv + "]", Rv = "(?:\\ud83c[\\udde6-\\uddff]){2}", Iv = "[\\ud800-\\udbff][\\udc00-\\udfff]", FB = "\\u200d", Nv = HB + "?", Pv = "[" + BB + "]?", GB = "(?:" + FB + "(?:" + [kv, Rv, Iv].join("|") + ")" + Pv + Nv + ")*", zB = Pv + Nv + GB, jB = "(?:" + [kv + sc + "?", sc, Rv, Iv, VB].join("|") + ")", WB = RegExp(ac + "(?=" + ac + ")|" + jB + zB, "g");
function qB(e) {
  return e.match(WB) || [];
}
function YB(e) {
  return Lv(e) ? qB(e) : RB(e);
}
function XB(e) {
  return function(t) {
    t = ns(t);
    var n = Lv(t) ? YB(t) : void 0, r = n ? n[0] : t.charAt(0), i = n ? OB(n, 1).join("") : t.slice(1);
    return r[e]() + i;
  };
}
var ZB = XB("toUpperCase");
const KB = ZB;
function QB(e) {
  return KB(ns(e).toLowerCase());
}
var JB = sv(function(e, t, n) {
  return t = t.toLowerCase(), e + (n ? QB(t) : t);
});
const t3 = JB;
class Fe {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  constructor(t, n) {
    this.components = [], this.services = {
      canvasZoom: gB,
      domUtils: D,
      events: mB,
      files: vB,
      gradientUtils: Ul,
      transitions: yB
    }, this.model = new Je(this.services);
  }
  // Contains the code that uses properties that are overridable by the super-class
  init(t, n) {
    this.model.set({ holder: t }, { skipUpdate: !0 }), Object.keys(this.services).forEach((r) => {
      const i = this.services[r];
      this.services[r] = new i(this.model, this.services);
    }), this.services.events.addEventListener(O.Model.UPDATE, (r) => {
      const i = !!b(r, "detail", "animate");
      this.update(i);
    }), this.model.setData(n.data), this.services.events.addEventListener(O.Chart.RESIZE, () => {
      this.update(!1);
    }), this.components = this.getComponents(), this.update();
  }
  getComponents() {
    return console.error("getComponents() method is not implemented"), [];
  }
  update(t = !0) {
    if (!this.components)
      return;
    Object.keys(this.services).forEach((i) => {
      this.services[i].update();
    }), this.components.forEach((i) => i.render(t));
    const n = this.services.transitions.getPendingTransitions(), r = Object.keys(n).map((i) => n[i].end().catch((s) => s));
    Promise.all(r).then(
      () => this.services.events.dispatchEvent(O.Chart.RENDER_FINISHED)
    );
  }
  destroy() {
    this.components.forEach((t) => t.destroy()), this.services.domUtils.getHolder().remove(), this.model.set({ destroyed: !0 }, { skipUpdate: !0 });
  }
  getChartComponents(t, n) {
    const r = this.model.getOptions(), i = b(r, "toolbar", "enabled"), s = {
      id: "legend",
      components: [new iu(this.model, this.services)],
      growth: st.PREFERRED
    }, a = b(r, "canvasZoom", "enabled");
    a && a === !0 && t.push(new DI(this.model, this.services));
    const o = !!this.model.getOptions().title, l = {
      id: "title",
      components: [new is(this.model, this.services)],
      growth: st.STRETCH
    }, c = {
      id: "toolbar",
      components: [new ro(this.model, this.services)],
      growth: st.PREFERRED
    }, u = {
      id: "header",
      components: [
        new be(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            l,
            ...i ? [c] : []
          ],
          {
            direction: Lt.ROW,
            alignItems: Wr.CENTER
          }
        )
      ],
      growth: st.PREFERRED
    }, h = {
      id: "graph-frame",
      components: t,
      growth: st.STRETCH,
      renderType: b(n, "graphFrameRenderType") || K.SVG
    }, d = b(n, "excludeLegend") !== !0 && r.legend.enabled !== !1;
    let f = Lt.COLUMN;
    if (d) {
      const v = b(r, "legend", "position");
      v === "left" ? (f = Lt.ROW, r.legend.orientation || (r.legend.orientation = Li.VERTICAL)) : v === "right" ? (f = Lt.ROW_REVERSE, r.legend.orientation || (r.legend.orientation = Li.VERTICAL)) : v === "bottom" && (f = Lt.COLUMN_REVERSE);
    }
    const p = {
      id: "spacer",
      components: [new bn(this.model, this.services)],
      growth: st.PREFERRED
    }, m = {
      id: "full-frame",
      components: [
        new be(
          this.model,
          this.services,
          [
            ...d ? [s] : [],
            ...d ? [p] : [],
            h
          ],
          {
            direction: f
          }
        )
      ],
      growth: st.STRETCH
    }, g = [];
    if (o || i) {
      g.push(u);
      const v = {
        id: "spacer",
        components: [
          new bn(this.model, this.services, i ? { size: 15 } : void 0)
        ],
        growth: st.PREFERRED
      };
      g.push(v);
    }
    return g.push(m), [
      new su(this.model, this.services),
      new io(this.model, this.services),
      new be(this.model, this.services, g, {
        direction: Lt.COLUMN
      })
    ];
  }
}
class me extends Fe {
  constructor(t, n) {
    super(t, n), this.services = Object.assign(this.services, {
      cartesianScales: xB,
      curves: _B,
      zoom: EB
    }), this.model = new or(this.services);
  }
  getAxisChartComponents(t, n) {
    const r = this.model.getOptions(), i = b(r, "zoomBar", H.TOP, "enabled"), s = b(r, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const a = this.services.cartesianScales.getMainXAxisPosition(), o = b(r, "axes", a, "scaleType"), l = i && a === H.BOTTOM && o === X.TIME, c = this.services.zoom.isZoomBarLocked(H.TOP), u = !!this.model.getOptions().title, h = {
      id: "title",
      components: [new is(this.model, this.services)],
      growth: st.STRETCH
    }, d = {
      id: "toolbar",
      components: [new ro(this.model, this.services)],
      growth: st.PREFERRED
    }, f = {
      id: "header",
      components: [
        new be(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            h,
            ...s ? [d] : []
          ],
          {
            direction: Lt.ROW,
            alignItems: Wr.CENTER
          }
        )
      ],
      growth: st.PREFERRED
    }, p = {
      id: "legend",
      components: [new iu(this.model, this.services)],
      growth: st.PREFERRED
    };
    l && !c && t.push(
      new gv(this.model, this.services),
      new kI(this.model, this.services)
    ), t.push(new II(this.model, this.services)), t.push(new NI(this.model, this.services));
    const m = {
      id: "graph-frame",
      components: t,
      growth: st.STRETCH,
      renderType: K.SVG
    }, g = b(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1;
    let v = Lt.COLUMN;
    if (g) {
      const E = b(this.model.getOptions(), "legend", "position");
      E === _i.LEFT ? (v = Lt.ROW, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = Li.VERTICAL)) : E === _i.RIGHT ? (v = Lt.ROW_REVERSE, this.model.getOptions().legend.orientation || (this.model.getOptions().legend.orientation = Li.VERTICAL)) : E === _i.BOTTOM && (v = Lt.COLUMN_REVERSE);
    }
    const y = {
      id: "spacer",
      components: [new bn(this.model, this.services)],
      growth: st.PREFERRED
    }, x = {
      id: "full-frame",
      components: [
        new be(
          this.model,
          this.services,
          [
            ...g ? [p] : [],
            ...g ? [y] : [],
            m
          ],
          {
            direction: v
          }
        )
      ],
      growth: st.STRETCH
    }, S = {
      id: "zoom-bar",
      components: [new RI(this.model, this.services)],
      growth: st.PREFERRED,
      renderType: K.SVG
    }, _ = [];
    if (u || s) {
      _.push(f);
      const E = {
        id: "spacer",
        components: [
          new bn(this.model, this.services, s ? { size: 15 } : void 0)
        ],
        growth: st.PREFERRED
      };
      _.push(E);
    }
    return l && _.push(S), _.push(x), [
      new vv(this.model, this.services),
      new io(this.model, this.services),
      new be(this.model, this.services, _, {
        direction: Lt.COLUMN
      })
    ];
  }
}
class e3 extends Fe {
  constructor(t, n) {
    super(t, n), this.model = new pL(this.services), this.model.setOptions(Pt(Mt.alluvialChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new PI(this.model, this.services)];
    return this.getChartComponents(t, {
      excludeLegend: !0
    });
  }
}
class n3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Pt(xn(Mt.areaChart), n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new kn(this.model, this.services),
      new Lr(this.model, this.services),
      new yv(this.model, this.services),
      new Ze(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0
      }),
      new ue(this.model, this.services, {
        skeleton: qt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class r3 extends me {
  constructor(t, n) {
    super(t, n), this.model = new gL(this.services), this.model.setOptions(Pt(Mt.boxplotChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new VI(this.model, this.services),
      new Yr(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(t, {
      legend: {
        enabled: !1
      }
    });
  }
}
class i3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Pt(Mt.bubbleChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new kn(this.model, this.services),
      new HI(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class s3 extends me {
  constructor(t, n) {
    super(t, n), this.model = new mL(this.services), this.model.setOptions(Pt(Mt.bulletChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new FI(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class a3 extends Fe {
  constructor(t, n) {
    super(t, n), this.model = new vL(this.services), this.model.setOptions(
      Pt(Mt.choroplethChart, n.options)
    ), this.init(t, n);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getChartComponents(t, n) {
    const r = this.model.getOptions(), i = b(r, "toolbar", "enabled"), s = !!this.model.getOptions().title, a = {
      id: "title",
      components: [new is(this.model, this.services)],
      growth: st.STRETCH
    }, o = {
      id: "toolbar",
      components: [new ro(this.model, this.services)],
      growth: st.PREFERRED
    }, l = {
      id: "header",
      components: [
        new be(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            a,
            ...i ? [o] : []
          ],
          {
            direction: Lt.ROW,
            alignItems: Wr.CENTER
          }
        )
      ],
      growth: st.PREFERRED
    }, c = {
      id: "legend",
      components: [
        new bv(this.model, this.services, {
          chartType: "choropleth"
        })
      ],
      growth: st.PREFERRED,
      renderType: K.SVG
    }, u = {
      id: "graph-frame",
      components: t,
      growth: st.STRETCH,
      renderType: K.SVG
    }, h = b(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1, d = Lt.COLUMN_REVERSE, f = {
      id: "spacer",
      components: [new bn(this.model, this.services, { size: 15 })],
      growth: st.PREFERRED
    }, p = {
      id: "full-frame",
      components: [
        new be(
          this.model,
          this.services,
          [
            ...h ? [c] : [],
            ...h ? [f] : [],
            u
          ],
          {
            direction: d
          }
        )
      ],
      growth: st.STRETCH
    }, m = [];
    if (s || i) {
      m.push(l);
      const g = {
        id: "spacer",
        components: [
          new bn(this.model, this.services, i ? { size: 15 } : void 0)
        ],
        growth: st.PREFERRED
      };
      m.push(g);
    }
    return m.push(p), [
      new su(this.model, this.services),
      new io(this.model, this.services),
      new be(this.model, this.services, m, {
        direction: Lt.COLUMN
      })
    ];
  }
  getComponents() {
    const t = [new YU(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class o3 extends Fe {
  constructor(t, n) {
    super(t, n), this.model = new yL(this.services), this.model.setOptions(Pt(Mt.circlePackChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new aN(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
const Ef = {
  [Te.LINE]: [Lr, Ze],
  [Te.SCATTER]: [Ze],
  [Te.AREA]: [yv, Lr, Ze],
  [Te.STACKED_AREA]: [Sv, Lr, Tv, $a],
  [Te.SIMPLE_BAR]: [Ev],
  [Te.GROUPED_BAR]: [_v, Yr],
  [Te.STACKED_BAR]: [Ov, $a]
};
class l3 extends me {
  constructor(t, n) {
    super(t, n);
    const r = Pt(Mt.comboChart, n.options);
    n.options.comboChartTypes || (console.error("No comboChartTypes defined for the Combo Chart!"), r.comboChartTypes = [{ type: Te.LINE, correspondingDatasets: [] }]), this.model.setOptions(r), this.init(t, n);
  }
  getGraphComponents() {
    const { comboChartTypes: t } = this.model.getOptions();
    let n = 0;
    const r = t.map((i) => {
      const s = i.type;
      let a;
      if (typeof i.type == "string") {
        if (!Object.keys(Ef).includes(i.type))
          return console.error(
            `Invalid chart type "${i.type}" specified for combo chart. Please refer to the ComboChart tutorial for more guidance.`
          ), null;
        let o = !1;
        const l = `${t3(i.type)}Chart`;
        return a = rt(
          {},
          Mt[l],
          this.model.getOptions(),
          i.options
        ), i.type === Te.STACKED_AREA && (o = !0), Ef[i.type].map(
          (c) => new c(this.model, this.services, {
            groups: i.correspondingDatasets,
            id: n++,
            options: a,
            stacked: o
          })
        );
      } else
        return a = rt({}, this.model.getOptions(), i.options), new s(this.model, this.services, {
          groups: i.correspondingDatasets,
          id: n++,
          options: a
        });
    }).filter((i) => i !== null);
    return Av(r);
  }
  getComponents() {
    const { comboChartTypes: t } = this.model.getOptions(), n = t.some(
      (i) => i.type === Te.STACKED_BAR || i.type === Te.STACKED_AREA
    ), r = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.GRID
      }),
      ...n ? [] : [new kn(this.model, this.services)],
      ...this.getGraphComponents()
    ];
    return this.getAxisChartComponents(r);
  }
}
class Uv extends Fe {
  // TODO - Optimize the use of "extending"
  constructor(t, n, r = !1) {
    super(t, n), this.model = new xL(this.services), !r && (this.model.setOptions(Pt(Mt.pieChart, n.options)), this.init(t, n));
  }
  getComponents() {
    const t = [
      new wv(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.PIE
      })
    ];
    return this.getChartComponents(t);
  }
}
class c3 extends Uv {
  constructor(t, n) {
    super(t, n, !0), this.model.setOptions(Pt(Mt.donutChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new lN(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.DONUT
      })
    ];
    return this.getChartComponents(t);
  }
}
class u3 extends Fe {
  constructor(t, n) {
    super(t, n), this.model = new bL(this.services), this.model.setOptions(Pt(Mt.gaugeChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new cN(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class h3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Pt(Mt.groupedBarChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new _v(this.model, this.services),
      new Yr(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class d3 extends me {
  constructor(t, n) {
    super(t, n), this.model = new wL(this.services), this.model.setOptions(Pt(Mt.heatmapChart, n.options)), this.init(t, n);
  }
  // Custom getChartComponents - Implements getChartComponents
  // Removes zoombar support and additional `features` that are not supported in heatmap
  getAxisChartComponents(t, n) {
    const r = this.model.getOptions(), i = b(r, "toolbar", "enabled");
    this.services.cartesianScales.determineAxisDuality(), this.services.cartesianScales.findDomainAndRangeAxes(), this.services.cartesianScales.determineOrientation();
    const s = !!this.model.getOptions().title, a = {
      id: "title",
      components: [new is(this.model, this.services)],
      growth: st.STRETCH
    }, o = {
      id: "toolbar",
      components: [new ro(this.model, this.services)],
      growth: st.PREFERRED
    }, l = {
      id: "header",
      components: [
        new be(
          this.model,
          this.services,
          [
            // always add title to keep layout correct
            a,
            ...i ? [o] : []
          ],
          {
            direction: Lt.ROW,
            alignItems: Wr.CENTER
          }
        )
      ],
      growth: st.PREFERRED
    }, c = {
      id: "legend",
      components: [
        new bv(this.model, this.services, {
          chartType: "heatmap"
        })
      ],
      growth: st.PREFERRED,
      renderType: K.SVG
    }, u = {
      id: "graph-frame",
      components: t,
      growth: st.STRETCH,
      renderType: K.SVG
    }, h = b(n, "legend", "enabled") !== !1 && this.model.getOptions().legend.enabled !== !1, d = Lt.COLUMN_REVERSE, f = {
      id: "spacer",
      components: [new bn(this.model, this.services, { size: 15 })],
      growth: st.PREFERRED
    }, p = {
      id: "full-frame",
      components: [
        new be(
          this.model,
          this.services,
          [
            ...h ? [c] : [],
            ...h ? [f] : [],
            u
          ],
          {
            direction: d
          }
        )
      ],
      growth: st.STRETCH
    }, m = [];
    if (s || i) {
      m.push(l);
      const g = {
        id: "spacer",
        components: [
          new bn(this.model, this.services, i ? { size: 15 } : void 0)
        ],
        growth: st.PREFERRED
      };
      m.push(g);
    }
    return m.push(p), [
      new vv(this.model, this.services),
      new io(this.model, this.services),
      new be(this.model, this.services, m, {
        direction: Lt.COLUMN
      })
    ];
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new uN(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class f3 extends me {
  constructor(t, n) {
    super(t, n), this.model = new _L(this.services), this.model.setOptions(Pt(Mt.histogramChart, n.options)), this.init(t, n), this.update();
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new KI(this.model, this.services),
      new hN(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class p3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Pt(Mt.lineChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new kn(this.model, this.services),
      new Lr(this.model, this.services),
      new Ze(this.model, this.services, { handleThresholds: !0 }),
      new gN(this.model, this.services),
      new Yr(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class g3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Pt(Mt.lollipopChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new kn(this.model, this.services),
      new dN(this.model, this.services),
      new Ze(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class m3 extends Fe {
  constructor(t, n) {
    var r;
    super(t, n), this.model = new EL(this.services);
    const i = (r = n.options.meter) != null && r.proportional ? rt(xn(Mt.proportionalMeterChart), n.options) : rt(xn(Mt.meterChart), n.options);
    this.model.setOptions(i), this.init(t, n);
  }
  getComponents() {
    const t = [
      ...b(this.model.getOptions(), "meter", "showLabels") ? [
        // Meter has a unique dataset title within the graph
        {
          id: "meter-title",
          components: [new sN(this.model, this.services)],
          growth: st.STRETCH,
          renderType: K.SVG
        },
        // Create the title spacer
        {
          id: "spacer",
          components: [
            new bn(this.model, this.services, {
              size: 8
            })
          ],
          growth: st.STRETCH
        }
      ] : [],
      // Specify what to render inside the graph only
      {
        id: "meter-graph",
        components: [new fN(this.model, this.services)],
        growth: st.STRETCH,
        renderType: K.SVG
      }
    ], n = [
      new be(this.model, this.services, t, {
        direction: Lt.COLUMN
      })
    ];
    return this.getChartComponents(n, {
      graphFrameRenderType: K.HTML
    });
  }
}
class v3 extends Fe {
  constructor(t, n) {
    super(t, n), this.model = new SL(this.services), this.model.setOptions(Pt(Mt.radarChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new pN(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class y3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Pt(Mt.scatterChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new kn(this.model, this.services),
      new Ze(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class x3 extends Fe {
  constructor(t, n) {
    super(t, n), this.model = new OL(this.services), this.model.setOptions(Pt(Mt.treeChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new mN(this.model, this.services)];
    return this.getChartComponents(t, {
      excludeLegend: !0
    });
  }
}
class b3 extends Fe {
  constructor(t, n) {
    super(t, n), this.model = new TL(this.services), this.model.setOptions(Pt(Mt.treemapChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [new jU(this.model, this.services)];
    return this.getChartComponents(t);
  }
}
class w3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Pt(Mt.simpleBarChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new Ev(this.model, this.services),
      new Yr(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.VERT_OR_HORIZ
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class _3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Pt(Mt.stackedAreaChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new $a(this.model, this.services),
      new Sv(this.model, this.services),
      new Lr(this.model, this.services, { stacked: !0 }),
      new Tv(this.model, this.services, {
        fadeInOnChartHolderMouseover: !0,
        handleThresholds: !0,
        stacked: !0
      }),
      new ue(this.model, this.services, {
        skeleton: qt.GRID
      })
    ];
    return this.getAxisChartComponents(t);
  }
}
class E3 extends me {
  constructor(t, n) {
    super(t, n), this.model.setOptions(Pt(Mt.stackedBarChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new ge(this.model, this.services),
      new Ee(this.model, this.services),
      new $a(this.model, this.services),
      new Ov(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.VERT_OR_HORIZ
      }),
      new Yr(this.model, this.services)
    ];
    return this.getAxisChartComponents(t);
  }
}
class S3 extends Fe {
  constructor(t, n) {
    super(t, n), this.model = new ML(this.services), this.model.setOptions(Pt(Mt.wordCloudChart, n.options)), this.init(t, n);
  }
  getComponents() {
    const t = [
      new WU(this.model, this.services),
      new ue(this.model, this.services, {
        skeleton: qt.PIE
      })
    ];
    return this.getChartComponents(t);
  }
}
var oc = { exports: {} }, ai = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Sf;
function O3() {
  if (Sf)
    return ai;
  Sf = 1;
  var e = Us, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(o, l, c) {
    var u, h = {}, d = null, f = null;
    c !== void 0 && (d = "" + c), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (f = l.ref);
    for (u in l)
      r.call(l, u) && !s.hasOwnProperty(u) && (h[u] = l[u]);
    if (o && o.defaultProps)
      for (u in l = o.defaultProps, l)
        h[u] === void 0 && (h[u] = l[u]);
    return { $$typeof: t, type: o, key: d, ref: f, props: h, _owner: i.current };
  }
  return ai.Fragment = n, ai.jsx = a, ai.jsxs = a, ai;
}
var oi = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Of;
function T3() {
  return Of || (Of = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Us, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), o = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), p = Symbol.iterator, m = "@@iterator";
    function g($) {
      if ($ === null || typeof $ != "object")
        return null;
      var G = p && $[p] || $[m];
      return typeof G == "function" ? G : null;
    }
    var v = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function y($) {
      {
        for (var G = arguments.length, q = new Array(G > 1 ? G - 1 : 0), it = 1; it < G; it++)
          q[it - 1] = arguments[it];
        x("error", $, q);
      }
    }
    function x($, G, q) {
      {
        var it = v.ReactDebugCurrentFrame, yt = it.getStackAddendum();
        yt !== "" && (G += "%s", q = q.concat([yt]));
        var Tt = q.map(function(gt) {
          return String(gt);
        });
        Tt.unshift("Warning: " + G), Function.prototype.apply.call(console[$], console, Tt);
      }
    }
    var S = !1, _ = !1, E = !1, T = !1, k = !1, N;
    N = Symbol.for("react.module.reference");
    function L($) {
      return !!(typeof $ == "string" || typeof $ == "function" || $ === r || $ === s || k || $ === i || $ === c || $ === u || T || $ === f || S || _ || E || typeof $ == "object" && $ !== null && ($.$$typeof === d || $.$$typeof === h || $.$$typeof === a || $.$$typeof === o || $.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      $.$$typeof === N || $.getModuleId !== void 0));
    }
    function C($, G, q) {
      var it = $.displayName;
      if (it)
        return it;
      var yt = G.displayName || G.name || "";
      return yt !== "" ? q + "(" + yt + ")" : q;
    }
    function V($) {
      return $.displayName || "Context";
    }
    function M($) {
      if ($ == null)
        return null;
      if (typeof $.tag == "number" && y("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof $ == "function")
        return $.displayName || $.name || null;
      if (typeof $ == "string")
        return $;
      switch ($) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case c:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof $ == "object")
        switch ($.$$typeof) {
          case o:
            var G = $;
            return V(G) + ".Consumer";
          case a:
            var q = $;
            return V(q._context) + ".Provider";
          case l:
            return C($, $.render, "ForwardRef");
          case h:
            var it = $.displayName || null;
            return it !== null ? it : M($.type) || "Memo";
          case d: {
            var yt = $, Tt = yt._payload, gt = yt._init;
            try {
              return M(gt(Tt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var A = Object.assign, w = 0, P, U, I, B, j, Y, J;
    function ft() {
    }
    ft.__reactDisabledLog = !0;
    function z() {
      {
        if (w === 0) {
          P = console.log, U = console.info, I = console.warn, B = console.error, j = console.group, Y = console.groupCollapsed, J = console.groupEnd;
          var $ = {
            configurable: !0,
            enumerable: !0,
            value: ft,
            writable: !0
          };
          Object.defineProperties(console, {
            info: $,
            log: $,
            warn: $,
            error: $,
            group: $,
            groupCollapsed: $,
            groupEnd: $
          });
        }
        w++;
      }
    }
    function Z() {
      {
        if (w--, w === 0) {
          var $ = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: A({}, $, {
              value: P
            }),
            info: A({}, $, {
              value: U
            }),
            warn: A({}, $, {
              value: I
            }),
            error: A({}, $, {
              value: B
            }),
            group: A({}, $, {
              value: j
            }),
            groupCollapsed: A({}, $, {
              value: Y
            }),
            groupEnd: A({}, $, {
              value: J
            })
          });
        }
        w < 0 && y("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ut = v.ReactCurrentDispatcher, nt;
    function Ot($, G, q) {
      {
        if (nt === void 0)
          try {
            throw Error();
          } catch (yt) {
            var it = yt.stack.trim().match(/\n( *(at )?)/);
            nt = it && it[1] || "";
          }
        return `
` + nt + $;
      }
    }
    var W = !1, Q;
    {
      var lt = typeof WeakMap == "function" ? WeakMap : Map;
      Q = new lt();
    }
    function F($, G) {
      if (!$ || W)
        return "";
      {
        var q = Q.get($);
        if (q !== void 0)
          return q;
      }
      var it;
      W = !0;
      var yt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Tt;
      Tt = ut.current, ut.current = null, z();
      try {
        if (G) {
          var gt = function() {
            throw Error();
          };
          if (Object.defineProperty(gt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(gt, []);
            } catch (tn) {
              it = tn;
            }
            Reflect.construct($, [], gt);
          } else {
            try {
              gt.call();
            } catch (tn) {
              it = tn;
            }
            $.call(gt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (tn) {
            it = tn;
          }
          $();
        }
      } catch (tn) {
        if (tn && it && typeof tn.stack == "string") {
          for (var pt = tn.stack.split(`
`), oe = it.stack.split(`
`), Ft = pt.length - 1, jt = oe.length - 1; Ft >= 1 && jt >= 0 && pt[Ft] !== oe[jt]; )
            jt--;
          for (; Ft >= 1 && jt >= 0; Ft--, jt--)
            if (pt[Ft] !== oe[jt]) {
              if (Ft !== 1 || jt !== 1)
                do
                  if (Ft--, jt--, jt < 0 || pt[Ft] !== oe[jt]) {
                    var Se = `
` + pt[Ft].replace(" at new ", " at ");
                    return $.displayName && Se.includes("<anonymous>") && (Se = Se.replace("<anonymous>", $.displayName)), typeof $ == "function" && Q.set($, Se), Se;
                  }
                while (Ft >= 1 && jt >= 0);
              break;
            }
        }
      } finally {
        W = !1, ut.current = Tt, Z(), Error.prepareStackTrace = yt;
      }
      var cr = $ ? $.displayName || $.name : "", wu = cr ? Ot(cr) : "";
      return typeof $ == "function" && Q.set($, wu), wu;
    }
    function It($, G, q) {
      return F($, !1);
    }
    function vt($) {
      var G = $.prototype;
      return !!(G && G.isReactComponent);
    }
    function Gt($, G, q) {
      if ($ == null)
        return "";
      if (typeof $ == "function")
        return F($, vt($));
      if (typeof $ == "string")
        return Ot($);
      switch ($) {
        case c:
          return Ot("Suspense");
        case u:
          return Ot("SuspenseList");
      }
      if (typeof $ == "object")
        switch ($.$$typeof) {
          case l:
            return It($.render);
          case h:
            return Gt($.type, G, q);
          case d: {
            var it = $, yt = it._payload, Tt = it._init;
            try {
              return Gt(Tt(yt), G, q);
            } catch {
            }
          }
        }
      return "";
    }
    var zt = Object.prototype.hasOwnProperty, tt = {}, Dt = v.ReactDebugCurrentFrame;
    function Ge($) {
      if ($) {
        var G = $._owner, q = Gt($.type, $._source, G ? G.type : null);
        Dt.setExtraStackFrame(q);
      } else
        Dt.setExtraStackFrame(null);
    }
    function ze($, G, q, it, yt) {
      {
        var Tt = Function.call.bind(zt);
        for (var gt in $)
          if (Tt($, gt)) {
            var pt = void 0;
            try {
              if (typeof $[gt] != "function") {
                var oe = Error((it || "React class") + ": " + q + " type `" + gt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof $[gt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw oe.name = "Invariant Violation", oe;
              }
              pt = $[gt](G, gt, it, q, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ft) {
              pt = Ft;
            }
            pt && !(pt instanceof Error) && (Ge(yt), y("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", it || "React class", q, gt, typeof pt), Ge(null)), pt instanceof Error && !(pt.message in tt) && (tt[pt.message] = !0, Ge(yt), y("Failed %s type: %s", q, pt.message), Ge(null));
          }
      }
    }
    var Vv = Array.isArray;
    function ao($) {
      return Vv($);
    }
    function Hv($) {
      {
        var G = typeof Symbol == "function" && Symbol.toStringTag, q = G && $[Symbol.toStringTag] || $.constructor.name || "Object";
        return q;
      }
    }
    function Fv($) {
      try {
        return hu($), !1;
      } catch {
        return !0;
      }
    }
    function hu($) {
      return "" + $;
    }
    function du($) {
      if (Fv($))
        return y("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Hv($)), hu($);
    }
    var Zr = v.ReactCurrentOwner, Gv = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, fu, pu, oo;
    oo = {};
    function zv($) {
      if (zt.call($, "ref")) {
        var G = Object.getOwnPropertyDescriptor($, "ref").get;
        if (G && G.isReactWarning)
          return !1;
      }
      return $.ref !== void 0;
    }
    function jv($) {
      if (zt.call($, "key")) {
        var G = Object.getOwnPropertyDescriptor($, "key").get;
        if (G && G.isReactWarning)
          return !1;
      }
      return $.key !== void 0;
    }
    function Wv($, G) {
      if (typeof $.ref == "string" && Zr.current && G && Zr.current.stateNode !== G) {
        var q = M(Zr.current.type);
        oo[q] || (y('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', M(Zr.current.type), $.ref), oo[q] = !0);
      }
    }
    function qv($, G) {
      {
        var q = function() {
          fu || (fu = !0, y("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", G));
        };
        q.isReactWarning = !0, Object.defineProperty($, "key", {
          get: q,
          configurable: !0
        });
      }
    }
    function Yv($, G) {
      {
        var q = function() {
          pu || (pu = !0, y("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", G));
        };
        q.isReactWarning = !0, Object.defineProperty($, "ref", {
          get: q,
          configurable: !0
        });
      }
    }
    var Xv = function($, G, q, it, yt, Tt, gt) {
      var pt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: $,
        key: G,
        ref: q,
        props: gt,
        // Record the component responsible for creating this element.
        _owner: Tt
      };
      return pt._store = {}, Object.defineProperty(pt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: it
      }), Object.defineProperty(pt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: yt
      }), Object.freeze && (Object.freeze(pt.props), Object.freeze(pt)), pt;
    };
    function Zv($, G, q, it, yt) {
      {
        var Tt, gt = {}, pt = null, oe = null;
        q !== void 0 && (du(q), pt = "" + q), jv(G) && (du(G.key), pt = "" + G.key), zv(G) && (oe = G.ref, Wv(G, yt));
        for (Tt in G)
          zt.call(G, Tt) && !Gv.hasOwnProperty(Tt) && (gt[Tt] = G[Tt]);
        if ($ && $.defaultProps) {
          var Ft = $.defaultProps;
          for (Tt in Ft)
            gt[Tt] === void 0 && (gt[Tt] = Ft[Tt]);
        }
        if (pt || oe) {
          var jt = typeof $ == "function" ? $.displayName || $.name || "Unknown" : $;
          pt && qv(gt, jt), oe && Yv(gt, jt);
        }
        return Xv($, pt, oe, yt, it, Zr.current, gt);
      }
    }
    var lo = v.ReactCurrentOwner, gu = v.ReactDebugCurrentFrame;
    function lr($) {
      if ($) {
        var G = $._owner, q = Gt($.type, $._source, G ? G.type : null);
        gu.setExtraStackFrame(q);
      } else
        gu.setExtraStackFrame(null);
    }
    var co;
    co = !1;
    function uo($) {
      return typeof $ == "object" && $ !== null && $.$$typeof === t;
    }
    function mu() {
      {
        if (lo.current) {
          var $ = M(lo.current.type);
          if ($)
            return `

Check the render method of \`` + $ + "`.";
        }
        return "";
      }
    }
    function Kv($) {
      {
        if ($ !== void 0) {
          var G = $.fileName.replace(/^.*[\\\/]/, ""), q = $.lineNumber;
          return `

Check your code at ` + G + ":" + q + ".";
        }
        return "";
      }
    }
    var vu = {};
    function Qv($) {
      {
        var G = mu();
        if (!G) {
          var q = typeof $ == "string" ? $ : $.displayName || $.name;
          q && (G = `

Check the top-level render call using <` + q + ">.");
        }
        return G;
      }
    }
    function yu($, G) {
      {
        if (!$._store || $._store.validated || $.key != null)
          return;
        $._store.validated = !0;
        var q = Qv(G);
        if (vu[q])
          return;
        vu[q] = !0;
        var it = "";
        $ && $._owner && $._owner !== lo.current && (it = " It was passed a child from " + M($._owner.type) + "."), lr($), y('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', q, it), lr(null);
      }
    }
    function xu($, G) {
      {
        if (typeof $ != "object")
          return;
        if (ao($))
          for (var q = 0; q < $.length; q++) {
            var it = $[q];
            uo(it) && yu(it, G);
          }
        else if (uo($))
          $._store && ($._store.validated = !0);
        else if ($) {
          var yt = g($);
          if (typeof yt == "function" && yt !== $.entries)
            for (var Tt = yt.call($), gt; !(gt = Tt.next()).done; )
              uo(gt.value) && yu(gt.value, G);
        }
      }
    }
    function Jv($) {
      {
        var G = $.type;
        if (G == null || typeof G == "string")
          return;
        var q;
        if (typeof G == "function")
          q = G.propTypes;
        else if (typeof G == "object" && (G.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        G.$$typeof === h))
          q = G.propTypes;
        else
          return;
        if (q) {
          var it = M(G);
          ze(q, $.props, "prop", it, $);
        } else if (G.PropTypes !== void 0 && !co) {
          co = !0;
          var yt = M(G);
          y("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", yt || "Unknown");
        }
        typeof G.getDefaultProps == "function" && !G.getDefaultProps.isReactClassApproved && y("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function t0($) {
      {
        for (var G = Object.keys($.props), q = 0; q < G.length; q++) {
          var it = G[q];
          if (it !== "children" && it !== "key") {
            lr($), y("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", it), lr(null);
            break;
          }
        }
        $.ref !== null && (lr($), y("Invalid attribute `ref` supplied to `React.Fragment`."), lr(null));
      }
    }
    function bu($, G, q, it, yt, Tt) {
      {
        var gt = L($);
        if (!gt) {
          var pt = "";
          ($ === void 0 || typeof $ == "object" && $ !== null && Object.keys($).length === 0) && (pt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var oe = Kv(yt);
          oe ? pt += oe : pt += mu();
          var Ft;
          $ === null ? Ft = "null" : ao($) ? Ft = "array" : $ !== void 0 && $.$$typeof === t ? (Ft = "<" + (M($.type) || "Unknown") + " />", pt = " Did you accidentally export a JSX literal instead of a component?") : Ft = typeof $, y("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ft, pt);
        }
        var jt = Zv($, G, q, yt, Tt);
        if (jt == null)
          return jt;
        if (gt) {
          var Se = G.children;
          if (Se !== void 0)
            if (it)
              if (ao(Se)) {
                for (var cr = 0; cr < Se.length; cr++)
                  xu(Se[cr], $);
                Object.freeze && Object.freeze(Se);
              } else
                y("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              xu(Se, $);
        }
        return $ === r ? t0(jt) : Jv(jt), jt;
      }
    }
    function e0($, G, q) {
      return bu($, G, q, !0);
    }
    function n0($, G, q) {
      return bu($, G, q, !1);
    }
    var r0 = n0, i0 = e0;
    oi.Fragment = r, oi.jsx = r0, oi.jsxs = i0;
  }()), oi;
}
process.env.NODE_ENV === "production" ? oc.exports = O3() : oc.exports = T3();
var Nt = oc.exports;
class Rt extends Us.PureComponent {
  constructor() {
    super(...arguments);
    ho(this, "chart");
    ho(this, "chartRef", Us.createRef());
  }
  // TODO: add abstract keyword once React 16 support no longer needed then remove the next 3 comments
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createChart(n, r, i) {
    throw new Error("Method not implemented.");
  }
  componentDidMount() {
    this.chartRef.current && !this.chart && (this.chart = this.createChart(this.chartRef.current, this.props.data, this.props.options));
  }
  componentDidUpdate(n) {
    var r, i;
    this.props.data !== n.data && ((r = this.chart) == null || r.model.setData(this.props.data)), this.props.options !== n.options && ((i = this.chart) == null || i.model.setOptions(this.props.options));
  }
  render() {
    return /* @__PURE__ */ Nt.jsx("div", { ref: this.chartRef, className: "chart-holder" });
  }
}
class Y3 extends Rt {
  createChart(t, n, r) {
    return new e3(t, { data: n, options: r });
  }
}
class X3 extends Rt {
  createChart(t, n, r) {
    return new n3(t, { data: n, options: r });
  }
}
class Z3 extends Rt {
  createChart(t, n, r) {
    return new r3(t, { data: n, options: r });
  }
}
class K3 extends Rt {
  createChart(t, n, r) {
    return new i3(t, { data: n, options: r });
  }
}
class Q3 extends Rt {
  createChart(t, n, r) {
    return new s3(t, { data: n, options: r });
  }
}
class J3 extends Rt {
  createChart(t, n, r) {
    return new a3(t, { data: n, options: r });
  }
}
class tV extends Rt {
  createChart(t, n, r) {
    return new o3(t, { data: n, options: r });
  }
}
class eV extends Rt {
  createChart(t, n, r) {
    return new l3(t, { data: n, options: r });
  }
}
class nV extends Rt {
  createChart(t, n, r) {
    return new c3(t, { data: n, options: r });
  }
}
class rV extends Rt {
  createChart(t, n, r) {
    return new u3(t, { data: n, options: r });
  }
}
class iV extends Rt {
  createChart(t, n, r) {
    return new h3(t, { data: n, options: r });
  }
}
class sV extends Rt {
  createChart(t, n, r) {
    return new d3(t, { data: n, options: r });
  }
}
class aV extends Rt {
  createChart(t, n, r) {
    return new f3(t, { data: n, options: r });
  }
}
class oV extends Rt {
  createChart(t, n, r) {
    return new p3(t, { data: n, options: r });
  }
}
class lV extends Rt {
  createChart(t, n, r) {
    return new g3(t, { data: n, options: r });
  }
}
class cV extends Rt {
  createChart(t, n, r) {
    return new m3(t, { data: n, options: r });
  }
}
class uV extends Rt {
  createChart(t, n, r) {
    return new Uv(t, { data: n, options: r });
  }
}
class hV extends Rt {
  createChart(t, n, r) {
    return new v3(t, { data: n, options: r });
  }
}
class dV extends Rt {
  createChart(t, n, r) {
    return new y3(t, { data: n, options: r });
  }
}
class fV extends Rt {
  createChart(t, n, r) {
    return new w3(t, { data: n, options: r });
  }
}
class pV extends Rt {
  createChart(t, n, r) {
    return new _3(t, { data: n, options: r });
  }
}
class gV extends Rt {
  createChart(t, n, r) {
    return new E3(t, { data: n, options: r });
  }
}
class mV extends Rt {
  createChart(t, n, r) {
    return new x3(t, { data: n, options: r });
  }
}
class vV extends Rt {
  createChart(t, n, r) {
    return new b3(t, { data: n, options: r });
  }
}
class yV extends Rt {
  createChart(t, n, r) {
    return new S3(t, { data: n, options: r });
  }
}
var Bv = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var r = [], i = 0; i < arguments.length; i++) {
        var s = arguments[i];
        if (s) {
          var a = typeof s;
          if (a === "string" || a === "number")
            r.push(s);
          else if (Array.isArray(s)) {
            if (s.length) {
              var o = n.apply(null, s);
              o && r.push(o);
            }
          } else if (a === "object") {
            if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) {
              r.push(s.toString());
              continue;
            }
            for (var l in s)
              t.call(s, l) && s[l] && r.push(l);
          }
        }
      }
      return r.join(" ");
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})(Bv);
var M3 = Bv.exports;
const Rn = /* @__PURE__ */ Gm(M3), In = "cds", xV = ({ tag: e = "div", children: t, color: n, href: r, position: i = "static", stacked: s, ...a }) => {
  const o = r ? "a" : a.onClick ? "button" : e, l = `${In}--cc--card-node`, c = Rn(l, {
    [`${l}--stacked`]: s,
    [`${l}--${o}`]: o,
    [a.className]: a.className
  });
  return /* @__PURE__ */ Nt.jsx(
    o,
    {
      className: c,
      style: { borderColor: n, position: i },
      tabIndex: 0,
      ...a,
      children: t
    }
  );
}, bV = ({
  children: e,
  farsideColumn: t = !1,
  ...n
}) => {
  const r = `${In}--cc--card-node`, i = Rn(`${r}__column`, {
    [`${r}__column--farside`]: t,
    ...n.className ? { [n.className]: !0 } : {}
  });
  return /* @__PURE__ */ Nt.jsx("div", { className: i, ...n, children: e });
}, wV = ({
  children: e,
  ...t
}) => {
  const n = `${In}--cc--card-node`, r = Rn(`${n}__label`, {
    ...t.className ? { [t.className]: !0 } : {}
  });
  return /* @__PURE__ */ Nt.jsx("label", { className: r, ...t, children: e });
}, _V = ({
  children: e,
  ...t
}) => {
  const n = `${In}--cc--card-node`, r = Rn(`${n}__subtitle`, {
    ...t.className ? { [t.className]: !0 } : {}
  });
  return /* @__PURE__ */ Nt.jsx("div", { className: r, ...t, children: e });
}, EV = ({
  children: e,
  ...t
}) => {
  const n = `${In}--cc--card-node`, r = Rn(`${n}__title`, {
    ...t.className ? { [t.className]: !0 } : {}
  });
  return /* @__PURE__ */ Nt.jsx("div", { className: r, ...t, children: e });
}, SV = ({
  color: e,
  markerEnd: t,
  markerStart: n,
  path: r,
  source: i,
  target: s,
  variant: a = null,
  ...o
}) => {
  const l = `${In}--cc--edge`, c = Rn(l, {
    [`${l}--${a}`]: a,
    ...o.className ? { [o.className]: !0 } : {}
  });
  let u = r;
  if (!u && i && s && (u = QI(i, s)), !u)
    throw Error("Missing parameters for Edge component: path or source and target.");
  return /* @__PURE__ */ Nt.jsxs("g", { className: c, ...o, children: [
    /* @__PURE__ */ Nt.jsx("path", { d: u, className: `${l}__container` }),
    /* @__PURE__ */ Nt.jsx("path", { d: u, className: `${l}__outer` }),
    /* @__PURE__ */ Nt.jsx(
      "path",
      {
        d: u,
        className: `${l}__inner`,
        markerEnd: `url(#${t})`,
        markerStart: `url(#${n})`,
        style: { stroke: e }
      }
    )
  ] });
}, Xr = ({
  color: e,
  d: t,
  id: n,
  orient: r = "auto",
  height: i,
  width: s,
  position: a = "end",
  className: o,
  refX: l,
  refY: c,
  ...u
}) => {
  const h = `${In}--cc--marker`, d = Rn(h, o), f = a === "end" ? (s || 0) / 2 + 0.5 : 0.5, p = (i || 0) / 2;
  return /* @__PURE__ */ Nt.jsx(
    "marker",
    {
      className: d,
      markerHeight: i,
      markerWidth: s,
      orient: r,
      id: n,
      refX: l || f,
      refY: c || p,
      markerUnits: "userSpaceOnUse",
      ...u,
      children: /* @__PURE__ */ Nt.jsx("path", { d: t, style: { fill: e } })
    }
  );
}, OV = (e) => /* @__PURE__ */ Nt.jsx(Xr, { d: JI.d, ...e }), TV = (e) => /* @__PURE__ */ Nt.jsx(Xr, { d: tN.d, ...e }), MV = (e) => /* @__PURE__ */ Nt.jsx(Xr, { d: eN.d, ...e }), CV = (e) => /* @__PURE__ */ Nt.jsx(Xr, { d: nN.d, ...e }), $V = (e) => /* @__PURE__ */ Nt.jsx(Xr, { d: rN.d, ...e }), AV = (e) => /* @__PURE__ */ Nt.jsx(Xr, { d: iN.d, ...e }), LV = ({
  shape: e = "circle",
  tag: t = "div",
  title: n = "Title",
  subtitle: r,
  description: i,
  renderIcon: s,
  href: a,
  size: o = 48,
  stacked: l,
  position: c = "fixed",
  bodyPosition: u = "absolute",
  ...h
}) => {
  const d = a ? "a" : h.onClick ? "button" : t, f = `${In}--cc--shape-node`, p = Rn(f, {
    [`${f}--stacked`]: l,
    [`${f}--${e}`]: e,
    [`${f}--${d}`]: d,
    [h.className]: h.className
  }), m = n ? /* @__PURE__ */ Nt.jsx("div", { className: `${f}__title`, children: n }) : null, g = r ? /* @__PURE__ */ Nt.jsx("div", { className: `${f}__subtitle`, children: r }) : null, v = i ? /* @__PURE__ */ Nt.jsx("div", { className: `${f}__description`, children: i }) : null;
  return /* @__PURE__ */ Nt.jsxs(
    d,
    {
      className: p,
      style: { height: o, width: o, position: c },
      tabIndex: 0,
      ...h,
      children: [
        /* @__PURE__ */ Nt.jsx("div", { className: `${f}__icon`, children: s }),
        /* @__PURE__ */ Nt.jsxs("div", { className: `${f}__body`, style: { position: u }, children: [
          m,
          g,
          v
        ] })
      ]
    }
  );
};
export {
  Y3 as AlluvialChart,
  X3 as AreaChart,
  OV as ArrowLeftMarker,
  TV as ArrowRightMarker,
  Z3 as BoxplotChart,
  K3 as BubbleChart,
  Q3 as BulletChart,
  xV as CardNode,
  bV as CardNodeColumn,
  wV as CardNodeLabel,
  _V as CardNodeSubtitle,
  EV as CardNodeTitle,
  MV as CircleMarker,
  tV as CirclePackChart,
  eV as ComboChart,
  CV as DiamondMarker,
  nV as DonutChart,
  SV as Edge,
  J3 as ExperimentalChoroplethChart,
  rV as GaugeChart,
  iV as GroupedBarChart,
  sV as HeatmapChart,
  aV as HistogramChart,
  oV as LineChart,
  lV as LollipopChart,
  Xr as Marker,
  cV as MeterChart,
  uV as PieChart,
  hV as RadarChart,
  dV as ScatterChart,
  LV as ShapeNode,
  fV as SimpleBarChart,
  $V as SquareMarker,
  pV as StackedAreaChart,
  gV as StackedBarChart,
  AV as TeeMarker,
  mV as TreeChart,
  vV as TreemapChart,
  yV as WordCloudChart
};
//# sourceMappingURL=index.mjs.map
