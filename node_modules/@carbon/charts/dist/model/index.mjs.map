{"version":3,"file":"index.mjs","sources":["../../../../node_modules/lodash-es/_arrayAggregator.js","../../../../node_modules/lodash-es/_baseAggregator.js","../../../../node_modules/lodash-es/_createAggregator.js","../../../../node_modules/lodash-es/fromPairs.js","../../../../node_modules/lodash-es/groupBy.js","../../src/model/model.ts","../../src/model/cartesian-charts.ts","../../src/model/alluvial.ts","../../src/model/boxplot.ts","../../src/model/bullet.ts","../../src/model/choropleth.ts","../../src/model/circle-pack.ts","../../src/model/pie.ts","../../src/model/gauge.ts","../../src/model/heatmap.ts","../../src/model/binned-charts.ts","../../src/model/meter.ts","../../src/model/radar.ts","../../src/model/tree.ts","../../src/model/treemap.ts","../../src/model/wordcloud.ts"],"sourcesContent":["/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nexport default arrayAggregator;\n","import baseEach from './_baseEach.js';\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nexport default baseAggregator;\n","import arrayAggregator from './_arrayAggregator.js';\nimport baseAggregator from './_baseAggregator.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nexport default createAggregator;\n","/**\n * The inverse of `_.toPairs`; this method returns an object composed\n * from key-value `pairs`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} pairs The key-value pairs.\n * @returns {Object} Returns the new object.\n * @example\n *\n * _.fromPairs([['a', 1], ['b', 2]]);\n * // => { 'a': 1, 'b': 2 }\n */\nfunction fromPairs(pairs) {\n  var index = -1,\n      length = pairs == null ? 0 : pairs.length,\n      result = {};\n\n  while (++index < length) {\n    var pair = pairs[index];\n    result[pair[0]] = pair[1];\n  }\n  return result;\n}\n\nexport default fromPairs;\n","import baseAssignValue from './_baseAssignValue.js';\nimport createAggregator from './_createAggregator.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nexport default groupBy;\n","import { bin as d3Bin, scaleOrdinal, stack, stackOffsetDiverging } from 'd3'\nimport {\n\tcloneDeep,\n\tfromPairs,\n\tgroupBy,\n\tmerge,\n\tuniq,\n} from 'lodash-es'\nimport { getProperty, updateLegendAdditionalItems } from '@/tools'\nimport { color as colorConfigs, legend as legendConfigs } from '@/configuration'\nimport { histogram as histogramConfigs } from '@/configuration-non-customizable'\nimport { Events, ScaleTypes, ColorClassNameTypes } from '@/interfaces/enums'\nimport { formatDateTillMilliSeconds } from '@/services/time-series'\nimport type { ChartTabularData } from '@/interfaces/model'\n\nexport type StackKeysParams = {\n\tbins?: any\n\tgroups?: any\n\tpercentage?: any\n\tdivergent?: any\n}\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class ChartModel {\n\tprotected services: any\n\n\t// Internal Model state\n\tprotected state: any = {\n\t\toptions: {}\n\t}\n\n\t// Data labels\n\t/**\n\t * A list of all the data groups that have existed within the lifetime of the chart\n\t * @type string[]\n\t */\n\tprotected allDataGroups: string[]\n\n\t// Fill scales & fill related objects\n\tprotected colorScale: any = {}\n\n\tprotected colorClassNames: any = {}\n\n\tconstructor(services: any) {\n\t\tthis.services = services\n\t}\n\n\tgetAllDataFromDomain(groups?: any) {\n\t\tif (!this.getData()) {\n\t\t\treturn null\n\t\t}\n\t\tconst options = this.getOptions()\n\t\t// Remove datasets that have been disabled\n\t\tlet allData = this.getData()\n\t\tconst dataGroups = this.getDataGroups()\n\t\tconst { groupMapsTo } = getProperty(options, 'data')\n\t\tconst axesOptions = getProperty(options, 'axes')\n\n\t\t// filter out the groups that are irrelevant to the component\n\t\tif (groups) {\n\t\t\tallData = allData.filter((item: any) => groups.includes(item[groupMapsTo]))\n\t\t}\n\n\t\tif (axesOptions) {\n\t\t\tObject.keys(axesOptions).forEach((axis) => {\n\t\t\t\tconst mapsTo = axesOptions[axis].mapsTo\n\t\t\t\tconst scaleType = axesOptions[axis].scaleType\n\t\t\t\t// make sure linear/log values are numbers\n\t\t\t\tif (scaleType === ScaleTypes.LINEAR || scaleType === ScaleTypes.LOG) {\n\t\t\t\t\tallData = allData.map((datum: any) => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...datum,\n\t\t\t\t\t\t\t[mapsTo]: datum[mapsTo] === null ? datum[mapsTo] : Number(datum[mapsTo])\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\t// Check for custom domain\n\t\t\t\tif (mapsTo && axesOptions[axis].domain) {\n\t\t\t\t\tif (scaleType === ScaleTypes.LABELS) {\n\t\t\t\t\t\tallData = allData.filter((datum: any) =>\n\t\t\t\t\t\t\taxesOptions[axis].domain.includes(datum[mapsTo])\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst [start, end] = axesOptions[axis].domain\n\t\t\t\t\t\t// Filter out data outside domain if that datapoint is using that axis (has mapsTo property)\n\t\t\t\t\t\tallData = allData.filter(\n\t\t\t\t\t\t\t(datum: any) => !(mapsTo in datum) || (datum[mapsTo] >= start && datum[mapsTo] <= end)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn allData.filter((datum: any) => {\n\t\t\treturn dataGroups.find((group: any) => group.name === datum[groupMapsTo])\n\t\t})\n\t}\n\n\t/**\n\t * Charts that have group configs passed into them, only want to retrieve the display data relevant to that chart\n\t * @param groups the included datasets for the particular chart\n\t */\n\tgetDisplayData(groups?: any) {\n\t\tif (!this.get('data')) {\n\t\t\treturn null\n\t\t}\n\n\t\tconst { ACTIVE } = legendConfigs.items.status\n\t\tconst dataGroups = this.getDataGroups(groups)\n\t\tconst { groupMapsTo } = this.getOptions().data\n\t\tconst allDataFromDomain = this.getAllDataFromDomain(groups)\n\n\t\treturn allDataFromDomain.filter((datum: any) => {\n\t\t\treturn dataGroups.find(\n\t\t\t\t(dataGroup: any) => dataGroup.name === datum[groupMapsTo] && dataGroup.status === ACTIVE\n\t\t\t)\n\t\t})\n\t}\n\n\tgetData() {\n\t\treturn this.get('data')\n\t}\n\n\tisDataEmpty() {\n\t\treturn !this.getData().length\n\t}\n\n\t/**\n\t *\n\t * @param newData The new raw data to be set\n\t */\n\tsetData(newData: any) {\n\t\tconst sanitizedData = this.sanitize(cloneDeep(newData))\n\t\tconst dataGroups = this.generateDataGroups(sanitizedData)\n\n\t\tthis.set({\n\t\t\tdata: sanitizedData,\n\t\t\tdataGroups\n\t\t})\n\n\t\treturn sanitizedData\n\t}\n\n\tgetDataGroups(groups?: any) {\n\t\tconst isDataLoading = getProperty(this.getOptions(), 'data', 'loading')\n\n\t\t// No data should be displayed while data is still loading\n\t\tif (isDataLoading) {\n\t\t\treturn []\n\t\t}\n\n\t\t// if its a combo chart, the specific chart will pass the model the groups it needs\n\t\tif (groups) {\n\t\t\treturn this.get('dataGroups').filter((dataGroup: any) => groups.includes(dataGroup.name))\n\t\t}\n\t\treturn this.get('dataGroups')\n\t}\n\n\tgetActiveDataGroups(groups?: any) {\n\t\tconst { ACTIVE } = legendConfigs.items.status\n\n\t\treturn this.getDataGroups(groups).filter((dataGroup: any) => dataGroup.status === ACTIVE)\n\t}\n\n\tgetDataGroupNames(groups?: any) {\n\t\tconst dataGroups = this.getDataGroups(groups)\n\t\treturn dataGroups.map((dataGroup: any) => dataGroup.name)\n\t}\n\n\tgetActiveDataGroupNames(groups?: any) {\n\t\tconst activeDataGroups = this.getActiveDataGroups(groups)\n\t\treturn activeDataGroups.map((dataGroup: any) => dataGroup.name)\n\t}\n\n\tprivate aggregateBinDataByGroup(bin: any) {\n\t\treturn groupBy(bin, 'group')\n\t}\n\n\tgetBinConfigurations() {\n\t\t// Manipulate data and options for Histogram\n\t\tconst data = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\n\t\tconst mainXPos = this.services.cartesianScales.getMainXAxisPosition()\n\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier()\n\n\t\tconst axisOptions = options.axes[mainXPos]\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { bins: axisBins = histogramConfigs.defaultBins } = axisOptions\n\t\tconst areBinsDefined = Array.isArray(axisBins)\n\n\t\t// Get Histogram bins\n\t\tconst bins = d3Bin()\n\t\t\t.value((d: any) => d[domainIdentifier])\n\t\t\t.thresholds(axisBins)(data)\n\n\t\tif (!areBinsDefined) {\n\t\t\t// If bins are not defined by user\n\t\t\tconst binsWidth = bins[0].x1 - bins[0].x0\n\t\t\t// Set last bin width as the others\n\t\t\tbins[bins.length - 1].x1 = +bins[bins.length - 1].x0 + binsWidth\n\t\t} else {\n\t\t\t// Set last bin end as the last user defined one\n\t\t\tbins[bins.length - 1].x1 = axisBins[axisBins.length - 1]\n\t\t}\n\n\t\tconst binsDomain = areBinsDefined\n\t\t\t? [axisBins[0], axisBins[axisBins.length - 1]]\n\t\t\t: [bins[0].x0, bins[bins.length - 1].x1]\n\n\t\t// Get all groups\n\t\tconst groupsKeys = Array.from(new Set(data.map((d: any) => d[groupMapsTo])))\n\n\t\tconst histogramData = []\n\n\t\t// Group data by bin\n\t\tbins.forEach((bin) => {\n\t\t\tconst key = `${bin.x0}-${bin.x1}`\n\t\t\tconst aggregateDataByGroup = this.aggregateBinDataByGroup(bin)\n\n\t\t\tgroupsKeys.forEach((group: string) => {\n\t\t\t\t// For each dataset put a bin with value 0 if not exist\n\t\t\t\t// (Scale X won't change when changing showed datasets)\n\t\t\t\thistogramData.push({\n\t\t\t\t\tgroup,\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue: aggregateDataByGroup[group] || 0,\n\t\t\t\t\tbin: bin.x0\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\treturn {\n\t\t\tbins,\n\t\t\tbinsDomain\n\t\t}\n\t}\n\n\tgetBinnedStackedData() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst dataGroupNames = this.getActiveDataGroupNames()\n\n\t\tconst { bins } = this.getBinConfigurations()\n\t\tconst dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys({\n\t\t\tbins\n\t\t})\n\n\t\treturn stack()\n\t\t\t.keys(dataGroupNames)(dataValuesGroupedByKeys)\n\t\t\t.map((series, i) => {\n\t\t\t\t// Add data group names to each series\n\t\t\t\treturn Object.keys(series)\n\t\t\t\t\t.filter((key: any) => !isNaN(key))\n\t\t\t\t\t.map((key: any) => {\n\t\t\t\t\t\tconst element = series[key]\n\t\t\t\t\t\telement[groupMapsTo] = dataGroupNames[i]\n\n\t\t\t\t\t\treturn element\n\t\t\t\t\t})\n\t\t\t})\n\t}\n\n\tgetGroupedData(groups?: any) {\n\t\tconst displayData = this.getDisplayData(groups)\n\t\tconst groupedData: any = {}\n\t\tconst { groupMapsTo } = this.getOptions().data\n\n\t\tdisplayData.map((datum: any) => {\n\t\t\tconst group = datum[groupMapsTo]\n\t\t\tif (groupedData[group] !== null && groupedData[group] !== undefined) {\n\t\t\t\tgroupedData[group].push(datum)\n\t\t\t} else {\n\t\t\t\tgroupedData[group] = [datum]\n\t\t\t}\n\t\t})\n\n\t\treturn Object.keys(groupedData).map((groupName) => ({\n\t\t\tname: groupName,\n\t\t\tdata: groupedData[groupName]\n\t\t}))\n\t}\n\n\tgetStackKeys({ bins = null, groups = null }: StackKeysParams = { bins: null, groups: null }) {\n\t\tconst options = this.getOptions()\n\n\t\tconst displayData = this.getDisplayData(groups)\n\n\t\tlet stackKeys: any\n\t\tif (bins) {\n\t\t\tstackKeys = bins.map((bin: any) => `${bin.x0}-${bin.x1}`)\n\t\t} else {\n\t\t\tstackKeys = uniq(\n\t\t\t\tdisplayData.map((datum: any) => {\n\t\t\t\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier(datum)\n\n\t\t\t\t\t// Use time value as key for Date object to avoid multiple data in the same second\n\t\t\t\t\tif (datum[domainIdentifier] instanceof Date) {\n\t\t\t\t\t\treturn formatDateTillMilliSeconds(datum[domainIdentifier])\n\t\t\t\t\t}\n\n\t\t\t\t\treturn datum[domainIdentifier] && typeof datum[domainIdentifier].toString === 'function'\n\t\t\t\t\t\t? datum[domainIdentifier].toString()\n\t\t\t\t\t\t: datum[domainIdentifier]\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\n\t\tconst axisPosition = this.services.cartesianScales.domainAxisPosition\n\t\tconst scaleType = options.axes[axisPosition].scaleType\n\n\t\t// Sort keys\n\t\tif (scaleType === ScaleTypes.TIME) {\n\t\t\tstackKeys.sort((a: any, b: any) => {\n\t\t\t\tconst dateA: any = new Date(a)\n\t\t\t\tconst dateB: any = new Date(b)\n\n\t\t\t\treturn dateA - dateB\n\t\t\t})\n\t\t} else if (scaleType === ScaleTypes.LOG || scaleType === ScaleTypes.LINEAR) {\n\t\t\tstackKeys.sort((a: any, b: any) => a - b)\n\t\t}\n\n\t\treturn stackKeys\n\t}\n\n\tgetDataValuesGroupedByKeys({ bins = null, groups = null }: StackKeysParams) {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst displayData = this.getDisplayData(groups)\n\n\t\tconst dataGroupNames = this.getDataGroupNames()\n\n\t\tconst stackKeys = this.getStackKeys({ bins, groups })\n\t\tif (bins) {\n\t\t\treturn stackKeys.map((key: any) => {\n\t\t\t\tconst [binStart, binEnd] = key.split('-')\n\n\t\t\t\tconst correspondingValues: any = { x0: binStart, x1: binEnd }\n\t\t\t\tconst correspondingBin = bins.find((bin: any) => bin.x0.toString() === binStart.toString())\n\n\t\t\t\tdataGroupNames.forEach((dataGroupName: any) => {\n\t\t\t\t\tcorrespondingValues[dataGroupName] = correspondingBin.filter(\n\t\t\t\t\t\t(binItem: any) => binItem[groupMapsTo] === dataGroupName\n\t\t\t\t\t).length\n\t\t\t\t})\n\n\t\t\t\treturn correspondingValues\n\t\t\t}) as any\n\t\t}\n\n\t\treturn stackKeys.map((key: any) => {\n\t\t\tconst correspondingValues: any = { sharedStackKey: key }\n\t\t\tdataGroupNames.forEach((dataGroupName: any) => {\n\t\t\t\tconst correspondingDatum = displayData.find((datum: any) => {\n\t\t\t\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier(datum)\n\n\t\t\t\t\treturn (\n\t\t\t\t\t\tdatum[groupMapsTo] === dataGroupName &&\n\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(datum, domainIdentifier) &&\n\t\t\t\t\t\t(datum[domainIdentifier] instanceof Date\n\t\t\t\t\t\t\t? formatDateTillMilliSeconds(datum[domainIdentifier]) === key\n\t\t\t\t\t\t\t: datum[domainIdentifier].toString() === key)\n\t\t\t\t\t)\n\t\t\t\t})\n\n\t\t\t\tconst rangeIdentifier =\n\t\t\t\t\tthis.services.cartesianScales.getRangeIdentifier(correspondingValues)\n\t\t\t\tcorrespondingValues[dataGroupName] = correspondingDatum\n\t\t\t\t\t? correspondingDatum[rangeIdentifier]\n\t\t\t\t\t: null\n\t\t\t})\n\n\t\t\treturn correspondingValues\n\t\t}) as any\n\t}\n\n\tgetStackedData({ percentage = false, groups = null, divergent = false }: StackKeysParams) {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\t// Get only active data groups so non-active data groups are not rendered\n\t\t// on legend item click\n\t\tconst dataGroupNames = this.getActiveDataGroupNames(groups)\n\t\tconst dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys({\n\t\t\tgroups\n\t\t})\n\n\t\tif (percentage) {\n\t\t\tconst maxByKey = fromPairs(dataValuesGroupedByKeys.map((d: any) => [d.sharedStackKey, 0]))\n\n\t\t\tdataValuesGroupedByKeys.forEach((d: any) => {\n\t\t\t\tdataGroupNames.forEach((name: any) => {\n\t\t\t\t\tmaxByKey[d.sharedStackKey] += d[name]\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// cycle through data values to get percentage\n\t\t\tdataValuesGroupedByKeys.forEach((d: any) => {\n\t\t\t\tdataGroupNames.forEach((name: any) => {\n\t\t\t\t\tconst denominator: number = maxByKey[d.sharedStackKey] as number\n\t\t\t\t\tif (maxByKey[d.sharedStackKey]) {\n\t\t\t\t\t\td[name] = (d[name] / denominator) * 100\n\t\t\t\t\t} else {\n\t\t\t\t\t\td[name] = 0\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\n\t\tconst stackToUse = divergent ? stack().offset(stackOffsetDiverging) : stack()\n\n\t\treturn stackToUse\n\t\t\t.keys(dataGroupNames)(dataValuesGroupedByKeys)\n\t\t\t.map((series: any, i: number) => {\n\t\t\t\t// Add data group names to each series\n\t\t\t\treturn Object.keys(series)\n\t\t\t\t\t.filter((key: any) => !isNaN(key))\n\t\t\t\t\t.map((key: any) => {\n\t\t\t\t\t\tconst element = series[key]\n\t\t\t\t\t\telement[groupMapsTo] = dataGroupNames[i]\n\n\t\t\t\t\t\treturn element\n\t\t\t\t\t})\n\t\t\t})\n\t}\n\n\t/**\n\t * @return {Object} The chart's options\n\t */\n\tgetOptions() {\n\t\treturn this.state.options\n\t}\n\n\tset(newState: any, configs?: any) {\n\t\tthis.state = Object.assign({}, this.state, newState)\n\t\tconst newConfig = Object.assign(\n\t\t\t{ skipUpdate: false, animate: true }, // default configs\n\t\t\tconfigs\n\t\t)\n\t\tif (!newConfig.skipUpdate) {\n\t\t\tthis.update(newConfig.animate)\n\t\t}\n\t}\n\n\tget(property?: string) {\n\t\tif (property) {\n\t\t\treturn this.state[property]\n\t\t} else {\n\t\t\treturn this.state\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param newOptions New options to be set\n\t */\n\tsetOptions(newOptions: any) {\n\t\tconst options = this.getOptions()\n\t\tupdateLegendAdditionalItems(options, newOptions)\n\n\t\tthis.set({\n\t\t\toptions: merge(options, newOptions)\n\t\t})\n\t}\n\n\t/**\n\t *\n\t * Updates miscellanous information within the model\n\t * such as the color scales, or the legend data labels\n\t */\n\tupdate(animate = true) {\n\t\tif (!this.getDisplayData()) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.updateAllDataGroups()\n\n\t\tthis.setCustomColorScale()\n\t\tthis.setColorClassNames()\n\t\tthis.services.events.dispatchEvent(Events.Model.UPDATE, { animate })\n\t}\n\n\t/*\n\t * Data labels\n\t */\n\ttoggleDataLabel(changedLabel: string) {\n\t\tconst { ACTIVE, DISABLED } = legendConfigs.items.status\n\t\tconst dataGroups = this.getDataGroups()\n\n\t\tconst hasDeactivatedItems = dataGroups.some((group: any) => group.status === DISABLED)\n\t\tconst activeItems = dataGroups.filter((group: any) => group.status === ACTIVE)\n\n\t\t// If there are deactivated items, toggle \"changedLabel\"\n\t\tif (hasDeactivatedItems) {\n\t\t\t// If the only active item is being toggled\n\t\t\t// Activate all items\n\t\t\tif (activeItems.length === 1 && activeItems[0].name === changedLabel) {\n\t\t\t\t// If every item is active, then enable \"changedLabel\" and disable all other items\n\t\t\t\tdataGroups.forEach((_: any, i: number) => {\n\t\t\t\t\tdataGroups[i].status = ACTIVE\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconst indexToChange = dataGroups.findIndex((group: any) => group.name === changedLabel)\n\t\t\t\tdataGroups[indexToChange].status =\n\t\t\t\t\tdataGroups[indexToChange].status === DISABLED ? ACTIVE : DISABLED\n\t\t\t}\n\t\t} else {\n\t\t\t// If every item is active, then enable \"changedLabel\" and disable all other items\n\t\t\tdataGroups.forEach((group: any, i: number) => {\n\t\t\t\tdataGroups[i].status = group.name === changedLabel ? ACTIVE : DISABLED\n\t\t\t})\n\t\t}\n\n\t\t// Updates selected groups\n\t\tconst updatedActiveItems = dataGroups.filter((group: any) => group.status === ACTIVE)\n\t\tconst options = this.getOptions()\n\n\t\tconst hasUpdatedDeactivatedItems = dataGroups.some((group: any) => group.status === DISABLED)\n\n\t\t// If there are deactivated items, map the item name into selected groups\n\t\tif (hasUpdatedDeactivatedItems) {\n\t\t\toptions.data.selectedGroups = updatedActiveItems.map((activeItem: any) => activeItem.name)\n\t\t} else {\n\t\t\t// If every item is active, clear array\n\t\t\toptions.data.selectedGroups = []\n\t\t}\n\n\t\t// dispatch legend filtering event with the status of all the dataLabels\n\t\tthis.services.events.dispatchEvent(Events.Legend.ITEMS_UPDATE, {\n\t\t\tdataGroups\n\t\t})\n\n\t\t// Update model\n\t\tthis.set({\n\t\t\tdataGroups\n\t\t})\n\t}\n\n\t/**\n\t * Should the data point be filled?\n\t * @param group\n\t * @param key\n\t * @param data\n\t * @param defaultFilled the default for this chart\n\t */\n\tgetIsFilled(group: any, key?: any, data?: any, defaultFilled?: boolean) {\n\t\tconst options = this.getOptions()\n\t\tif (options.getIsFilled) {\n\t\t\treturn options.getIsFilled(group, key, data, defaultFilled)\n\t\t} else {\n\t\t\treturn defaultFilled\n\t\t}\n\t}\n\n\tgetFillColor(group: any, key?: any, data?: any) {\n\t\tconst options = this.getOptions()\n\t\tconst defaultFillColor = getProperty(this.colorScale, group)\n\n\t\tif (options.getFillColor) {\n\t\t\treturn options.getFillColor(group, key, data, defaultFillColor)\n\t\t} else {\n\t\t\treturn defaultFillColor\n\t\t}\n\t}\n\n\tgetStrokeColor(group: any, key?: any, data?: any) {\n\t\tconst options = this.getOptions()\n\t\tconst defaultStrokeColor = getProperty(this.colorScale, group)\n\n\t\tif (options.getStrokeColor) {\n\t\t\treturn options.getStrokeColor(group, key, data, defaultStrokeColor)\n\t\t} else {\n\t\t\treturn defaultStrokeColor\n\t\t}\n\t}\n\n\tisUserProvidedColorScaleValid() {\n\t\tconst userProvidedScale = getProperty(this.getOptions(), 'color', 'scale')\n\t\tconst dataGroups = this.getDataGroups()\n\n\t\tif (userProvidedScale == null || Object.keys(userProvidedScale).length == 0) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn dataGroups.some((dataGroup: any) =>\n\t\t\tObject.keys(userProvidedScale).includes(dataGroup.name)\n\t\t)\n\t}\n\n\tgetColorClassName(configs: {\n\t\tclassNameTypes?: ColorClassNameTypes[] // heatmaps do not pass this value\n\t\tdataGroupName?: string | number\n\t\toriginalClassName?: string\n\t\tvalue?: number // required for heatmap override\n\t}) {\n\t\tconst colorPairingTag = this.colorClassNames(configs.dataGroupName)\n\t\tlet className = configs.originalClassName\n\t\tconfigs.classNameTypes.forEach(\n\t\t\t(type) =>\n\t\t\t\t(className = configs.originalClassName\n\t\t\t\t\t? `${className} ${type}-${colorPairingTag}`\n\t\t\t\t\t: `${type}-${colorPairingTag}`)\n\t\t)\n\n\t\treturn className || ''\n\t}\n\n\t/**\n\t * For charts that might hold an associated status for their dataset\n\t */\n\tgetStatus(): any {\n\t\treturn null\n\t}\n\n\tgetAllDataGroupsNames() {\n\t\treturn this.allDataGroups\n\t}\n\n\t/**\n\t * Converts data provided in the older format to tabular\n\t *\n\t */\n\tprotected transformToTabularData(data: any) {\n\t\tconsole.warn(\n\t\t\t\"We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/docs-tutorials--tabular-data-format\"\n\t\t)\n\t\tconst tabularData: ChartTabularData = []\n\t\tconst { datasets, labels } = data\n\n\t\t// Loop through all datasets\n\t\tdatasets.forEach((dataset: any) => {\n\t\t\t// Update each data point to the new format\n\t\t\tdataset.data.forEach((datum: any, i: number) => {\n\t\t\t\tlet group\n\n\t\t\t\tconst datasetLabel = getProperty(dataset, 'label')\n\t\t\t\tif (datasetLabel === null) {\n\t\t\t\t\tconst correspondingLabel = getProperty(labels, i)\n\t\t\t\t\tif (correspondingLabel) {\n\t\t\t\t\t\tgroup = correspondingLabel\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup = 'Ungrouped'\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgroup = datasetLabel\n\t\t\t\t}\n\n\t\t\t\tconst updatedDatum: any = {\n\t\t\t\t\tgroup,\n\t\t\t\t\tkey: labels[i]\n\t\t\t\t}\n\n\t\t\t\tif (isNaN(datum)) {\n\t\t\t\t\tupdatedDatum['value'] = datum.value\n\t\t\t\t\tupdatedDatum['date'] = datum.date\n\t\t\t\t} else {\n\t\t\t\t\tupdatedDatum['value'] = datum\n\t\t\t\t}\n\n\t\t\t\ttabularData.push(updatedDatum)\n\t\t\t})\n\t\t})\n\n\t\treturn tabularData\n\t}\n\n\tgetTabularDataArray(): ChartTabularData {\n\t\treturn []\n\t}\n\n\texportToCSV() {\n\t\tconst data = this.getTabularDataArray().map((row) =>\n\t\t\trow.map((column: any) => `\"${column === '&ndash;' ? 'â€“' : column}\"`)\n\t\t)\n\n\t\tlet csvString = '',\n\t\t\tcsvData = ''\n\t\tdata.forEach(function (d, i) {\n\t\t\tcsvData = d.join(',')\n\t\t\tcsvString += i < data.length ? csvData + '\\n' : csvData\n\t\t})\n\n\t\tthis.services.files.downloadCSV(csvString, 'myChart.csv')\n\t}\n\n\tprotected getTabularData(data: any) {\n\t\t// if data is not an array\n\t\tif (!Array.isArray(data)) {\n\t\t\treturn this.transformToTabularData(data)\n\t\t}\n\n\t\treturn data\n\t}\n\n\tprotected sanitize(data: any) {\n\t\tdata = this.getTabularData(data)\n\n\t\treturn data\n\t}\n\n\t/*\n\t * Data groups\n\t */\n\tprotected updateAllDataGroups() {\n\t\t// allDataGroups is used to generate a color scale that applies\n\t\t// to all the groups. Now when the data updates, you might remove a group,\n\t\t// and then bring it back in a newer data update, therefore\n\t\t// the order of the groups in allDataGroups matters so that you'd never\n\t\t// have an incorrect color assigned to a group.\n\n\t\t// Also, a new group should only be added to allDataGroups if\n\t\t// it doesn't currently exist\n\n\t\tif (!this.allDataGroups) {\n\t\t\tthis.allDataGroups = this.getDataGroupNames()\n\t\t} else {\n\t\t\t// Loop through current data groups\n\t\t\tthis.getDataGroupNames().forEach((dataGroupName: any) => {\n\t\t\t\t// If group name hasn't been stored yet, store it\n\t\t\t\tif (this.allDataGroups.indexOf(dataGroupName) === -1) {\n\t\t\t\t\tthis.allDataGroups.push(dataGroupName)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tprotected generateDataGroups(data: any) {\n\t\tconst { groupMapsTo } = this.getOptions().data\n\t\tconst { ACTIVE, DISABLED } = legendConfigs.items.status\n\t\tconst options = this.getOptions()\n\n\t\tconst uniqueDataGroups = uniq(data.map((datum: any) => datum[groupMapsTo]))\n\n\t\t// check if selectedGroups can be applied to chart with current data groups\n\t\tif (options.data.selectedGroups.length) {\n\t\t\tconst hasAllSelectedGroups = options.data.selectedGroups.every((groupName: any) =>\n\t\t\t\tuniqueDataGroups.includes(groupName)\n\t\t\t)\n\t\t\tif (!hasAllSelectedGroups) {\n\t\t\t\toptions.data.selectedGroups = []\n\t\t\t}\n\t\t}\n\n\t\t// Get group status based on items in selected groups\n\t\tconst getStatus = (groupName: any) =>\n\t\t\t!options.data.selectedGroups.length || options.data.selectedGroups.includes(groupName)\n\t\t\t\t? ACTIVE\n\t\t\t\t: DISABLED\n\n\t\treturn uniqueDataGroups.map((groupName) => ({\n\t\t\tname: groupName,\n\t\t\tstatus: getStatus(groupName)\n\t\t}))\n\t}\n\n\t/*\n\t * Fill scales\n\t */\n\tprotected setCustomColorScale() {\n\t\tif (!this.isUserProvidedColorScaleValid()) {\n\t\t\treturn\n\t\t}\n\n\t\tconst options = this.getOptions()\n\t\tconst userProvidedScale = getProperty(options, 'color', 'scale')\n\n\t\tObject.keys(userProvidedScale).forEach((dataGroup) => {\n\t\t\tif (!this.allDataGroups.includes(dataGroup)) {\n\t\t\t\tconsole.warn(`\"${dataGroup}\" does not exist in data groups.`)\n\t\t\t}\n\t\t})\n\n\t\t/**\n\t\t * Go through allDataGroups. If a data group has a color value provided\n\t\t * by the user, add that to the color range\n\t\t */\n\t\tconst providedDataGroups = this.allDataGroups.filter(\n\t\t\t(dataGroup) => userProvidedScale[dataGroup]\n\t\t)\n\n\t\tprovidedDataGroups.forEach(\n\t\t\t(dataGroup) => (this.colorScale[dataGroup] = userProvidedScale[dataGroup])\n\t\t)\n\t}\n\n\t/*\n\t * Color palette\n\t */\n\tprotected setColorClassNames() {\n\t\tconst colorPairingOptions = getProperty(this.getOptions(), 'color', 'pairing')\n\n\t\t// Check if user has defined numberOfVariants (differ from given data)\n\t\tlet numberOfVariants = getProperty(colorPairingOptions, 'numberOfVariants')\n\t\tif (!numberOfVariants || numberOfVariants < this.allDataGroups.length) {\n\t\t\tnumberOfVariants = this.allDataGroups.length\n\t\t}\n\n\t\tlet pairingOption = getProperty(colorPairingOptions, 'option')\n\t\tconst colorPairingCounts = colorConfigs.pairingOptions\n\n\t\t// If number of dataGroups is greater than 5, user 14-color palette\n\t\tconst numberOfColors = numberOfVariants > 5 ? 14 : numberOfVariants\n\n\t\t// Use default palette if user choice is not in range\n\t\tconst key = `${numberOfColors}-color` as keyof typeof colorPairingCounts\n\t\tpairingOption = pairingOption <= colorPairingCounts[key] ? pairingOption : 1\n\n\t\t// Create color classes for graph, tooltip and stroke use\n\t\tconst colorPairing = this.allDataGroups.map(\n\t\t\t(_, index) => `${numberOfColors}-${pairingOption}-${(index % 14) + 1}`\n\t\t)\n\n\t\t// Create default color classnames\n\t\tthis.colorClassNames = scaleOrdinal().range(colorPairing).domain(this.allDataGroups)\n\t}\n}\n","import { format } from 'date-fns'\nimport { cloneDeep, uniq } from 'lodash-es'\nimport { getProperty } from '@/tools'\nimport { ChartModel } from './model'\nimport { ScaleTypes, AxisPositions, AxisFlavor } from '@/interfaces/enums'\n\n/**\n * This supports adding X and Y Cartesian[2D] zoom data to a ChartModel\n * */\nexport class ChartModelCartesian extends ChartModel {\n\taxisFlavor = AxisFlavor.DEFAULT // can't be protected as it's used by two-dimensional-axes.ts\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\t// get the scales information\n\t// needed for getTabularArray()\n\tprotected assignRangeAndDomains() {\n\t\tconst { cartesianScales } = this.services\n\t\tconst options = this.getOptions()\n\t\tconst isDualAxes = cartesianScales.isDualAxes()\n\n\t\tconst scales = {\n\t\t\tprimaryDomain: cartesianScales.domainAxisPosition,\n\t\t\tprimaryRange: cartesianScales.rangeAxisPosition,\n\t\t\tsecondaryDomain: null as any,\n\t\t\tsecondaryRange: null as any\n\t\t}\n\t\tif (isDualAxes) {\n\t\t\tscales.secondaryDomain = cartesianScales.secondaryDomainAxisPosition\n\t\t\tscales.secondaryRange = cartesianScales.secondaryRangeAxisPosition\n\t\t}\n\n\t\tObject.keys(scales).forEach((scale: 'primaryDomain' | 'primaryRange' | 'secondaryDomain' | 'secondaryRange') => {\n\t\t\tconst position = scales[scale]\n\t\t\tif (cartesianScales.scales[position]) {\n\t\t\t\tscales[scale] = {\n\t\t\t\t\tposition: position,\n\t\t\t\t\tlabel: cartesianScales.getScaleLabel(position),\n\t\t\t\t\tidentifier: getProperty(options, 'axes', position, 'mapsTo')\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscales[scale] = null\n\t\t\t}\n\t\t})\n\n\t\treturn scales\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst { cartesianScales } = this.services\n\t\tconst { primaryDomain, primaryRange, secondaryDomain, secondaryRange } =\n\t\t\tthis.assignRangeAndDomains()\n\n\t\tconst domainScaleType = cartesianScales.getDomainAxisScaleType()\n\t\tlet domainValueFormatter: any\n\t\tif (domainScaleType === ScaleTypes.TIME) {\n\t\t\tdomainValueFormatter = (d: any) => format(d, 'MMM d, yyyy')\n\t\t}\n\n\t\tconst result = [\n\t\t\t[\n\t\t\t\t'Group',\n\t\t\t\tprimaryDomain.label,\n\t\t\t\tprimaryRange.label,\n\t\t\t\t...(secondaryDomain ? [secondaryDomain.label] : []),\n\t\t\t\t...(secondaryRange ? [secondaryRange.label] : [])\n\t\t\t],\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tdatum[primaryDomain.identifier] === null\n\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t: domainValueFormatter\n\t\t\t\t\t? domainValueFormatter(datum[primaryDomain.identifier])\n\t\t\t\t\t: datum[primaryDomain.identifier],\n\t\t\t\tdatum[primaryRange.identifier] === null || isNaN(datum[primaryRange.identifier])\n\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t: datum[primaryRange.identifier].toLocaleString(),\n\t\t\t\t...(secondaryDomain\n\t\t\t\t\t? [\n\t\t\t\t\t\t\tdatum[secondaryDomain.identifier] === null\n\t\t\t\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t\t\t\t: datum[secondaryDomain.identifier]\n\t\t\t\t\t\t]\n\t\t\t\t\t: []),\n\t\t\t\t...(secondaryRange\n\t\t\t\t\t? [\n\t\t\t\t\t\t\tdatum[secondaryRange.identifier] === null || isNaN(datum[secondaryRange.identifier])\n\t\t\t\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t\t\t\t: datum[secondaryRange.identifier]\n\t\t\t\t\t\t]\n\t\t\t\t\t: [])\n\t\t\t])\n\t\t]\n\n\t\treturn result\n\t}\n\n\tsetData(newData: any) {\n\t\tlet data: any\n\t\tif (newData) {\n\t\t\tdata = super.setData(newData)\n\t\t\tif (getProperty(this.getOptions(), 'zoomBar', AxisPositions.TOP, 'enabled')) {\n\t\t\t\t// get pre-defined zoom bar data\n\t\t\t\tconst definedZoomBarData = getProperty(\n\t\t\t\t\tthis.getOptions(),\n\t\t\t\t\t'zoomBar',\n\t\t\t\t\tAxisPositions.TOP,\n\t\t\t\t\t'data'\n\t\t\t\t)\n\t\t\t\t// if we have zoom bar data we need to update it as well\n\t\t\t\t// with pre-defined zoom bar data\n\t\t\t\tthis.setZoomBarData(definedZoomBarData)\n\t\t\t}\n\t\t}\n\n\t\treturn data\n\t}\n\n\t/**\n\t * @param zoomBarData any special zoom bar data to use instead of the model data\n\t */\n\tsetZoomBarData(newZoomBarData?: any) {\n\t\tconst sanitizedData = newZoomBarData\n\t\t\t? this.sanitize(cloneDeep(newZoomBarData))\n\t\t\t: this.getDisplayData() // if we're not passed explicit zoom data use the model\n\n\t\tlet zoomBarNormalizedValues = sanitizedData\n\n\t\tconst { cartesianScales } = this.services\n\t\tif (sanitizedData && cartesianScales.domainAxisPosition && cartesianScales.rangeAxisPosition) {\n\t\t\tconst domainIdentifier = cartesianScales.getDomainIdentifier()\n\t\t\tconst rangeIdentifier = cartesianScales.getRangeIdentifier()\n\t\t\t// get all dates (Number) in displayData\n\t\t\tlet allDates = sanitizedData.map((datum: any) => datum[domainIdentifier].getTime())\n\t\t\tallDates = uniq(allDates).sort()\n\n\t\t\t// Go through all date values\n\t\t\t// And get corresponding data from each dataset\n\t\t\tzoomBarNormalizedValues = allDates.map((date: Date) => {\n\t\t\t\tlet sum = 0\n\t\t\t\tconst datum: any = {}\n\n\t\t\t\tsanitizedData.forEach((data: any) => {\n\t\t\t\t\tif (data[domainIdentifier].getTime() === date) {\n\t\t\t\t\t\tsum += data[rangeIdentifier]\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tdatum[domainIdentifier] = new Date(date)\n\t\t\t\tdatum[rangeIdentifier] = sum\n\n\t\t\t\treturn datum\n\t\t\t})\n\t\t}\n\n\t\tthis.set({ zoomBarData: zoomBarNormalizedValues })\n\t}\n\n\tgetZoomBarData() {\n\t\treturn this.get('zoomBarData')\n\t}\n\n\tprotected sanitizeDateValues(data: any) {\n\t\tconst options = this.getOptions()\n\n\t\tif (!options.axes) {\n\t\t\treturn data\n\t\t}\n\n\t\tconst keysToCheck: any[] = []\n\t\tObject.keys(AxisPositions).forEach((axisPositionKey: keyof typeof AxisPositions) => {\n\t\t\tconst axisPosition = AxisPositions[axisPositionKey]\n\t\t\tconst axisOptions = options.axes[axisPosition]\n\n\t\t\tif (axisOptions && axisOptions.scaleType === ScaleTypes.TIME) {\n\t\t\t\tconst axisMapsTo = axisOptions.mapsTo\n\n\t\t\t\tif (axisMapsTo !== null || axisMapsTo !== undefined) {\n\t\t\t\t\tkeysToCheck.push(axisMapsTo)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tif (keysToCheck.length > 0) {\n\t\t\t// Check all datapoints and sanitize dates\n\t\t\tdata.forEach((datum: any) => {\n\t\t\t\tkeysToCheck.forEach((key: any) => {\n\t\t\t\t\tif (getProperty(datum, key, 'getTime') === null) {\n\t\t\t\t\t\tdatum[key] = new Date(datum[key])\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\n\t\treturn data\n\t}\n\n\tprotected sanitize(data: any) {\n\t\tdata = super.sanitize(data)\n\t\tdata = this.sanitizeDateValues(data)\n\n\t\treturn data\n\t}\n}\n","// Internal Imports\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/**\n * Alluvial chart model layer\n */\nexport class AlluvialChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\n\t\t// Sort array by source to get a close depiction of the alluvial chart\n\t\tdisplayData.sort((a: any, b: any) => a['source'].localeCompare(b['source']))\n\n\t\tconst result = [\n\t\t\t['Source', 'Target', 'Value'],\n\t\t\t...displayData.map((datum: any) => [datum['source'], datum['target'], datum['value']])\n\t\t]\n\n\t\treturn result\n\t}\n}\n","import { ascending, min, max, quantile, scaleOrdinal } from 'd3'\nimport { getProperty } from '@/tools'\nimport { color as colorConfigs } from '@/configuration'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class BoxplotChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetBoxQuartiles(d: any) {\n\t\treturn {\n\t\t\tq_25: quantile(d, 0.25),\n\t\t\tq_50: quantile(d, 0.5),\n\t\t\tq_75: quantile(d, 0.75)\n\t\t}\n\t}\n\n\tgetBoxplotData() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst groupedData = this.getGroupedData()\n\n\t\t// Prepare the data for the box plots\n\t\tconst boxplotData = []\n\t\tfor (const { name: group, data } of groupedData) {\n\t\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\t\t\tconst values = data.map((d: any) => d[rangeIdentifier]).sort(ascending)\n\n\t\t\tconst record = {\n\t\t\t\t[groupMapsTo]: group,\n\t\t\t\tcounts: values,\n\t\t\t\tquartiles: this.getBoxQuartiles(values),\n\t\t\t\toutliers: null as any,\n\t\t\t\twhiskers: null as any\n\t\t\t}\n\n\t\t\tconst q1 = record.quartiles.q_25\n\t\t\tconst q3 = record.quartiles.q_75\n\n\t\t\tconst iqr = (q3 - q1) * 1.5\n\t\t\tconst irq1 = q1 - iqr\n\t\t\tconst irq3 = q3 + iqr\n\n\t\t\tconst outliers = []\n\t\t\tconst normalValues = []\n\n\t\t\tfor (const value of values) {\n\t\t\t\tif (value < irq1) {\n\t\t\t\t\toutliers.push(value)\n\t\t\t\t} else if (value > irq3) {\n\t\t\t\t\toutliers.push(value)\n\t\t\t\t} else {\n\t\t\t\t\tnormalValues.push(value)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trecord.outliers = outliers\n\n\t\t\tconst minNormalValue = min(normalValues)\n\t\t\tconst maxNormalValue = max(normalValues)\n\t\t\trecord.whiskers = {\n\t\t\t\tmin: minNormalValue\n\t\t\t\t\t? minNormalValue\n\t\t\t\t\t: min([record.quartiles.q_25, record.quartiles.q_50, record.quartiles.q_75]),\n\t\t\t\tmax: maxNormalValue\n\t\t\t\t\t? maxNormalValue\n\t\t\t\t\t: max([record.quartiles.q_25, record.quartiles.q_50, record.quartiles.q_75])\n\t\t\t}\n\n\t\t\tboxplotData.push(record)\n\t\t}\n\n\t\treturn boxplotData\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst boxplotData = this.getBoxplotData()\n\n\t\tconst result = [\n\t\t\t['Group', 'Minimum', 'Q1', 'Median', 'Q3', 'Maximum', 'IQR', 'Outlier(s)'],\n\t\t\t...boxplotData.map((datum) => {\n\t\t\t\tlet outliers = getProperty(datum, 'outliers')\n\t\t\t\tif (outliers === null || outliers.length === 0) {\n\t\t\t\t\toutliers = ['&ndash;']\n\t\t\t\t}\n\t\t\t\treturn [\n\t\t\t\t\tdatum[groupMapsTo],\n\t\t\t\t\tgetProperty(datum, 'whiskers', 'min') !== null\n\t\t\t\t\t\t? getProperty(datum, 'whiskers', 'min').toLocaleString()\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_25') !== null\n\t\t\t\t\t\t? getProperty(datum, 'quartiles', 'q_25').toLocaleString()\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_50') !== null\n\t\t\t\t\t\t? getProperty(datum, 'quartiles', 'q_50').toLocaleString()\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_75') !== null\n\t\t\t\t\t\t? getProperty(datum, 'quartiles', 'q_75').toLocaleString()\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'whiskers', 'max') !== null\n\t\t\t\t\t\t? getProperty(datum, 'whiskers', 'max').toLocaleString()\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_75') !== null &&\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_25') !== null\n\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_75') - getProperty(datum, 'quartiles', 'q_25')\n\t\t\t\t\t\t\t).toLocaleString()\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\toutliers.map((d: any) => d.toLocaleString()).join(',')\n\t\t\t\t]\n\t\t\t})\n\t\t]\n\n\t\treturn result\n\t}\n\n\tprotected setColorClassNames() {\n\t\t// monochrome\n\t\tconst numberOfColors = 1\n\n\t\tconst colorPairingOptions = getProperty(this.getOptions(), 'color', 'pairing')\n\t\tlet pairingOption = getProperty(colorPairingOptions, 'option')\n\t\tconst colorPairingCounts = colorConfigs.pairingOptions\n\n\t\t// Use default palette if user choice is not in range\n\t\tpairingOption =\n\t\t\tpairingOption <= colorPairingCounts[`${numberOfColors}-color`] ? pairingOption : 1\n\n\t\t// Create color classes for graph, tooltip and stroke use\n\t\tconst colorPairing = this.allDataGroups.map(() => `${numberOfColors}-${pairingOption}-1`)\n\n\t\t// Create default color classnames\n\t\tthis.colorClassNames = scaleOrdinal().range(colorPairing).domain(this.allDataGroups)\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/**\n * Bullet chart model layer\n */\nexport class BulletChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\t/**\n\t * Determines the index of the performance area titles to use\n\t * @param datum\n\t * @returns number\n\t */\n\tgetMatchingRangeIndexForDatapoint(datum: any) {\n\t\tlet matchingRangeIndex\n\t\tfor (let i = datum.ranges.length - 1; i > 0; i--) {\n\t\t\tconst range = datum.ranges[i]\n\t\t\tif (datum.value >= range) {\n\t\t\t\tmatchingRangeIndex = i\n\n\t\t\t\treturn matchingRangeIndex\n\t\t\t}\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\n\t\tconst performanceAreaTitles = getProperty(options, 'bullet', 'performanceAreaTitles')\n\n\t\tconst result = [\n\t\t\t['Title', 'Group', 'Value', 'Target', 'Percentage', 'Performance'],\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum['title'],\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : datum['value'],\n\t\t\t\tgetProperty(datum, 'marker') === null ? '&ndash;' : datum['marker'],\n\t\t\t\tgetProperty(datum, 'marker') === null\n\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t: `${Math.floor((datum[rangeIdentifier] / datum.marker) * 100)}%`,\n\t\t\t\tperformanceAreaTitles[this.getMatchingRangeIndexForDatapoint(datum)]\n\t\t\t])\n\t\t]\n\n\t\treturn result\n\t}\n}\n","// External Imports\nimport { isEmpty } from 'lodash-es'\n\n// Internal Imports\nimport { ChartModel } from './model'\nimport { getProperty } from '@/tools'\nimport { getColorScale } from '@/services/color-scale-utils'\n\n/**\n * Base thematic maps chart model layer\n */\nexport class ChoroplethModel extends ChartModel {\n\tprivate _colorScale: any = undefined\n\n\t// Holds a mapping of geometry objects to data objects\n\t// Allows us to access data faster\n\tprivate _matrix = {}\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\t/**\n\t * @override\n\t * @param value\n\t * @returns string\n\t */\n\tgetFillColor(value: number) {\n\t\treturn this._colorScale(value)\n\t}\n\n\t/**\n\t * Helper function that will generate a dictionary\n\t */\n\tgetCombinedData() {\n\t\tif (isEmpty(this._matrix)) {\n\t\t\tconst options = this.getOptions()\n\t\t\tconst data = this.getDisplayData()\n\t\t\tif (!isEmpty(data) && !isEmpty(options.geoData.objects.countries)) {\n\t\t\t\t/**\n\t\t\t\t * @todo\n\t\t\t\t * We can either use name or id by default to generate this dictionary\n\t\t\t\t * Curently id & name are standard in geoJSON. Unfortunately, topojson does not have any standard\n\t\t\t\t * so feature objects can have any key. We suggest that they include name or id at the very least\n\t\t\t\t *\n\t\t\t\t * May need to provide users with the option to pass in keys to create dictionary with\n\t\t\t\t */\n\t\t\t\toptions.geoData.objects.countries.geometries.forEach((country) => {\n\t\t\t\t\tthis._matrix[country.properties.NAME] = country\n\t\t\t\t})\n\n\t\t\t\tdata.forEach((value) => {\n\t\t\t\t\tif (this._matrix[value.name]) {\n\t\t\t\t\t\tthis._matrix[value.name]['value'] = value.value || null\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn(`Data point ${value} is missing geographical data.`)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\treturn this._matrix\n\t}\n\n\t/**\n\t * Generate tabular data from display data\n\t * @returns Array<Object>\n\t */\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\n\t\tconst result = [\n\t\t\t['Country ID', 'Country Name', 'Value'],\n\t\t\t...displayData.map((datum) => [\n\t\t\t\tdatum['id'] === null ? '&ndash;' : datum['id'],\n\t\t\t\tdatum['name'],\n\t\t\t\tdatum['value']\n\t\t\t])\n\t\t]\n\n\t\treturn result\n\t}\n\n\t// Uses quantize scale to return class names\n\tgetColorClassName(configs: { value?: number; originalClassName?: string }) {\n\t\treturn `${configs.originalClassName} ${this._colorScale(configs.value as number)}`\n\t}\n\n\tprotected setColorClassNames() {\n\t\tconst colorOptions = getProperty(this.getOptions(), 'color')\n\t\tthis._colorScale = getColorScale(this.getDisplayData(), colorOptions)\n\t}\n}\n","import { merge } from 'lodash-es'\nimport { getProperty, updateLegendAdditionalItems } from '@/tools'\nimport { ChartModel } from './model'\nimport { LegendItemType } from '@/interfaces/enums'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class CirclePackChartModel extends ChartModel {\n\tparentNode = false\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t\tthis.set({ depth: 2 }, { skipUpdate: true })\n\t}\n\n\tsetData(newData: any) {\n\t\tsuper.setData(newData)\n\t\tthis.setDataGroups()\n\t\tif (newData.length === 1) {\n\t\t\tthis.parentNode = true\n\t\t}\n\t\tthis.setZoom()\n\t}\n\n\tsetOptions(newOptions: any) {\n\t\tconst options = this.getOptions()\n\t\tconst zoomOptions = merge({}, newOptions, this.getZoomOptions(newOptions))\n\t\tupdateLegendAdditionalItems(options, zoomOptions)\n\n\t\tconst depth = this.getHierarchyLevel()\n\t\tconst userProvidedDepth = getProperty(options, 'circlePack', 'hierarchyLevel')\n\n\t\tthis.set({\n\t\t\toptions: merge(options, zoomOptions),\n\t\t\tdepth: userProvidedDepth && userProvidedDepth < 4 ? userProvidedDepth : depth\n\t\t})\n\t}\n\n\tgetZoomOptions(options?: any) {\n\t\tif (!this.getDisplayData()) {\n\t\t\treturn {}\n\t\t}\n\t\t// uses the user provided options and data to determine if there is zoom in this CP chart\n\t\tconst displayData = this.getDisplayData()\n\t\tconst zoomOptions = options ? options : this.getOptions()\n\t\tconst data =\n\t\t\tdisplayData.length === 1 && getProperty(displayData, 0, 'children')\n\t\t\t\t? getProperty(displayData, 0, 'children')\n\t\t\t\t: displayData\n\n\t\tlet depth = this.getHierarchyLevel()\n\t\t// check the data depth\n\t\tdata.some((datum: any) => {\n\t\t\tif (datum.children) {\n\t\t\t\tif (datum.children.some((item: any) => item.children)) {\n\t\t\t\t\tdepth = 3\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tif (getProperty(zoomOptions, 'canvasZoom', 'enabled') === true && depth > 2) {\n\t\t\treturn {\n\t\t\t\tlegend: {\n\t\t\t\t\tadditionalItems: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: LegendItemType.ZOOM,\n\t\t\t\t\t\t\tname: 'Click to zoom'\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n\n\tsetZoom(options?: any) {\n\t\tthis.setOptions(this.getZoomOptions(options))\n\t}\n\n\t// update the hierarchy level\n\tupdateHierarchyLevel(depth: number) {\n\t\tthis.set({ depth: depth })\n\t}\n\n\tgetHierarchyLevel() {\n\t\treturn this.get('depth')\n\t}\n\n\thasParentNode() {\n\t\treturn this.parentNode\n\t}\n\n\t// set the datagroup name on the items that are it's children\n\tsetDataGroups() {\n\t\tconst data = this.getData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst newData = data.map((depthOne: any) => {\n\t\t\tconst groupName = depthOne[groupMapsTo]\n\t\t\treturn this.setChildrenDataGroup(depthOne, groupName)\n\t\t})\n\n\t\tthis.set(\n\t\t\t{\n\t\t\t\tdata: newData\n\t\t\t},\n\t\t\t{ skipUpdate: true }\n\t\t)\n\t}\n\n\t// sets name recursively down the node tree\n\tprotected setChildrenDataGroup(node: any, name: any) {\n\t\tif (node.children) {\n\t\t\treturn {\n\t\t\t\t...node,\n\t\t\t\tdataGroupName: name,\n\t\t\t\tchildren: node.children.map((child: any) => {\n\t\t\t\t\treturn this.setChildrenDataGroup(child, name)\n\t\t\t\t})\n\t\t\t}\n\t\t} else {\n\t\t\treturn { ...node, dataGroupName: name }\n\t\t}\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\n\t\tconst result = [['Child', 'Parent', 'Value']]\n\n\t\tdisplayData.forEach((datum: any) => {\n\t\t\tlet value = datum.value ? datum.value : 0\n\t\t\tif (datum.children) {\n\t\t\t\t// Call recursive function\n\t\t\t\tvalue += this.getChildrenDatums(datum.children, datum.name, result, 0)\n\t\t\t}\n\t\t\tresult.push(['&ndash;', datum.name, value])\n\t\t})\n\n\t\treturn result\n\t}\n\n\t/**\n\t * Recursively determine the relationship between all the nested elements in the child\n\t * @param children: Object\n\t * @param parent: String\n\t * @param result: Array<Object>\n\t * @param totalSum: number\n\t * @returns: number\n\t */\n\tprivate getChildrenDatums(children: any, parent: any, result: string[][] = [], totalSum = 0) {\n\t\tconst grandParent = parent\n\n\t\tchildren.forEach((child: any) => {\n\t\t\tconst parentWithinIteration = child.name\n\t\t\tlet sum = 0\n\n\t\t\tif (child.children) {\n\t\t\t\tif (child.children.length > 0) {\n\t\t\t\t\tif (typeof child.value === 'number') {\n\t\t\t\t\t\ttotalSum += child.value\n\t\t\t\t\t}\n\n\t\t\t\t\tsum += this.getChildrenDatums(child.children, parentWithinIteration, result, sum)\n\t\t\t\t\tresult.push([parentWithinIteration, grandParent, sum])\n\t\t\t\t\ttotalSum += sum\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet value = 0\n\t\t\t\tif (typeof child.value === 'number') {\n\t\t\t\t\tvalue = child.value\n\t\t\t\t\ttotalSum += child.value\n\t\t\t\t}\n\t\t\t\tresult.push([child.name, grandParent, value])\n\t\t\t}\n\t\t})\n\n\t\treturn totalSum\n\t}\n}\n","import { ChartModel } from './model'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class PieChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularData(data: any) {\n\t\tconst tabularData = super.getTabularData(data)\n\n\t\t// if the data was changed to tabular format\n\t\t// update the group to the key so the slices render with the correct tooltips and colors\n\t\tif (data !== tabularData) {\n\t\t\t// If a label was set for the overall dataset, reassign it to key value\n\t\t\ttabularData.forEach((d: any) => {\n\t\t\t\tif (d.key && d.key !== d.group) {\n\t\t\t\t\td.group = d.key\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn tabularData\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst result = [\n\t\t\t['Group', 'Value'],\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : datum['value'].toLocaleString()\n\t\t\t])\n\t\t]\n\n\t\treturn result\n\t}\n\n\tsanitize(data: any) {\n\t\tconst tabularData = this.getTabularData(data)\n\n\t\t// Sort data based on value\n\t\treturn tabularData.sort((a, b) => b.value - a.value)\n\t}\n}\n","import { ChartModel } from './model'\n\n/**\n * The gauge chart model layer\n */\nexport class GaugeChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetDataGroups() {\n\t\treturn super.getDataGroups().filter((item: any) => item.name !== 'delta')\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst result = [\n\t\t\t['Group', 'Value'],\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : datum['value'].toLocaleString()\n\t\t\t])\n\t\t]\n\n\t\treturn result\n\t}\n}\n","import { extent, scaleQuantize, scaleLinear } from 'd3'\nimport { cloneDeep, isEmpty } from 'lodash-es'\nimport { getProperty } from '@/tools'\nimport { AxisFlavor, ScaleTypes } from '@/interfaces/enums'\nimport { getColorScale } from '@/services'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n\n/** The gauge chart model layer */\nexport class HeatmapModel extends ChartModelCartesian {\n\taxisFlavor = AxisFlavor.HOVERABLE\n\tprivate _colorScale: any = undefined\n\n\t// List of unique ranges and domains\n\tprivate _domains: any[] = []\n\tprivate _ranges: any[] = []\n\n\tprivate _matrix: any = {}\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\n\t\t// Check which scale types are being used\n\t\tconst axis = getProperty(this.getOptions(), 'axes')\n\n\t\t// Need to check options since scale service hasn't been instantiated\n\t\tif (\n\t\t\t(!!getProperty(axis, 'left', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'left', 'scaleType') !== ScaleTypes.LABELS) ||\n\t\t\t(!!getProperty(axis, 'right', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'right', 'scaleType') !== ScaleTypes.LABELS) ||\n\t\t\t(!!getProperty(axis, 'top', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'top', 'scaleType') !== ScaleTypes.LABELS) ||\n\t\t\t(!!getProperty(axis, 'bottom', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'bottom', 'scaleType') !== ScaleTypes.LABELS)\n\t\t) {\n\t\t\tthrow Error('Heatmap only supports label scaletypes.')\n\t\t}\n\t}\n\n\t/**\n\t * Get min and maximum value of the display data\n\t * @returns Array consisting of smallest and largest values in  data\n\t */\n\tgetValueDomain() {\n\t\tconst limits = extent(this.getDisplayData(), (d: any) => d.value)\n\t\tconst domain = scaleLinear()\n\t\t\t.domain(limits as [number, number])\n\t\t\t.nice()\n\t\t\t.domain()\n\n\t\t// Ensuring limits start at 0 to make scale look more `nicer`\n\t\tif (domain[0] > 0) {\n\t\t\tdomain[0] = 0\n\t\t} else if (domain[0] === 0 && domain[1] === 0) {\n\t\t\t// Range cannot be between 0 and 0 (itself)\n\t\t\treturn [0, 1]\n\t\t}\n\n\t\t// Ensure the median of the range is 0 if domain extends into both negative & positive\n\t\tif (domain[0] < 0 && domain[1] > 0) {\n\t\t\tif (Math.abs(domain[0]) > domain[1]) {\n\t\t\t\tdomain[1] = Math.abs(domain[0])\n\t\t\t} else {\n\t\t\t\tdomain[0] = -domain[1]\n\t\t\t}\n\t\t}\n\n\t\treturn domain\n\t}\n\n\t/**\n\t * @override\n\t * @param value\n\t * @returns string\n\t */\n\tgetFillColor(value: number) {\n\t\treturn this._colorScale(value)\n\t}\n\n\t/**\n\t * Generate a list of all unique domains\n\t * @returns String[]\n\t */\n\tgetUniqueDomain(): string[] {\n\t\tif (isEmpty(this._domains)) {\n\t\t\tconst displayData = this.getDisplayData()\n\t\t\tconst { cartesianScales } = this.services\n\n\t\t\tconst domainIdentifier = cartesianScales.getDomainIdentifier()\n\t\t\tconst mainXAxisPosition = cartesianScales.getMainXAxisPosition()\n\t\t\tconst customDomain = cartesianScales.getCustomDomainValuesByposition(mainXAxisPosition)\n\n\t\t\t// Use user defined domain if specified\n\t\t\tif (customDomain) {\n\t\t\t\treturn customDomain\n\t\t\t}\n\n\t\t\t// Get unique axis values & create a matrix\n\t\t\tthis._domains = Array.from(\n\t\t\t\tnew Set(\n\t\t\t\t\tdisplayData.map((d: any) => {\n\t\t\t\t\t\treturn d[domainIdentifier]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn this._domains\n\t}\n\n\t/**\n\t * Generates a list of all unique ranges\n\t * @returns String[]\n\t */\n\tgetUniqueRanges(): string[] {\n\t\tif (isEmpty(this._ranges)) {\n\t\t\tconst displayData = this.getDisplayData()\n\t\t\tconst { cartesianScales } = this.services\n\n\t\t\tconst rangeIdentifier = cartesianScales.getRangeIdentifier()\n\t\t\tconst mainYAxisPosition = cartesianScales.getMainYAxisPosition()\n\t\t\tconst customDomain = cartesianScales.getCustomDomainValuesByposition(mainYAxisPosition)\n\n\t\t\t// Use user defined domain if specified\n\t\t\tif (customDomain) {\n\t\t\t\treturn customDomain\n\t\t\t}\n\n\t\t\t// Get unique axis values & create a matrix\n\t\t\tthis._ranges = Array.from(\n\t\t\t\tnew Set(\n\t\t\t\t\tdisplayData.map((d: any) => {\n\t\t\t\t\t\treturn d[rangeIdentifier]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn this._ranges\n\t}\n\n\t/**\n\t * Generates a matrix (If doesn't exist) and returns it\n\t * @returns Object\n\t */\n\tgetMatrix() {\n\t\tif (isEmpty(this._matrix)) {\n\t\t\tconst uniqueDomain = this.getUniqueDomain()\n\t\t\tconst uniqueRange = this.getUniqueRanges()\n\n\t\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier()\n\t\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\n\t\t\t// Create a column\n\t\t\tconst range: any = {}\n\t\t\tuniqueRange.forEach((ran: any) => {\n\t\t\t\t// Initialize matrix to empty state\n\t\t\t\trange[ran] = {\n\t\t\t\t\tvalue: null,\n\t\t\t\t\tindex: -1\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// Complete the matrix by cloning the column to all domains\n\t\t\tuniqueDomain.forEach((dom: any) => {\n\t\t\t\tthis._matrix[dom] = cloneDeep(range)\n\t\t\t})\n\n\t\t\t// Fill in user passed data\n\t\t\tthis.getDisplayData().forEach((d: any, i: number) => {\n\t\t\t\tthis._matrix[d[domainIdentifier]][d[rangeIdentifier]] = {\n\t\t\t\t\tvalue: d['value'],\n\t\t\t\t\tindex: i\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn this._matrix\n\t}\n\n\t/**\n\t *\n\t * @param newData The new raw data to be set\n\t */\n\tsetData(newData: any) {\n\t\tconst sanitizedData = this.sanitize(cloneDeep(newData))\n\t\tconst dataGroups = this.generateDataGroups(sanitizedData)\n\n\t\tthis.set({\n\t\t\tdata: sanitizedData,\n\t\t\tdataGroups\n\t\t})\n\n\t\t// Set attributes to empty\n\t\tthis._domains = []\n\t\tthis._ranges = []\n\t\tthis._matrix = {}\n\n\t\treturn sanitizedData\n\t}\n\n\t/**\n\t * Converts Object matrix into a single array\n\t * @returns object[]\n\t */\n\tgetMatrixAsArray(): object[] {\n\t\tif (isEmpty(this._matrix)) {\n\t\t\tthis.getMatrix()\n\t\t}\n\n\t\tconst uniqueDomain = this.getUniqueDomain()\n\t\tconst uniqueRange = this.getUniqueRanges()\n\n\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier()\n\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\n\t\tconst arr: any[] = []\n\t\tuniqueDomain.forEach((domain) => {\n\t\t\tuniqueRange.forEach((range) => {\n\t\t\t\tconst element: any = {\n\t\t\t\t\tvalue: this._matrix[domain][range].value,\n\t\t\t\t\tindex: this._matrix[domain][range].index\n\t\t\t\t}\n\t\t\t\telement[domainIdentifier] = domain\n\t\t\t\telement[rangeIdentifier] = range\n\t\t\t\tarr.push(element)\n\t\t\t})\n\t\t})\n\n\t\treturn arr\n\t}\n\n\t/**\n\t * Generate tabular data from display data\n\t * @returns Array<Object>\n\t */\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\n\t\tconst { primaryDomain, primaryRange } = this.assignRangeAndDomains()\n\n\t\tlet domainValueFormatter: any\n\n\t\tconst result = [\n\t\t\t[primaryDomain.label, primaryRange.label, 'Value'],\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[primaryDomain.identifier] === null\n\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t: domainValueFormatter\n\t\t\t\t\t? domainValueFormatter(datum[primaryDomain.identifier])\n\t\t\t\t\t: datum[primaryDomain.identifier],\n\t\t\t\tdatum[primaryRange.identifier] === null\n\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t: datum[primaryRange.identifier].toLocaleString(),\n\t\t\t\tdatum['value']\n\t\t\t])\n\t\t]\n\n\t\treturn result\n\t}\n\n\t// Uses quantize scale to return class names\n\tgetColorClassName(configs: { value?: number, originalClassName?: string }) {\n\t\treturn `${configs.originalClassName} ${this._colorScale(configs.value as number)}`\n\t}\n\n\tprotected setColorClassNames() {\n\t\tconst options = this.getOptions()\n\n\t\tconst customColors = getProperty(options, 'color', 'gradient', 'colors')\n\t\tconst customColorsEnabled = !isEmpty(customColors)\n\n\t\tlet colorPairingOption = getProperty(options, 'color', 'pairing', 'option')\n\n\t\t// If domain consists of negative and positive values, use diverging palettes\n\t\tconst domain = this.getValueDomain()\n\t\tconst colorScheme = domain[0] < 0 && domain[1] > 0 ? 'diverge' : 'mono'\n\n\t\t// Use default color pairing options if not in defined range\n\t\tif (colorPairingOption < 1 && colorPairingOption > 4 && colorScheme === 'mono') {\n\t\t\tcolorPairingOption = 1\n\t\t} else if (colorPairingOption < 1 && colorPairingOption > 2 && colorScheme === 'diverge') {\n\t\t\tcolorPairingOption = 1\n\t\t}\n\n\t\t// Uses css classes for fill\n\t\tconst colorPairing = customColorsEnabled ? customColors : []\n\n\t\tif (!customColorsEnabled) {\n\t\t\t// Add class names to list and the amount based on the color scheme\n\t\t\t// Carbon charts has 11 colors for a single monochromatic palette & 17 for a divergent palette\n\t\t\tconst colorGroupingLength = colorScheme === 'diverge' ? 17 : 11\n\t\t\tfor (let i = 1; i < colorGroupingLength + 1; i++) {\n\t\t\t\tcolorPairing.push(`fill-${colorScheme}-${colorPairingOption}-${i}`)\n\t\t\t}\n\t\t}\n\n\t\t// Save scale type\n\t\tthis._colorScale = scaleQuantize()\n\t\t\t.domain(domain as [number, number])\n\t\t\t.range(colorPairing)\n\t\tconst colorOptions = getProperty(this.getOptions(), 'color')\n\t\tthis._colorScale = getColorScale(this.getDisplayData(), colorOptions)\n\t}\n}\n","// Internal Imports\nimport { ChartModelCartesian } from './cartesian-charts'\n\nimport { get } from 'lodash-es'\n\n/**\n * this is intended for binned type of charts\n * */\nexport class ChartModelBinned extends ChartModelCartesian {\n\tgetTabularDataArray() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst binnedStackedData = this.getBinnedStackedData()\n\n\t\tconst result = [\n\t\t\t[\n\t\t\t\tget(options, 'bins.rangeLabel') || 'Range',\n\t\t\t\t...binnedStackedData.map((datum) => get(datum, `0.${groupMapsTo}`))\n\t\t\t],\n\t\t\t...get(binnedStackedData, 0).map((d, i) => [\n\t\t\t\t`${get(d, 'data.x0')} â€“ ${get(d, 'data.x1')}`,\n\t\t\t\t...binnedStackedData.map((datum) => get(datum[i], `data.${get(datum[i], groupMapsTo)}`))\n\t\t\t])\n\t\t]\n\n\t\treturn result\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModel } from './model'\nimport { ChartTabularData } from '@/interfaces/model'\n\n/** The meter chart model layer which extends some of the data setting options.\n * Meter only uses 1 dataset\n *  */\n\nexport class MeterChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetMaximumDomain(data: any) {\n\t\tconst max = data.reduce((accumulator: number, datum: any) => accumulator + datum.value, 0)\n\t\treturn max\n\t}\n\n\t/**\n\t * Use a provided color for the bar or default to carbon color if no status provided.\n\t * Defaults to carbon color otherwise.\n\t * @param group dataset group label\n\t */\n\tgetFillColor(group: string) {\n\t\tconst options = this.getOptions()\n\t\tconst userProvidedScale = getProperty(options, 'color', 'scale')\n\t\tconst status = this.getStatus()\n\t\t// user provided a fill color or there isn't a status we can use the colorScale\n\t\tif (userProvidedScale || !status) {\n\t\t\treturn super.getFillColor(group)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/**\n\t * Get the associated status for the data by checking the ranges\n\t */\n\tgetStatus() {\n\t\tconst options = this.getOptions()\n\t\tconst dataValues = getProperty(this.getDisplayData())\n\n\t\tconst totalValue =\n\t\t\tdataValues?.reduce((previous: any, current: any) => {\n\t\t\t\treturn previous + current.value\n\t\t\t}, 0) ?? 0\n\n\t\t// use max value if the percentage is bigger than 100%\n\t\tconst boundedValue = getProperty(options, 'meter', 'proportional')\n\t\t\t? totalValue\n\t\t\t: totalValue > 100\n\t\t\t? 100\n\t\t\t: totalValue\n\n\t\t// user needs to supply ranges\n\t\tconst allRanges = getProperty(options, 'meter', 'status', 'ranges')\n\n\t\tif (allRanges) {\n\t\t\tconst result = allRanges.filter(\n\t\t\t\t(step: any) => step.range[0] <= boundedValue && boundedValue <= step.range[1]\n\t\t\t)\n\t\t\tif (result.length > 0) {\n\t\t\t\treturn result[0].status\n\t\t\t}\n\t\t}\n\n\t\treturn null\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst status = this.getStatus()\n\t\tconst proportional = getProperty(options, 'meter', 'proportional')\n\n\t\tlet result: ChartTabularData = []\n\t\tlet domainMax: number\n\t\t// Display the appropriate columns and fields depending on the type of meter\n\t\tif (proportional === null) {\n\t\t\tdomainMax = 100\n\t\t\tconst datum = displayData[0]\n\n\t\t\tresult = [\n\t\t\t\t['Group', 'Value', ...(status ? ['Status'] : [])],\n\t\t\t\t[datum[groupMapsTo], datum['value'], ...(status ? [status] : [])]\n\t\t\t]\n\t\t} else {\n\t\t\tconst total = getProperty(proportional, 'total')\n\t\t\tdomainMax = total ? total : this.getMaximumDomain(displayData)\n\n\t\t\tresult = [\n\t\t\t\t['Group', 'Value', 'Percentage of total'],\n\t\t\t\t...displayData.map((datum: any) => [\n\t\t\t\t\tdatum[groupMapsTo],\n\t\t\t\t\tdatum['value'],\n\t\t\t\t\t((datum['value'] / domainMax) * 100).toFixed(2) + ' %'\n\t\t\t\t])\n\t\t\t]\n\t\t}\n\n\t\treturn result\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class RadarChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst options = this.getOptions()\n\n\t\tconst groupedData = this.getGroupedData()\n\n\t\tconst { angle, value } = getProperty(options, 'radar', 'axes')\n\n\t\tconst additionalHeaders = getProperty(groupedData, '0', 'data').map((d: any) => d[angle])\n\n\t\tconst result = [\n\t\t\t['Group', ...additionalHeaders],\n\t\t\t...groupedData.map((datum) => {\n\t\t\t\treturn [\n\t\t\t\t\tdatum['name'],\n\t\t\t\t\t...additionalHeaders.map((_: any, i: number) =>\n\t\t\t\t\t\tgetProperty(datum, 'data', i, value) !== null\n\t\t\t\t\t\t\t? getProperty(datum, 'data', i, value).toLocaleString()\n\t\t\t\t\t\t\t: '&ndash;'\n\t\t\t\t\t)\n\t\t\t\t]\n\t\t\t})\n\t\t]\n\n\t\treturn result\n\t}\n}\n","import { ChartModel } from './model'\n\n/**\n * The tree chart model layer\n */\nexport class TreeChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\n\t\tconst result = [['Child', 'Parent']]\n\n\t\tdisplayData.forEach((datum: any) => {\n\t\t\t// Call recurisve function\n\t\t\tthis.getChildrenDatums(datum, result)\n\t\t\tresult.push([datum.name, '&ndash;'])\n\t\t})\n\n\t\treturn result\n\t}\n\n\t/**\n\t * Determine the child parent relationship in nested data\n\t * @param datum: Object\n\t * @param result: Array<Object>\n\t */\n\tprivate getChildrenDatums(datum: any, result: any[] = []) {\n\t\t// Check to see if datum has children before iterating through it\n\t\tif (datum.children) {\n\t\t\tif (datum.children.length > 0) {\n\t\t\t\tdatum.children.forEach((child: any) => {\n\t\t\t\t\tthis.getChildrenDatums(child, result)\n\t\t\t\t\tresult.push([child.name, datum.name])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModel } from './model'\n\n/**\n * The treemap chart model layer\n */\nexport class TreemapChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\n\t\tconst result = [['Child', 'Group', 'Value']]\n\n\t\tdisplayData.forEach((datum: any) => {\n\t\t\tif (Array.isArray(datum.children)) {\n\t\t\t\tdatum.children.forEach((child: any) => {\n\t\t\t\t\tresult.push([child.name, datum.name, child.value])\n\t\t\t\t})\n\t\t\t} else if (getProperty(datum.name) !== null && getProperty(datum.value)) {\n\t\t\t\tresult.push(['â€“', datum.name, datum.value])\n\t\t\t}\n\t\t})\n\n\t\treturn result\n\t}\n}\n","import { ChartModel } from './model'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class WordCloudModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\n\t\tconst options = this.getOptions()\n\t\tconst { fontSizeMapsTo, wordMapsTo } = options.wordCloud\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst result = [\n\t\t\t[options.tooltip.wordLabel, 'Group', options.tooltip.valueLabel],\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[wordMapsTo],\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tdatum[fontSizeMapsTo]\n\t\t\t])\n\t\t]\n\n\t\treturn result\n\t}\n}\n"],"names":["arrayAggregator","array","setter","iteratee","accumulator","index","length","value","baseAggregator","collection","baseEach","key","createAggregator","initializer","func","isArray","baseIteratee","fromPairs","pairs","result","pair","objectProto","hasOwnProperty","groupBy","baseAssignValue","groupBy$1","ChartModel","services","groups","options","allData","dataGroups","groupMapsTo","getProperty","axesOptions","item","axis","mapsTo","scaleType","ScaleTypes","datum","start","end","group","ACTIVE","legendConfigs","dataGroup","newData","sanitizedData","cloneDeep","bin","data","mainXPos","domainIdentifier","axisOptions","axisBins","histogramConfigs","areBinsDefined","bins","d3Bin","binsWidth","binsDomain","groupsKeys","histogramData","aggregateDataByGroup","dataGroupNames","dataValuesGroupedByKeys","stack","series","i","element","displayData","groupedData","groupName","stackKeys","uniq","formatDateTillMilliSeconds","axisPosition","a","b","dateA","dateB","binStart","binEnd","correspondingValues","correspondingBin","dataGroupName","binItem","correspondingDatum","rangeIdentifier","percentage","divergent","maxByKey","d","name","denominator","stackOffsetDiverging","newState","configs","newConfig","property","newOptions","updateLegendAdditionalItems","merge","animate","Events","changedLabel","DISABLED","hasDeactivatedItems","activeItems","_","indexToChange","updatedActiveItems","activeItem","defaultFilled","defaultFillColor","defaultStrokeColor","userProvidedScale","colorPairingTag","className","type","tabularData","datasets","labels","dataset","datasetLabel","correspondingLabel","updatedDatum","row","column","csvString","csvData","uniqueDataGroups","getStatus","colorPairingOptions","numberOfVariants","pairingOption","colorPairingCounts","colorConfigs","numberOfColors","colorPairing","scaleOrdinal","ChartModelCartesian","AxisFlavor","cartesianScales","isDualAxes","scales","scale","position","primaryDomain","primaryRange","secondaryDomain","secondaryRange","domainScaleType","domainValueFormatter","format","AxisPositions","definedZoomBarData","newZoomBarData","zoomBarNormalizedValues","allDates","date","sum","keysToCheck","axisPositionKey","axisMapsTo","AlluvialChartModel","BoxplotChartModel","quantile","boxplotData","values","ascending","record","q1","q3","iqr","irq1","irq3","outliers","normalValues","minNormalValue","min","maxNormalValue","max","BulletChartModel","matchingRangeIndex","range","performanceAreaTitles","ChoroplethModel","isEmpty","country","colorOptions","getColorScale","CirclePackChartModel","zoomOptions","depth","userProvidedDepth","LegendItemType","depthOne","node","child","children","parent","totalSum","grandParent","parentWithinIteration","PieChartModel","GaugeChartModel","HeatmapModel","limits","extent","domain","scaleLinear","mainXAxisPosition","customDomain","mainYAxisPosition","uniqueDomain","uniqueRange","ran","dom","arr","customColors","customColorsEnabled","colorPairingOption","colorScheme","colorGroupingLength","scaleQuantize","ChartModelBinned","binnedStackedData","get","MeterChartModel","status","dataValues","totalValue","previous","current","boundedValue","allRanges","step","proportional","domainMax","total","RadarChartModel","angle","additionalHeaders","TreeChartModel","TreemapChartModel","WordCloudModel","fontSizeMapsTo","wordMapsTo"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}